{
  "methods": [
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns a {@code Method} object that reflects the specified declared method of the class or interface represented by this {@code Class} object. The {@code name} parameter is a {@code String} that specifies the simple name of the desired method, and the {@code parameterTypes} parameter is an array of {@code Class} objects that identify the method's formal parameter types, in declared order. If more than one method with the same parameter types is declared in a class, and one of these methods has a return type that is more specific than any of the others, that method is returned; otherwise one of the methods is chosen arbitrarily. If the name is \"\"or \"\" a {@code NoSuchMethodException} is raised. If this {@code Class} object represents an array type, then this method does not find the {@code clone()} method.",
        "class": "Instances of the class {@code Class} represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a {@code Class} object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code int}, {@code long}, {@code float}, and {@code double}), and the keyword {@code void} are also represented as {@code Class} objects. {@code Class} has no public constructor. Instead {@code Class} objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the {@code defineClass} method in the class loader. The following example uses a {@code Class} object to print the class name of an object:      void printClassName(Object obj) {\n         System.out.println(\"The class of \" + obj +\n                            \" is \" + obj.getClass().getName());\n     }\n It is also possible to get the {@code Class} object for a named type (or for void) using a class literal. See Section 15.8.2 of The Javaâ„¢ Language Specification. For example: {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.Class.getDeclaredMethod",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.Class[]"
      ],
      "return": "java.lang.reflect.Method",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Persist the given transient instance, first assigning a generated identifier. (Or using the current value of the identifier property if the assigned generator is used.) This operation cascades to associated instances if the association is mapped with {@code cascade=\"save-update\"}",
        "class": "Concrete implementation of a Session. Exposes two interfaces: {@link org.hibernate.Session} to the application {@link org.hibernate.engine.spi.SessionImplementor} to other Hibernate components (SPI) This class is not thread-safe."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.hibernate.internal.SessionImpl.save",
      "jar": "hibernate-core-5.2.10.Final.jar",
      "comment": "",
      "parameters": [
        "java.lang.Object"
      ],
      "return": "java.io.Serializable",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Attempts to establish a connection to the given database URL. The DriverManager attempts to select an appropriate driver from the set of registered JDBC drivers. Note: If the {@code user} or {@code password} property are also specified as part of the {@code url}, it is implementation-defined as to which value will take precedence. For maximum portability, an application should only specify a property once.",
        "class": "The basic service for managing a set of JDBC drivers. NOTE: The {@link javax.sql.DataSource} interface, new in the JDBC 2.0 API, provides another way to connect to a data source. The use of a DataSource object is the preferred means of connecting to a data source. As part of its initialization, the DriverManager class will attempt to load the driver classes referenced in the \"jdbc.drivers\" system property. This allows a user to customize the JDBC Drivers used by their applications. For example in your ~\/.hotjava\/properties file you might specify:  jdbc.drivers=foo.bah.Driver:wombat.sql.Driver:bad.taste.ourDriver\n The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition Service Provider mechanism. JDBC 4.0 Drivers must include the file META-INF\/services\/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF\/services\/java.sql.Driver file would contain the entry:  my.sql.Driver\n Applications no longer need to explicitly load JDBC drivers using Class.forName(). Existing programs which currently load JDBC drivers using Class.forName() will continue to work without modification. When the method getConnection is called, the DriverManager will attempt to locate a suitable driver from amongst those loaded at initialization and those loaded explicitly using the same classloader as the current applet or application. Starting with the Java 2 SDK, Standard Edition, version 1.3, a logging stream can be set only if the proper permission has been granted. Normally this will be done with the tool PolicyTool, which can be used to grant permission java.sql.SQLPermission \"setLog\"."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.sql.DriverManager.getConnection",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.sql.Connection",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getPathInfo() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getPathInfo",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": "Mock implementation of the {@link javax.portlet.PortletRequest} interface."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.mock.web.portlet.MockPortletRequest.setParameter",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to return setAttribute(String name, Object o) on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.setAttribute",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.Object"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.ClientProperties.getNavigatorUserAgent",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to call setIntHeader(String name, int value) on the wrapped response object.",
        "class": "Provides a convenient implementation of the HttpServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletResponseWrapper.setIntHeader",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Log a method entry. This is a convenience method that can be used to log entry to a method. A LogRecord with message \"ENTRY\", log level FINER, and the given sourceMethod and sourceClass is logged.",
        "class": "A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the {@code getLogger} factory methods may be garbage collected at any time if a strong reference to the Logger is not kept. Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree. The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent. On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree. Each Logger may have a {@code ResourceBundle} associated with it. The {@code ResourceBundle} may be specified by name, using the {@link #getLogger(java.lang.String, java.lang.String)} factory method, or by value - using the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method. This bundle will be used for localizing logging messages. If a Logger does not have its own {@code ResourceBundle} or resource bundle name, then it will inherit the {@code ResourceBundle} or resource bundle name from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument. These methods take a {@link Supplier}{@code } function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       \/\/ collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled. \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n When looking for a {@code ResourceBundle}, the logger will first look at whether a bundle was specified using {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then only whether a resource bundle name was specified through the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. If no {@code ResourceBundle} or no resource bundle name is found, then it will use the nearest {@code ResourceBundle} or resource bundle name inherited from its parent tree. When a {@code ResourceBundle} was inherited or specified through the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then that {@code ResourceBundle} will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a {@code ResourceBundle} object, using the default Locale at the time of logging. When mapping resource bundle names to {@code ResourceBundle} objects, the logger will first try to use the Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class loader} to map the given resource bundle name to a {@code ResourceBundle}. If the thread context class loader is {@code null}, it will try the {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader} instead. If the {@code ResourceBundle} is still not found, it will use the class loader of the first caller of the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string. There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name. There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message. There are convenience methods for tracing method entries (the \"entering\" methods), method returns (the \"exiting\" methods) and throwing exceptions (the \"throwing\" methods). Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string. For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.logging.Logger.entering",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/jca\/cci\/connection\/SingleConnectionFactory.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Create a new SingleConnectionFactory for bean-style usage.",
        "class": "A CCI ConnectionFactory adapter that returns the same Connection on all {@code getConnection} calls, and ignores calls to {@code Connection.close()}. Useful for testing and standalone environments, to keep using the same Connection for multiple CciTemplate calls, without having a pooling ConnectionFactory, also spanning any number of transactions. You can either pass in a CCI Connection directly, or let this factory lazily create a Connection via a given target ConnectionFactory."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.jca.cci.connection.SingleConnectionFactory.<init>",
      "jar": null,
      "comment": "Counter example for authentication (init)",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/3.2.6.RELEASE\/apidocs\/org\/springframework\/security\/core\/userdetails\/UserDetailsByNameServiceWrapper.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE862"
      ],
      "javadoc": {
        "method": "Get the UserDetails object from the wrapped UserDetailsService implementation",
        "class": "This implementation for AuthenticationUserDetailsService wraps a regular Spring Security UserDetailsService implementation, to retrieve a UserDetails object based on the user name contained in an Authentication object."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper.loadUserDetails",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "org.springframework.security.core.Authentication"
      ],
      "return": "org.springframework.security.core.userdetails.UserDetails",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/commons.apache.org\/proper\/commons-lang\/javadocs\/api-3.1\/org\/apache\/commons\/lang3\/text\/StrSubstitutor.html",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE306",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Replaces all the occurrences of variables with their matching values from the resolver using the given source array as a template. The array is not altered by this method.",
        "class": "Substitutes variables within a string by values. This class takes a piece of text and substitutes all the variables within it. The default definition of a variable is {@code ${variableName}}. The prefix and suffix can be changed via constructors and set methods. Variable values are typically resolved from a map, but could also be resolved from system properties, or by supplying a custom variable resolver. The simplest example is to use this class to replace Java System properties. For example:  StrSubstitutor.replaceSystemProperties(\n      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n Typical usage of this class follows the following pattern: First an instance is created and initialized with the map that contains the values for the available variables. If a prefix and\/or suffix for variables should be used other than the default ones, the appropriate settings can be performed. After that the {@code replace()} method can be called passing in the source text for interpolation. In the returned text all variable references (as long as their values are known) will be resolved. The following example demonstrates this:  Map valuesMap = HashMap();\n valuesMap.put(\"animal\", \"quick brown fox\");\n valuesMap.put(\"target\", \"lazy dog\");\n String templateString = \"The ${animal} jumps over the ${target}.\";\n StrSubstitutor sub = new StrSubstitutor(valuesMap);\n String resolvedString = sub.replace(templateString);\n yielding:       The quick brown fox jumps over the lazy dog.\n Also, this class allows to set a default value for unresolved variables. The default value for a variable can be appended to the variable name after the variable default value delimiter. The default value of the variable default value delimiter is ':-', as in bash and other *nix shells, as those are arguably where the default ${} delimiter set originated. The variable default value delimiter can be manually set by calling {@link #setValueDelimiterMatcher(StrMatcher)}, {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}. The following shows an example with variable default value settings:  Map valuesMap = HashMap();\n valuesMap.put(\"animal\", \"quick brown fox\");\n valuesMap.put(\"target\", \"lazy dog\");\n String templateString = \"The ${animal} jumps over the ${target}. ${undefined.number:-1234567890}.\";\n StrSubstitutor sub = new StrSubstitutor(valuesMap);\n String resolvedString = sub.replace(templateString);\n yielding:       The quick brown fox jumps over the lazy dog. 1234567890.\n In addition to this usage pattern there are some static convenience methods that cover the most common use cases. These methods can be used without the need of manually creating an instance. However if multiple replace operations are to be performed, creating and reusing an instance of this class will be more efficient. Variable replacement works in a recursive way. Thus, if a variable value contains a variable then that variable will also be replaced. Cyclic replacements are detected and will cause an exception to be thrown. Sometimes the interpolation's result must contain a variable prefix. As an example take the following source text:    The variable ${${name}} must be used.\n Here only the variable's name referred to in the text should be replaced resulting in the text (assuming that the value of the {@code name} variable is {@code x}):    The variable ${x} must be used.\n To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do not conflict with the result text you want to produce. The other possibility is to use the escape character, by default '$'. If this character is placed before a variable reference, this reference is ignored and won't be replaced. For example:    The variable $${${name}} must be used.\n In some complex scenarios you might even want to perform substitution in the names of variables, for instance  ${jre-${java.specification.version}}\n {@code StrSubstitutor} supports this recursive substitution in variable names, but it has to be enabled explicitly by setting the {@link #setEnableSubstitutionInVariables(boolean) enableSubstitutionInVariables} property to true. This class is not thread safe."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.lang3.text.StrSubstitutor.replace",
      "jar": null,
      "comment": "",
      "parameters": [
        "char[]"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/DigestScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces a digest authorization string for the given set of {@link Credentials}, method name and URI.",
        "class": "Digest authentication scheme as defined in RFC 2617. Both MD5 (default) and MD5-sess are supported. Currently only qop=auth or no qop is supported. qop=auth-int is unsupported. If auth and auth-int are provided, auth is used. Credential charset is configured via the {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET} parameter of the HTTP request. Since the digest username is included as clear text in the generated Authentication header, the charset of the username must be compatible with the {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET http element charset}. The following parameters can be used to customize the behavior of this class: {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET}"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.auth.DigestScheme.authenticate",
      "jar": null,
      "comment": "Produces an authentication string for the given credentials.",
      "parameters": [
        "org.apache.http.auth.Credentials",
        "org.apache.http.HttpRequest"
      ],
      "return": "org.apache.http.Header",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/NTLMScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces an authorization string for the given set of {@link Credentials}.",
        "class": "NTLM is a proprietary authentication scheme developed by Microsoft and optimized for Windows platforms."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.auth.NTLMScheme.authenticate",
      "jar": null,
      "comment": "Produces an authentication string for the given credentials.",
      "parameters": [
        "org.apache.http.auth.Credentials",
        "org.apache.http.HttpRequest"
      ],
      "return": "org.apache.http.Header",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.springframework.web.filter.DelegatingFilterProxy.class$",
      "jar": null,
      "comment": "Counter example for sanitizer (String param, but implicit method)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.Class",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Gets the system property indicated by the specified key. First, if there is a security manager, its checkPropertyAccess method is called with the key as its argument. If there is no current set of system properties, a set of system properties is first created and initialized in the same manner as for the getProperties method.",
        "class": "The System class contains several useful class fields and methods. It cannot be instantiated. Among the facilities provided by the System class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.lang.System.getProperty",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/BasicScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces basic authorization string for the given set of {@link Credentials}.",
        "class": "Basic authentication scheme as defined in RFC 2617."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.BasicScheme.authenticate",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "org.apache.commons.httpclient.Credentials",
        "org.apache.commons.httpclient.HttpMethod"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/xml.apache.org\/xalan-j\/apidocs\/org\/apache\/xalan\/xsltc\/runtime\/BasisLibrary.html",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Replace a certain character in a string with a new substring.",
        "class": "Standard XSLT functions. All standard functions expect the current node and the DOM as their last two arguments."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xalan.xsltc.runtime.BasisLibrary.replace",
      "jar": null,
      "comment": "String replacement",
      "parameters": [
        "java.lang.String",
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0,
          1,
          2
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "This method encodes for JavaScript strings contained within HTML script blocks. It is NOT safe for use in script attributes (such as onclick). The caller must provide the surrounding quotation characters. This method performs the same encode as {@link #forJavaScript(String)} with the exception that \" and ' are encoded as \\\" and \\' respectively. Unless you are interested in saving a few bytes of output or are writing a framework on top of this library, it is recommend that you use {@link #forJavaScript(String)} over this method. Example JSP Usage:     \n        var data = \"\";",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forJavaScriptBlock",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/NTLMScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Create a NTLM authorization string for the given challenge and NT credentials.",
        "class": "An implementation of the Microsoft proprietary NTLM authentication scheme. For a detailed explanation of the NTLM scheme please see http:\/\/davenport.sourceforge.net\/ntlm.html."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.NTLMScheme.authenticate",
      "jar": null,
      "comment": "Depricated method. The credentials are provided. The authentication string is returned.",
      "parameters": [
        "org.apache.commons.httpclient.NTCredentials",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getParameterNames() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getParameterNames",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.util.Enumeration",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/HttpServletRequestImpl.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Gets the real path corresponding to the given virtual path. For example, if path is equal to \/index.html, this method will return the absolute file path on the server's filesystem to which a request of the form http:\/\/&lt;host&gt;:&lt;port&gt;\/&lt;contextPath&gt;\/index.html would be mapped, where &lt;contextPath&gt; corresponds to the context path of this ServletContext. The real path returned will be in a form appropriate to the computer and operating system on which the servlet container is running, including the proper path separators. Resources inside the \/META-INF\/resources directories of JAR files bundled in the application's \/WEB-INF\/lib directory must be considered only if the container has unpacked them from their containing JAR file, in which case the path to the unpacked location must be returned. This method returns null if the servlet container is unable to translate the given virtual path to a real path.",
        "class": "Stub implementation of a {@link javax.servlet.http.HttpServletRequest} with lots of unimplemented methods. I implemented only those, which are required for testing the {@link org.apache.xmlrpc.webserver.XmlRpcServlet}. Perhaps someone else is adding more at a later time?"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.HttpServletRequestImpl.getRealPath",
      "jar": null,
      "comment": "Counter example for sanitizer.",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Log an INFO message. If the logger is currently enabled for the INFO message level then the given message is forwarded to all the registered output Handler objects.",
        "class": "A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the {@code getLogger} factory methods may be garbage collected at any time if a strong reference to the Logger is not kept. Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree. The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent. On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree. Each Logger may have a {@code ResourceBundle} associated with it. The {@code ResourceBundle} may be specified by name, using the {@link #getLogger(java.lang.String, java.lang.String)} factory method, or by value - using the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method. This bundle will be used for localizing logging messages. If a Logger does not have its own {@code ResourceBundle} or resource bundle name, then it will inherit the {@code ResourceBundle} or resource bundle name from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument. These methods take a {@link Supplier}{@code } function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       \/\/ collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled. \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n When looking for a {@code ResourceBundle}, the logger will first look at whether a bundle was specified using {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then only whether a resource bundle name was specified through the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. If no {@code ResourceBundle} or no resource bundle name is found, then it will use the nearest {@code ResourceBundle} or resource bundle name inherited from its parent tree. When a {@code ResourceBundle} was inherited or specified through the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then that {@code ResourceBundle} will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a {@code ResourceBundle} object, using the default Locale at the time of logging. When mapping resource bundle names to {@code ResourceBundle} objects, the logger will first try to use the Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class loader} to map the given resource bundle name to a {@code ResourceBundle}. If the thread context class loader is {@code null}, it will try the {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader} instead. If the {@code ResourceBundle} is still not found, it will use the class loader of the first caller of the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string. There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name. There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message. There are convenience methods for tracing method entries (the \"entering\" methods), method returns (the \"exiting\" methods) and throwing exceptions (the \"throwing\" methods). Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string. For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.logging.Logger.info",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/web\/servlet\/tags\/UrlTag.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Build the query string from available parameters that have not already been applied as template params. The names and values of parameters are URL encoded.",
        "class": "JSP tag for creating URLs. Modeled after the JSTL c:url tag with backwards compatibility in mind. Enhancements to the JSTL functionality include: URL encoded template URI variables HTML\/XML escaping of URLs JavaScript escaping of URLs Template URI variables are indicated in the {@link #setValue(String) 'value'} attribute and marked by braces '{variableName}'. The braces and attribute name are replaced by the URL encoded value of a parameter defined with the spring:param tag in the body of the url tag. If no parameter is available the literal value is passed through. Params matched to template variables will not be added to the query string. Use of the spring:param tag for URI template variables is strongly recommended over direct EL substitution as the values are URL encoded. Failure to properly encode URL can leave an application vulnerable to XSS and other injection attacks. URLs can be HTML\/XML escaped by setting the {@link #setHtmlEscape(boolean) 'htmlEscape'} attribute to 'true'. Detects an HTML escaping setting, either on this tag instance, the page level, or the {@code web.xml} level. The default is 'false'. When setting the URL value into a variable, escaping is not recommended. Example usage: \n   \n  Results in: {@code \/currentApplicationContext\/url\/path\/more%20than%20JSTL%20c%3Aurl}"
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.servlet.tags.UrlTag.createQueryString",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.util.List",
        "java.util.Set",
        "boolean"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/beans\/factory\/support\/MethodOverrides.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Return whether the set of method overrides is empty.",
        "class": "Set of method overrides, determining which, if any, methods on a managed object the Spring IoC container will override at runtime. The currently supported {@link MethodOverride} variants are {@link LookupOverride} and {@link ReplaceOverride}."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.beans.factory.support.MethodOverrides.isEmpty",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/BasicScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces basic authorization string for the given set of {@link Credentials}.",
        "class": "Basic authentication scheme as defined in RFC 2617."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.BasicScheme.authenticate",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "org.apache.commons.httpclient.UsernamePasswordCredentials"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/messaging\/simp\/stomp\/StompDecoder.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "See STOMP Spec 1.2: \"Value Encoding\".",
        "class": "Decodes one or more STOMP frames contained in a {@link ByteBuffer}. An attempt is made to read all complete STOMP frames from the buffer, which could be zero, one, or more. If there is any left-over content, i.e. an incomplete STOMP frame, at the end the buffer is reset to point to the beginning of the partial content. The caller is then responsible for dealing with that incomplete content by buffering until there is more input available."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.messaging.simp.stomp.StompDecoder.unescape",
      "jar": null,
      "comment": "Counter example for sanitizer (unescape)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/balzaczyy\/pebble-clone\/blob\/master\/src\/main\/java\/net\/sourceforge\/pebble\/event\/AuditListener.java",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Called when a blog entry has been unpublished.",
        "class": ""
      },
      "framework": "pebble",
      "discovery": "manual",
      "name": "net.sourceforge.pebble.event.AuditListener.blogEntryUnpublished",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [
        "net.sourceforge.pebble.api.event.blogentry.BlogEntryEvent"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Return the persistent instance of the given entity class with the given identifier, assuming that the instance exists. This method might return a proxied instance that is initialized on-demand, when a non-identifier method is accessed. You should not use this method to determine if an instance exists (use get() instead). Use this only to retrieve an instance that you assume exists, where non-existence would be an actual error.",
        "class": "Concrete implementation of a Session. Exposes two interfaces: {@link org.hibernate.Session} to the application {@link org.hibernate.engine.spi.SessionImplementor} to other Hibernate components (SPI) This class is not thread-safe."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.hibernate.internal.SessionImpl.load",
      "jar": "hibernate-core-5.2.10.Final.jar",
      "comment": "",
      "parameters": [
        "java.lang.Class",
        "java.io.Serializable"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/web\/servlet\/tags\/UrlTag.html",
      "type": [
        "sink",
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Build the URL for the tag from the tag attributes and parameters.",
        "class": "JSP tag for creating URLs. Modeled after the JSTL c:url tag with backwards compatibility in mind. Enhancements to the JSTL functionality include: URL encoded template URI variables HTML\/XML escaping of URLs JavaScript escaping of URLs Template URI variables are indicated in the {@link #setValue(String) 'value'} attribute and marked by braces '{variableName}'. The braces and attribute name are replaced by the URL encoded value of a parameter defined with the spring:param tag in the body of the url tag. If no parameter is available the literal value is passed through. Params matched to template variables will not be added to the query string. Use of the spring:param tag for URI template variables is strongly recommended over direct EL substitution as the values are URL encoded. Failure to properly encode URL can leave an application vulnerable to XSS and other injection attacks. URLs can be HTML\/XML escaped by setting the {@link #setHtmlEscape(boolean) 'htmlEscape'} attribute to 'true'. Detects an HTML escaping setting, either on this tag instance, the page level, or the {@code web.xml} level. The default is 'false'. When setting the URL value into a variable, escaping is not recommended. Example usage: \n   \n  Results in: {@code \/currentApplicationContext\/url\/path\/more%20than%20JSTL%20c%3Aurl}"
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.servlet.tags.UrlTag.createUrl",
      "jar": null,
      "comment": "Source training set",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "This method encodes for HTML text attributes. Example JSP Usage      \n Encoding Table Input Result {@code &} {@code &} {@code }) is not required for attributes. Numeric encoding is used for double-quote character ({@code \"}) as it shorter than the also valid {@code \"}. Carriage return (U+0D), line-feed (U+0A), horizontal tab (U+09) and space (U+20) are valid in quoted attributes and in block in an unescaped form. Surrogate pairs are passed through only if valid. Characters that are not valid according to the XML specification are replaced by a space character as they could lead to parsing errors. In particular only {@code #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]} are considered valid.",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forHtmlAttribute",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/4.3.9.RELEASE\/javadoc-api\/org\/springframework\/jca\/cci\/connection\/ConnectionFactoryUtils.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.jca.cci.connection.ConnectionFactoryUtils.<init>",
      "jar": null,
      "comment": "Counter example for authentication (init)",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/docs.spring.io\/autorepo\/docs\/spring-security\/3.2.9.RELEASE\/apidocs\/org\/springframework\/security\/authentication\/UsernamePasswordAuthenticationToken.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "See {@link #isAuthenticated()} for a full description. Implementations should always allow this method to be called with a false parameter, as this is used by various classes to specify the authentication token should not be trusted. If an implementation wishes to reject an invocation with a true parameter (which would indicate the authentication token is trusted - a potential security risk) the implementation should throw an {@link IllegalArgumentException}.",
        "class": "An {@link org.springframework.security.core.Authentication} implementation that is designed for simple presentation of a username and password. The principal and credentials should be set with an Object that provides the respective property via its Object.toString() method. The simplest such Object to use is String."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.authentication.UsernamePasswordAuthenticationToken.setAuthenticated",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted. So the security level depentd on this fact.",
      "parameters": [
        "boolean"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Turn special characters into HTML character references. Handles complete character set defined in HTML 4.01 recommendation. Escapes all special characters to their corresponding numeric reference in hex format (&#xHex;). Reference: http:\/\/www.w3.org\/TR\/html4\/sgml\/entities.html",
        "class": "Utility class for HTML escaping. Escapes and unescapes based on the W3C HTML 4.01 recommendation, handling character entity references. Reference: http:\/\/www.w3.org\/TR\/html4\/charset.html For a comprehensive set of String escaping utilities, consider Apache Commons Lang and its StringEscapeUtils class. We are not using that class here to avoid a runtime dependency on Commons Lang just for HTML escaping. Furthermore, Spring's HTML escaping is more flexible and 100% HTML 4.0 compliant."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.springframework.web.util.HtmlUtils.htmlEscapeHex",
      "jar": "spring-web-4.3.9.RELEASE.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/shiro.apache.org\/static\/1.2.1\/apidocs\/org\/apache\/shiro\/subject\/support\/DelegatingSubject.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Logs out this Subject and invalidates and\/or removes any associated entities, such as a {@link Session Session} and authorization data. After this method is called, the Subject is considered 'anonymous' and may continue to be used for another log-in if desired. Web Environment Warning Calling this method in web environments will usually remove any associated session cookie as part of session invalidation. Because cookies are part of the HTTP header, and headers can only be set before the response body (html, image, etc) is sent, this method in web environments must be called before any content has been rendered. The typical approach most applications use in this scenario is to redirect the user to a different location (e.g. home page) immediately after calling this method. This is an effect of the HTTP protocol itself and not a reflection of Shiro's implementation. Non-HTTP environments may of course use a logged-out subject for login again if desired.",
        "class": "Implementation of the {@code Subject} interface that delegates method calls to an underlying {@link org.apache.shiro.mgt.SecurityManager SecurityManager} instance for security checks. It is essentially a {@code SecurityManager} proxy. This implementation does not maintain state such as roles and permissions (only {@code Subject} {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless architecture. It instead asks the underlying {@code SecurityManager} every time to perform the authorization check. A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would be \"hit\" every time a method is called. This is not necessarily the case and is up to the implementation of the underlying {@code SecurityManager} instance. If caching of authorization data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered much more elegant to let the underlying {@code SecurityManager} implementation or its delegate components manage caching, not this class. A {@code SecurityManager} is considered a business-tier component, where caching strategies are better managed. Applications from large and clustered to simple and JVM-local all benefit from stateless architectures. This implementation plays a part in the stateless programming paradigm and should be used whenever possible."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.shiro.subject.support.DelegatingSubject.logout",
      "jar": null,
      "comment": "Logout",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getRemoteAddr() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getRemoteAddr",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/XmlRpcServlet.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Writes the specified message to a servlet log file, usually an event log. The name and type of the servlet log file is  specific to the servlet container.",
        "class": "A default servlet implementation The typical use would be to derive a subclass, which is overwriting at least the method {@link #newXmlRpcHandlerMapping()}. The servlet accepts the following init parameters: Name Description enabledForExtensions Sets the value {@link XmlRpcConfig#isEnabledForExtensions()} to true."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.XmlRpcServlet.log",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/apache\/stratos\/blob\/master\/components\/org.apache.stratos.cli\/src\/main\/java\/org\/apache\/stratos\/cli\/StratosApplication.java",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.stratos.cli.StratosApplication.run",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.lang.String[]"
      ],
      "return": "int",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/PebbleTemplates\/pebble\/blob\/master\/src\/main\/java\/com\/mitchellbosecke\/pebble\/utils\/PathUtils.java",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "",
        "class": "Utility class to handle relative paths."
      },
      "framework": "pebble",
      "discovery": "manual",
      "name": "com.mitchellbosecke.pebble.utils.PathUtils.sanitize",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String",
        "char"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getRequestedSessionId() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getRequestedSessionId",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/SPNegoScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces SPNEGO authorization Header based on token created by processChallenge.",
        "class": "SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication scheme."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.auth.SPNegoScheme.authenticate",
      "jar": null,
      "comment": "The authentication string is calculated from the credentials and returned as a header.",
      "parameters": [
        "org.apache.http.auth.Credentials",
        "org.apache.http.HttpRequest",
        "org.apache.http.protocol.HttpContext"
      ],
      "return": "org.apache.http.Header",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/4.3.9.RELEASE\/javadoc-api\/org\/springframework\/mock\/web\/MockHttpServletRequest.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Use the container login mechanism configured for the ServletContext to authenticate the user making this request. This method may modify and commit the argument HttpServletResponse.",
        "class": "Mock implementation of the {@link javax.servlet.http.HttpServletRequest} interface. The default, preferred {@link Locale} for the server mocked by this request is {@link Locale#ENGLISH}. This value can be changed via {@link #addPreferredLocale} or {@link #setPreferredLocales}. As of Spring Framework 4.0, this set of mocks is designed on a Servlet 3.0 baseline."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.mock.web.MockHttpServletRequest.authenticate",
      "jar": null,
      "comment": "The authentication is added to the response.",
      "parameters": [
        "javax.servlet.http.HttpServletResponse"
      ],
      "return": "boolean",
      "dataIn": {
        "parameters": [
          0,
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns a {@code String} value for an unescaped CSV column. If the value is enclosed in double quotes, and contains a comma, newline or double quote, then quotes are removed. Any double quote escaped characters (a pair of double quotes) are unescaped to just one double quote. If the value is not enclosed in double quotes, or is and does not contain a comma, newline or double quote, then the String value is returned unchanged. see Wikipedia and RFC 4180.",
        "class": "Escapes and unescapes {@code String}s for Java, Java Script, HTML and XML. #ThreadSafe#"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.apache.commons.lang3.StringEscapeUtils.unescapeCsv",
      "jar": "commons-lang3-3.10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/NTLMScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces NTLM authorization string for the given set of {@link Credentials}.",
        "class": "An implementation of the Microsoft proprietary NTLM authentication scheme. For a detailed explanation of the NTLM scheme please see http:\/\/davenport.sourceforge.net\/ntlm.html."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.NTLMScheme.authenticate",
      "jar": null,
      "comment": "Depricated method. The credentials are provided. The authentication string is returned.",
      "parameters": [
        "org.apache.commons.httpclient.Credentials",
        "org.apache.commons.httpclient.HttpMethod"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encoder for XML and XHTML text content. See {@link #forHtmlContent(String)} for description of encoding and context.",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forXmlContent",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for use in an XML element. The implementation should follow the XML Encoding Standard from the W3C. The use of a real XML parser is strongly encouraged. However, in the hopefully rare case that you need to make sure that data is safe for inclusion in an XML document and cannot use a parse, this method provides a safe mechanism to do so.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForXML",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/RequestData.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the request method.",
        "class": "Web servers extension of {@link org.apache.xmlrpc.common.XmlRpcHttpRequestConfig}, which allows to store additional per request data."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.RequestData.getMethod",
      "jar": null,
      "comment": "Counter example for sanitizer.",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Turn special characters into HTML character references. Handles complete character set defined in HTML 4.01 recommendation. Escapes all special characters to their corresponding numeric reference in decimal format (&#Decimal;). Reference: http:\/\/www.w3.org\/TR\/html4\/sgml\/entities.html",
        "class": "Utility class for HTML escaping. Escapes and unescapes based on the W3C HTML 4.01 recommendation, handling character entity references. Reference: http:\/\/www.w3.org\/TR\/html4\/charset.html For a comprehensive set of String escaping utilities, consider Apache Commons Lang and its StringEscapeUtils class. We are not using that class here to avoid a runtime dependency on Commons Lang just for HTML escaping. Furthermore, Spring's HTML escaping is more flexible and 100% HTML 4.0 compliant."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.springframework.web.util.HtmlUtils.htmlEscapeDecimal",
      "jar": "spring-web-4.3.9.RELEASE.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to call sendError(int sc) on the wrapped response object.",
        "class": "Provides a convenient implementation of the HttpServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletResponseWrapper.sendError",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for insertion inside a data value in a Visual Basic script. Putting user data directly inside a script is quite dangerous. Great care must be taken to prevent putting user data directly into script code itself, as no amount of encoding will prevent attacks there. This method is not recommended as VBScript is only supported by Internet Explorer",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForVBScript",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/cyejing\/spring-framework-yj\/blob\/master\/spring-context\/src\/main\/java\/org\/springframework\/format\/datetime\/joda\/PeriodFormatter.java",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Parse a text String to produce a T.",
        "class": "{@link Formatter} implementation for a Joda-Time {@link Period}, following Joda-Time's parsing rules for a Period."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.format.datetime.joda.PeriodFormatter.parse",
      "jar": null,
      "comment": "Counter example for sources.",
      "parameters": [
        "java.lang.String",
        "java.util.Locale"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the name of the cookie. The name cannot be changed after creation.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.getName",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Find by primary key and lock. Search for an entity of the specified class and primary key and lock it with respect to the specified lock type. If the entity instance is contained in the persistence context, it is returned from there, and the effect of this method is the same as if the lock method had been called on the entity. If the entity is found within the persistence context and the lock mode type is pessimistic and the entity has a version attribute, the persistence provider must perform optimistic version checks when obtaining the database lock. If these checks fail, the OptimisticLockException will be thrown. If the lock mode type is pessimistic and the entity instance is found but cannot be locked: the PessimisticLockException will be thrown if the database locking failure causes transaction-level rollback the LockTimeoutException will be thrown if the database locking failure causes only statement-level rollback",
        "class": "Concrete implementation of a Session. Exposes two interfaces: {@link org.hibernate.Session} to the application {@link org.hibernate.engine.spi.SessionImplementor} to other Hibernate components (SPI) This class is not thread-safe."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.hibernate.internal.SessionImpl.find",
      "jar": "hibernate-core-5.2.10.Final.jar",
      "comment": "",
      "parameters": [
        "java.lang.Class",
        "java.lang.Object",
        "javax.persistence.LockModeType"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/google\/google-auth-library-java\/blob\/master\/oauth2_http\/java\/com\/google\/auth\/oauth2\/DefaultCredentialsProvider.java",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE862"
      ],
      "javadoc": {
        "method": "Returns the Application Default Credentials. Returns the Application Default Credentials which are credentials that identify and authorize the whole application. This is the built-in service account if running on Google Compute Engine or credentials specified by an environment variable or a file in a well-known location.",
        "class": "Provides the Application Default Credential from the environment. An instance represents the per-process state used to get and cache the credential and allows overriding the state and environment for testing purposes."
      },
      "framework": "oauth",
      "discovery": "manual",
      "name": "com.google.auth.oauth2.DefaultCredentialsProvider.getDefaultCredentials",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "com.google.api.client.http.HttpTransport"
      ],
      "return": "com.google.auth.oauth2.GoogleCredentials",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "http:\/\/help.collab.net\/topic\/iaf-700\/pebble-soap-javadocs\/net\/sourceforge\/pebble\/util\/SecurityUtils.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": "A collection of utility methods for security."
      },
      "framework": "pebble",
      "discovery": "manual",
      "name": "net.sourceforge.pebble.util.SecurityUtils.runAsUnauthenticated",
      "jar": null,
      "comment": "Puts the state of the program to unauthenticated.",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encodes for (X)HTML text content and text attributes. Since this method encodes for both contexts, it may be slightly less efficient to use this method over the methods targeted towards the specific contexts ({@link #forHtmlAttribute(String)} and {@link #forHtmlContent(String)}. In general this method should be preferred unless you are really concerned with saving a few bytes or are writing a framework that utilizes this package. Example JSP Usage      \n\n     \" \/>\n Encoding Table Input Result {@code &} {@code &} {@code } {@code >} {@code \"} {@code \"} {@code '} {@code '} Additional Notes The encoding of the greater-than sign ({@code >}) is not strictly required, but is included for maximum compatibility. Numeric encoding is used for double-quote character ({@code \"}) as it shorter than the also valid {@code \"}. Carriage return (U+0D), line-feed (U+0A), horizontal tab (U+09) and space (U+20) are valid in quoted attributes and in block in an unescaped form. Surrogate pairs are passed through only if valid. Characters that are not valid according to the XML specification are replaced by a space character as they could lead to parsing errors. In particular only {@code #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]} are considered valid.",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forHtml",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Log a FINER message. If the logger is currently enabled for the FINER message level then the given message is forwarded to all the registered output Handler objects.",
        "class": "A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the {@code getLogger} factory methods may be garbage collected at any time if a strong reference to the Logger is not kept. Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree. The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent. On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree. Each Logger may have a {@code ResourceBundle} associated with it. The {@code ResourceBundle} may be specified by name, using the {@link #getLogger(java.lang.String, java.lang.String)} factory method, or by value - using the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method. This bundle will be used for localizing logging messages. If a Logger does not have its own {@code ResourceBundle} or resource bundle name, then it will inherit the {@code ResourceBundle} or resource bundle name from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument. These methods take a {@link Supplier}{@code } function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       \/\/ collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled. \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n When looking for a {@code ResourceBundle}, the logger will first look at whether a bundle was specified using {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then only whether a resource bundle name was specified through the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. If no {@code ResourceBundle} or no resource bundle name is found, then it will use the nearest {@code ResourceBundle} or resource bundle name inherited from its parent tree. When a {@code ResourceBundle} was inherited or specified through the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then that {@code ResourceBundle} will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a {@code ResourceBundle} object, using the default Locale at the time of logging. When mapping resource bundle names to {@code ResourceBundle} objects, the logger will first try to use the Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class loader} to map the given resource bundle name to a {@code ResourceBundle}. If the thread context class loader is {@code null}, it will try the {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader} instead. If the {@code ResourceBundle} is still not found, it will use the class loader of the first caller of the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string. There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name. There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message. There are convenience methods for tracing method entries (the \"entering\" methods), method returns (the \"exiting\" methods) and throwing exceptions (the \"throwing\" methods). Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string. For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.logging.Logger.finer",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "http:\/\/grepcode.com\/file\/repo1.maven.org\/maven2\/xerces\/xerces\/2.4.0\/org\/apache\/xerces\/impl\/xs\/models\/XSDFACM.java?av=h",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Dumps the tree of the current node to standard output.",
        "class": "DFAContentModel is the implementation of XSCMValidator that does all of the non-trivial element content validation. This class does the conversion from the regular expression to the DFA that it then uses in its validation algorithm."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xerces.impl.xs.models.XSDFACM.dumpTree",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.apache.xerces.impl.dtd.models.CMNode",
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/NegotiateScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces Negotiate authorization Header based on token created by processChallenge.",
        "class": "SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication scheme."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.auth.NegotiateScheme.authenticate",
      "jar": null,
      "comment": "Produces an authentication string for the given credentials.",
      "parameters": [
        "org.apache.http.auth.Credentials",
        "org.apache.http.HttpRequest",
        "org.apache.http.protocol.HttpContext"
      ],
      "return": "org.apache.http.Header",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Performs percent-encoding for a component of a URI, such as a query parameter name or value, path or query-string. In particular this method insures that special characters in the component do not get interpreted as part of another component.      ?query#fragment\">\n\n     &order=1#top\">\n Encoding Table The following characters are not encoded:  U+20:                           - .   0 1 2 3 4 5 6 7 8 9\n U+40: @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z         _\n U+60:   a b c d e f g h i j k l m n o p q r s t u v w x y z       ~\n Encoding Notes Unlike {@link #forUri(String)} this method is safe to be used in most containing contexts, including: HTML\/XML, CSS, and JavaScript contexts. URL encoding is an encoding for bytes, not unicode. The input string is thus first encoded as a sequence of UTF-8 byte. The bytes are then encoded as {@code %xx} where {@code xx} is the two-digit hexidecimal representation of the byte. (The implementation does this as one step for performance.) Surrogate pairs are first decoded to a Unicode code point before encoding as UTF-8. Invalid characters (e.g. partial or invalid surrogate pairs), are replaced with a hyphen ({@code -}) character.",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forUriComponent",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/shiro.apache.org\/static\/1.2.6\/apidocs\/org\/apache\/shiro\/mgt\/DefaultSecurityManager.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "First authenticates the {@code AuthenticationToken} argument, and if successful, constructs a {@code Subject} instance representing the authenticated account's identity. Once constructed, the {@code Subject} instance is then {@link #bind bound} to the application for subsequent access before being returned to the caller.",
        "class": "The Shiro framework's default concrete implementation of the {@link SecurityManager} interface, based around a collection of {@link org.apache.shiro.realm.Realm}s. This implementation delegates its authentication, authorization, and session operations to wrapped {@link Authenticator}, {@link Authorizer}, and {@link org.apache.shiro.session.mgt.SessionManager SessionManager} instances respectively via superclass implementation. To greatly reduce and simplify configuration, this implementation (and its superclasses) will create suitable defaults for all of its required dependencies, except the required one or more {@link Realm Realm}s. Because {@code Realm} implementations usually interact with an application's data model, they are almost always application specific; you will want to specify at least one custom {@code Realm} implementation that 'knows' about your application's data\/security model (via {@link #setRealm} or one of the overloaded constructors). All other attributes in this class hierarchy will have suitable defaults for most enterprise applications. RememberMe notice: This class supports the ability to configure a {@link #setRememberMeManager RememberMeManager} for {@code RememberMe} identity services for login\/logout, BUT, a default instance will not be created for this attribute at startup. Because RememberMe services are inherently client tier-specific and therefore aplication-dependent, if you want {@code RememberMe} services enabled, you will have to specify an instance yourself via the {@link #setRememberMeManager(RememberMeManager) setRememberMeManager} mutator. However if you're reading this JavaDoc with the expectation of operating in a Web environment, take a look at the {@code org.apache.shiro.web.DefaultWebSecurityManager} implementation, which does support {@code RememberMe} services by default at startup."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.shiro.mgt.DefaultSecurityManager.login",
      "jar": null,
      "comment": "Login the specified subject with the tocken and return the subject.",
      "parameters": [
        "org.apache.shiro.subject.Subject",
        "org.apache.shiro.authc.AuthenticationToken"
      ],
      "return": "org.apache.shiro.subject.Subject",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/jdbc\/core\/JdbcTemplate.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Execute a query given static SQL, reading the ResultSet with a ResultSetExtractor. Uses a JDBC Statement, not a PreparedStatement. If you want to execute a static query with a PreparedStatement, use the overloaded {@code query} method with {@code null} as argument array.",
        "class": "This is the central class in the JDBC core package. It simplifies the use of JDBC and helps to avoid common errors. It executes core JDBC workflow, leaving application code to provide SQL and extract results. This class executes SQL queries or updates, initiating iteration over ResultSets and catching JDBC exceptions and translating them to the generic, more informative exception hierarchy defined in the org.springframework.dao package. Code using this class need only implement callback interfaces, giving them a clearly defined contract. The {@link PreparedStatementCreator} callback interface creates a prepared statement given a Connection, providing SQL and any necessary parameters. The {@link ResultSetExtractor} interface extracts values from a ResultSet. See also {@link PreparedStatementSetter} and {@link RowMapper} for two popular alternative callback interfaces. Can be used within a service implementation via direct instantiation with a DataSource reference, or get prepared in an application context and given to services as bean reference. Note: The DataSource should always be configured as a bean in the application context, in the first case given to the service directly, in the second case to the prepared template. Because this class is parameterizable by the callback interfaces and the {@link org.springframework.jdbc.support.SQLExceptionTranslator} interface, there should be no need to subclass it. All SQL operations performed by this class are logged at debug level, using \"org.springframework.jdbc.core.JdbcTemplate\" as log category."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.jdbc.core.JdbcTemplate.query",
      "jar": null,
      "comment": "sql query",
      "parameters": [
        "java.lang.String",
        "org.springframework.jdbc.core.ResultSetExtractor"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/annotation\/web\/configurers\/UrlAuthorizationConfigurer.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Creates a String for specifying a user requires a role.",
        "class": "Adds URL based authorization using {@link DefaultFilterInvocationSecurityMetadataSource}. At least one {@link org.springframework.web.bind.annotation.RequestMapping} needs to be mapped to {@link ConfigAttribute}'s for this {@link SecurityContextConfigurer} to have meaning. Security Filters Usage includes applying the {@link UrlAuthorizationConfigurer} and then modifying the StandardInterceptUrlRegistry. For example:  protected void configure(HttpSecurity http) throws Exception {\n \thttp.apply(new UrlAuthorizationConfigurer()).getRegistry()\n \t\t\t.antMatchers(\"\/users**\", \"\/sessions\/**\").hasRole(\"USER\")\n \t\t\t.antMatchers(\"\/signup\").hasRole(\"ANONYMOUS\").anyRequest().hasRole(\"USER\");\n }\n The following Filters are populated {@link org.springframework.security.web.access.intercept.FilterSecurityInterceptor} Shared Objects Created The following shared objects are populated to allow other {@link org.springframework.security.config.annotation.SecurityConfigurer}'s to customize: {@link org.springframework.security.web.access.intercept.FilterSecurityInterceptor} Shared Objects Used The following shared objects are used: AuthenticationManager"
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.web.configurers.UrlAuthorizationConfigurer.hasRole",
      "jar": null,
      "comment": "Counter example for sanitizer (has)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/docs.spring.io\/autorepo\/docs\/spring-security\/3.1.8.CI-SNAPSHOT\/apidocs\/org\/springframework\/security\/authentication\/AnonymousAuthenticationProvider.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Performs authentication with the same contract as {@link org.springframework.security.authentication.AuthenticationManager#authenticate(Authentication)} .",
        "class": "An {@link AuthenticationProvider} implementation that validates {@link AnonymousAuthenticationToken}s. To be successfully validated, the {@link AnonymousAuthenticationToken#getKeyHash()} must match this class' {@link #getKey()}."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.authentication.AnonymousAuthenticationProvider.authenticate",
      "jar": null,
      "comment": "The input object is authenticated and returned.",
      "parameters": [
        "org.springframework.security.core.Authentication"
      ],
      "return": "org.springframework.security.core.Authentication",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the selected text from the text that is presented by this text component.",
        "class": "The TextComponent class is the superclass of any component that allows the editing of some text. A text component embodies a string of text. The TextComponent class defines a set of methods that determine whether or not this text is editable. If the component is editable, it defines another set of methods that supports a text insertion caret. In addition, the class defines methods that are used to maintain a current selection from the text. The text selection, a substring of the component's text, is the target of editing operations. It is also referred to as the selected text."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.awt.TextComponent.getSelectedText",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the comment describing the purpose of this cookie, or null if the cookie has no comment.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.getComment",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Prints an integer. The string produced by {@link java.lang.String#valueOf(int)} is translated into bytes according to the platform's default character encoding, and these bytes are written in exactly the manner of the {@link #write(int)} method.",
        "class": "Prints formatted representations of objects to a text-output stream. This class implements all of the print methods found in {@link PrintStream}. It does not contain methods for writing raw bytes, for which a program should use unencoded byte streams. Unlike the {@link PrintStream} class, if automatic flushing is enabled it will be done only when one of the println, printf, or format methods is invoked, rather than whenever a newline character happens to be output. These methods use the platform's own notion of line separator rather than the newline character. Methods in this class never throw I\/O exceptions, although some of its constructors may. The client may inquire as to whether any errors have occurred by invoking {@link #checkError checkError()}."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.PrintWriter.print",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.ClientProperties.getNavigatorAppCodeName",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "The {@link WebServer} is a minimal HTTP server, that might be used as an embedded web server. Use of the {@link WebServer} has grown very popular amongst users of Apache XML-RPC. Why this is the case, can hardly be explained, because the {@link WebServer} is at best a workaround, compared to full blown servlet engines like Tomcat or Jetty. For example, under heavy load it will almost definitely be slower than a real servlet engine, because it does neither support proper keepalive (multiple requests per physical connection) nor chunked mode (in other words, it cannot stream requests). If you still insist in using the {@link WebServer}, it is recommended to use its subclass, the {@link ServletWebServer} instead, which offers a minimal subset of the servlet API. In other words, you keep yourself the option to migrate to a real servlet engine later. Use of the {@link WebServer} goes roughly like this: First of all, create a property file (for example \"MyHandlers.properties\") and add it to your jar file. The property keys are handler names and the property values are the handler classes. Once that is done, create an instance of WebServer:    final int port = 8088;\n   final String propertyFile = \"MyHandler.properties\";\n\n   PropertyHandlerMapping mapping = new PropertyHandlerMapping();\n   ClassLoader cl = Thread.currentThread().getContextClassLoader();\n   mapping.load(cl, propertyFile);\n   WebServer webServer = new WebServer(port);\n   XmlRpcServerConfigImpl config = new XmlRpcServerConfigImpl();\n   XmlRpcServer server = webServer.getXmlRpcServer();\n   server.setConfig(config);\n   server.setHandlerMapping(mapping);\n   webServer.start();"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.WebServer.newThreadPool",
      "jar": null,
      "comment": "Counter example for source",
      "parameters": [],
      "return": "org.apache.xmlrpc.util.ThreadPool",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Construct an InternetAddress given the address and personal name. The address is assumed to be a syntactically valid RFC822 address.",
        "class": "This class represents an Internet email address using the syntax of RFC822. Typical address syntax is of the form \"user@host.domain\" or \"Personal Name \"."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.mail.internet.InternetAddress.<init>",
      "jar": "org.apache.stratos.cli-4.0.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to return addHeader(String name, String value) on the wrapped response object.",
        "class": "Provides a convenient implementation of the HttpServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletResponseWrapper.addHeader",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/jsoup.org\/apidocs\/org\/jsoup\/nodes\/Entities.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Un-escape an HTML escaped string.",
        "class": "HTML entities, and escape routines. Source: W3C HTML named character references."
      },
      "framework": "jsoup",
      "discovery": "manual",
      "name": "org.jsoup.nodes.Entities.unescape",
      "jar": null,
      "comment": "Counter example for sanitizer (unescape)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/mock\/web\/MockBodyContent.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Print a String and then terminate the line. This method behaves as though it invokes {@link #print(String)} and then {@link #println()}.",
        "class": "Mock implementation of the {@link javax.servlet.jsp.tagext.BodyContent} class. Used for testing the web framework; only necessary for testing applications when testing custom JSP tags."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.mock.web.MockBodyContent.println",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/server\/XmlRpcServerWorker.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078",
        "CWE079"
      ],
      "javadoc": {
        "method": "Performs a synchronous request. The client worker extends this interface with the ability to perform asynchronous requests.",
        "class": "Server specific implementation of {@link XmlRpcWorker}."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.server.XmlRpcServerWorker.execute",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.apache.xmlrpc.XmlRpcRequest"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/BasicScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces basic authorization string for the given set of {@link Credentials}.",
        "class": "Basic authentication scheme as defined in RFC 2617."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.BasicScheme.authenticate",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "org.apache.commons.httpclient.Credentials",
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/WebServer.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Listens for client requests until stopped. Call {@link #start()} to invoke this method, and {@link #shutdown()} to break out of it.",
        "class": "The {@link WebServer} is a minimal HTTP server, that might be used as an embedded web server. Use of the {@link WebServer} has grown very popular amongst users of Apache XML-RPC. Why this is the case, can hardly be explained, because the {@link WebServer} is at best a workaround, compared to full blown servlet engines like Tomcat or Jetty. For example, under heavy load it will almost definitely be slower than a real servlet engine, because it does neither support proper keepalive (multiple requests per physical connection) nor chunked mode (in other words, it cannot stream requests). If you still insist in using the {@link WebServer}, it is recommended to use its subclass, the {@link ServletWebServer} instead, which offers a minimal subset of the servlet API. In other words, you keep yourself the option to migrate to a real servlet engine later. Use of the {@link WebServer} goes roughly like this: First of all, create a property file (for example \"MyHandlers.properties\") and add it to your jar file. The property keys are handler names and the property values are the handler classes. Once that is done, create an instance of WebServer:    final int port = 8088;\n   final String propertyFile = \"MyHandler.properties\";\n\n   PropertyHandlerMapping mapping = new PropertyHandlerMapping();\n   ClassLoader cl = Thread.currentThread().getContextClassLoader();\n   mapping.load(cl, propertyFile);\n   WebServer webServer = new WebServer(port);\n   XmlRpcServerConfigImpl config = new XmlRpcServerConfigImpl();\n   XmlRpcServer server = webServer.getXmlRpcServer();\n   server.setConfig(config);\n   server.setHandlerMapping(mapping);\n   webServer.start();"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.WebServer.run",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/spring-projects\/spring-security\/blob\/master\/config\/src\/main\/java\/org\/springframework\/security\/config\/http\/FormLoginBeanDefinitionParser.java",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.http.FormLoginBeanDefinitionParser.getLoginPage",
      "jar": null,
      "comment": "Counter example for authentications and cwe306",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/util\/DefaultPropertiesPersister.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "Default implementation of the {@link PropertiesPersister} interface. Follows the native parsing of java.util.Properties. Allows for reading from any Reader and writing to any Writer, for example to specify a charset for a properties file. This is a capability that standard java.util.Properties unfortunately lacks up until JDK 1.5: You can only load files using the ISO-8859-1 charset there. Loading from and storing to a stream delegates to Properties.load and Properties.store, respectively, to be fully compatible with the Unicode conversion as implemented by the JDK Properties class. On JDK 1.6, Properties.load\/store will also be used for readers\/writers, effectively turning this class into a plain backwards compatibility adapter. The persistence code that works with Reader\/Writer follows the JDK's parsing strategy but does not implement Unicode conversion, because the Reader\/Writer should already apply proper decoding\/encoding of characters. If you use prefer to escape unicode characters in your properties files, do not specify an encoding for a Reader\/Writer (like ReloadableResourceBundleMessageSource's \"defaultEncoding\" and \"fileEncodings\" properties). As of Spring 1.2.2, this implementation also supports properties XML files, through the loadFromXml and storeToXml methods. The default implementations delegate to JDK 1.5's corresponding methods, throwing an exception if running on an older JDK. Those implementations could be subclassed to apply custom XML handling on JDK 1.4, for example."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.util.DefaultPropertiesPersister.unescape",
      "jar": null,
      "comment": "Counter example for sanitizer (unescape)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "loadFiles.",
        "class": "Plugin class."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.plugins.Plugin.loadFiles",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.nio.file.Path"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the text that is presented by this text component. By default, this is an empty string.",
        "class": "The TextComponent class is the superclass of any component that allows the editing of some text. A text component embodies a string of text. The TextComponent class defines a set of methods that determine whether or not this text is editable. If the component is editable, it defines another set of methods that supports a text insertion caret. In addition, the class defines methods that are used to maintain a current selection from the text. The text selection, a substring of the component's text, is the target of editing operations. It is also referred to as the selected text."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.awt.TextComponent.getText",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns a String containing the value of the named initialization parameter, or null if the parameter does not exist. See {@link ServletConfig#getInitParameter}. This method is supplied for convenience. It gets the value of the named parameter from the servlet's ServletConfig object.",
        "class": "Defines a generic, protocol-independent servlet. To write an HTTP servlet for use on the Web, extend {@link javax.servlet.http.HttpServlet} instead. GenericServlet implements the Servlet and ServletConfig interfaces. GenericServlet may be directly extended by a servlet, although it's more common to extend a protocol-specific subclass such as HttpServlet. GenericServlet makes writing servlets easier. It provides simple versions of the lifecycle methods init and destroy and of the methods in the ServletConfig interface. GenericServlet also implements the log method, declared in the ServletContext interface. To write a generic servlet, you need only override the abstract service method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.GenericServlet.getInitParameter",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/static.javadoc.io\/org.owasp.esapi\/esapi\/2.0.1\/org\/owasp\/esapi\/Encoder.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Encode for Base64.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "owaspesapi",
      "discovery": "manual",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForBase64",
      "jar": null,
      "comment": "",
      "parameters": [
        "byte[]",
        "boolean"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to return setHeader(String name, String value) on the wrapped response object.",
        "class": "Provides a convenient implementation of the HttpServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletResponseWrapper.setHeader",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/jca\/work\/DelegatingWork.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Delegates execution to the underlying Runnable.",
        "class": "Simple Work adapter that delegates to a given Runnable."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.jca.work.DelegatingWork.run",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encodes for CSS strings. The context must be surrounded by quotation characters. It is safe for use in both style blocks and attributes in HTML. Example JSP Usage      ');\">\n\n     \n         background: url('');\n     \n Encoding Notes The following characters are encoded using hexidecimal encodings: {@code U+0000} - {@code U+001f}, {@code \"}, {@code '}, {@code \\}, {@code }, {@code U+007f}, line separator ({@code U+2028}), paragraph separator ({@code U+2029}). Any character requiring encoding is encoded as {@code \\xxx} where {@code xxx} is the shortest hexidecimal representation of its Unicode code point (after decoding surrogate pairs if necessary). This encoding is never zero padded. Thus, for example, the tab character is encoded as {@code \\9}, not {@code \\0009}. The encoder looks ahead 1 character in the input and appends a space to an encoding to avoid the next character becoming part of the hexidecimal encoded sequence. Thus \u201C{@code '1}\u201D is encoded as \u201C{@code \\27 1}\u201D, and not as \u201C{@code \\271}\u201D. If a space is not necessary, it is not included, thus \u201C{@code 'x}\u201D is encoded as \u201C{@code \\27x}\u201D, and not as \u201C{@code \\27 x}\u201D. Surrogate pairs are passed through only if valid. Invalid surrogate pairs are replaced by an underscore (_). Unicode \"non-characters\" are replaced by underscores (_).",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forCssString",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/annotation\/web\/messaging\/MessageSecurityMetadataSourceRegistry.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "Allows mapping security constraints using {@link MessageMatcher} to the security expressions."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry.hasAuthority",
      "jar": null,
      "comment": "Counter example for sanitizer (has)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Log a FINEST message. If the logger is currently enabled for the FINEST message level then the given message is forwarded to all the registered output Handler objects.",
        "class": "A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the {@code getLogger} factory methods may be garbage collected at any time if a strong reference to the Logger is not kept. Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree. The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent. On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree. Each Logger may have a {@code ResourceBundle} associated with it. The {@code ResourceBundle} may be specified by name, using the {@link #getLogger(java.lang.String, java.lang.String)} factory method, or by value - using the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method. This bundle will be used for localizing logging messages. If a Logger does not have its own {@code ResourceBundle} or resource bundle name, then it will inherit the {@code ResourceBundle} or resource bundle name from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument. These methods take a {@link Supplier}{@code } function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       \/\/ collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled. \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n When looking for a {@code ResourceBundle}, the logger will first look at whether a bundle was specified using {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then only whether a resource bundle name was specified through the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. If no {@code ResourceBundle} or no resource bundle name is found, then it will use the nearest {@code ResourceBundle} or resource bundle name inherited from its parent tree. When a {@code ResourceBundle} was inherited or specified through the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then that {@code ResourceBundle} will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a {@code ResourceBundle} object, using the default Locale at the time of logging. When mapping resource bundle names to {@code ResourceBundle} objects, the logger will first try to use the Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class loader} to map the given resource bundle name to a {@code ResourceBundle}. If the thread context class loader is {@code null}, it will try the {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader} instead. If the {@code ResourceBundle} is still not found, it will use the class loader of the first caller of the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string. There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name. There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message. There are convenience methods for tracing method entries (the \"entering\" methods), method returns (the \"exiting\" methods) and throwing exceptions (the \"throwing\" methods). Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string. For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.logging.Logger.finest",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns a {@code Field} object that reflects the specified public member field of the class or interface represented by this {@code Class} object. The {@code name} parameter is a {@code String} specifying the simple name of the desired field. The field to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object: If C declares a public field with the name specified, that is the field to be reflected. If no field was found in step 1 above, this algorithm is applied recursively to each direct superinterface of C. The direct superinterfaces are searched in the order they were declared. If no field was found in steps 1 and 2 above, and C has a superclass S, then this algorithm is invoked recursively upon S. If C has no superclass, then a {@code NoSuchFieldException} is thrown. If this {@code Class} object represents an array type, then this method does not find the {@code length} field of the array type.",
        "class": "Instances of the class {@code Class} represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a {@code Class} object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code int}, {@code long}, {@code float}, and {@code double}), and the keyword {@code void} are also represented as {@code Class} objects. {@code Class} has no public constructor. Instead {@code Class} objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the {@code defineClass} method in the class loader. The following example uses a {@code Class} object to print the class name of an object:      void printClassName(Object obj) {\n         System.out.println(\"The class of \" + obj +\n                            \" is \" + obj.getClass().getName());\n     }\n It is also possible to get the {@code Class} object for a named type (or for void) using a class literal. See Section 15.8.2 of The Javaâ„¢ Language Specification. For example: {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.Class.getField",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.reflect.Field",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/static.javadoc.io\/org.owasp.esapi\/esapi\/2.0.1\/org\/owasp\/esapi\/reference\/validation\/CreditCardValidationRule.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "The method is similar to ValidationRuile.getSafe except that it returns a harmless object that <b>may or may not have any similarity to the original input (in some cases you may not care)</b>. In most cases this should be the same as the getSafe method only instead of throwing an exception, return some default value.",
        "class": "A validator performs syntax and possibly semantic validation of a single piece of data from an untrusted source."
      },
      "framework": "owaspesapi",
      "discovery": "manual",
      "name": "org.owasp.esapi.reference.validation.HTMLValidationRule.sanitize",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/4.0.0.RELEASE\/apidocs\/org\/springframework\/security\/config\/annotation\/authentication\/builders\/AuthenticationManagerBuilder.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.ldapAuthentication",
      "jar": null,
      "comment": "Authentication to LDAP. The owner of the return object can manipulate users to a LDAP connection.",
      "parameters": [],
      "return": "org.springframework.security.config.'annotation'.authentication.configurers.ldap.LdapAuthenticationProviderConfigurer",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/DigestScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces a digest authorization string for the given set of {@link Credentials}, method name and URI.",
        "class": "Digest authentication scheme as defined in RFC 2617. Both MD5 (default) and MD5-sess are supported. Currently only qop=auth or no qop is supported. qop=auth-int is unsupported. If auth and auth-int are provided, auth is used. Credential charset is configured via the {@link org.apache.commons.httpclient.params.HttpMethodParams#CREDENTIAL_CHARSET credential charset} parameter. Since the digest username is included as clear text in the generated Authentication header, the charset of the username must be compatible with the {@link org.apache.commons.httpclient.params.HttpMethodParams#HTTP_ELEMENT_CHARSET http element charset}. TODO: make class more stateful regarding repeated authentication requests"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.DigestScheme.authenticate",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "org.apache.commons.httpclient.Credentials",
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/google.github.io\/google-auth-library-java\/releases\/0.7.1\/apidocs\/com\/google\/auth\/oauth2\/UserAuthorizer.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns a UserCredentials instance by exchanging an OAuth2 authorization code for tokens.",
        "class": "Handles an interactive 3-Legged-OAuth2 (3LO) user consent authorization."
      },
      "framework": "oauth",
      "discovery": "manual",
      "name": "com.google.auth.oauth2.UserAuthorizer.getCredentialsFromCode",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.lang.String",
        "java.net.URI"
      ],
      "return": "com.google.auth.oauth2.UserCredentials",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the names of the servlet's initialization parameters as an Enumeration of String objects, or an empty Enumeration if the servlet has no initialization parameters. See {@link ServletConfig#getInitParameterNames}. This method is supplied for convenience. It gets the parameter names from the servlet's ServletConfig object.",
        "class": "Defines a generic, protocol-independent servlet. To write an HTTP servlet for use on the Web, extend {@link javax.servlet.http.HttpServlet} instead. GenericServlet implements the Servlet and ServletConfig interfaces. GenericServlet may be directly extended by a servlet, although it's more common to extend a protocol-specific subclass such as HttpServlet. GenericServlet makes writing servlets easier. It provides simple versions of the lifecycle methods init and destroy and of the methods in the ServletConfig interface. GenericServlet also implements the log method, declared in the ServletContext interface. To write a generic servlet, you need only override the abstract service method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.GenericServlet.getInitParameterNames",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.util.Enumeration",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/orm\/hibernate3\/support\/ClobStringType.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "",
        "class": "Hibernate UserType implementation for Strings that get mapped to CLOBs. Retrieves the LobHandler to use from LocalSessionFactoryBean at config time. Particularly useful for storing Strings with more than 4000 characters in an Oracle database (only possible via CLOBs), in combination with OracleLobHandler. Can also be defined in generic Hibernate mappings, as DefaultLobCreator will work with most JDBC-compliant database drivers. In this case, the field type does not have to be CLOB: For databases like MySQL and MS SQL Server, any large enough character type will work."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.orm.hibernate3.support.ClobStringType.sqlTypes",
      "jar": null,
      "comment": "depricated method. ",
      "parameters": [],
      "return": "int[]",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.ClientProperties.getRemoteAddress",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/BasicScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces basic authorization header for the given set of {@link Credentials}.",
        "class": "Basic authentication scheme as defined in RFC 2617. The following parameters can be used to customize the behavior of this class: {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET}"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.auth.BasicScheme.authenticate",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "org.apache.http.auth.Credentials",
        "org.apache.http.HttpRequest"
      ],
      "return": "org.apache.http.Header",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/OWASP\/WebGoat\/blob\/master\/webgoat\/src\/main\/java\/org\/owasp\/webgoat\/util\/HtmlEncoder.java",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Given a string containing entity escapes, returns a string containing the actual Unicode characters corresponding to the escapes. Adapted from http:\/\/www.purpletech.com\/code\/src\/com\/purpletech\/util\/Utils.java.",
        "class": "This file is part of WebGoat, an Open Web Application Security Project utility. For details, please see http:\/\/www.owasp.org\/ Copyright (c) 2002 - 20014 Bruce Mayhew This program is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. Getting Source ============== Source for this application is maintained at https:\/\/github.com\/WebGoat\/WebGoat, a repository for free software projects."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.util.HtmlEncoder.decode",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/test\/context\/MergedContextConfiguration.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Generate a null-safe {@link String} representation of the supplied {@link ContextLoader} based solely on the fully qualified name of the loader or \"null\" if the supplied loaded is {@code null}.",
        "class": "{@code MergedContextConfiguration} encapsulates the merged context configuration declared on a test class and all of its superclasses via {@link ContextConfiguration @ContextConfiguration}, {@link ActiveProfiles @ActiveProfiles}, and {@link TestPropertySource @TestPropertySource}. Merged context resource locations, annotated classes, active profiles, property resource locations, and in-lined properties represent all declared values in the test class hierarchy taking into consideration the semantics of the {@link ContextConfiguration#inheritLocations}, {@link ActiveProfiles#inheritProfiles}, {@link TestPropertySource#inheritLocations}, and {@link TestPropertySource#inheritProperties} flags. A {@link SmartContextLoader} uses {@code MergedContextConfiguration} to load an {@link org.springframework.context.ApplicationContext ApplicationContext}. {@code MergedContextConfiguration} is also used by the {@link org.springframework.test.context.cache.ContextCache ContextCache} as the key for caching an {@link org.springframework.context.ApplicationContext ApplicationContext} that was loaded using properties of this {@code MergedContextConfiguration}."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.test.context.MergedContextConfiguration.nullSafeToString",
      "jar": null,
      "comment": "Counter example for sanitizer",
      "parameters": [
        "org.springframework.test.context.ContextLoader"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/hibernate\/hibernate-validator\/blob\/master\/engine\/src\/main\/java\/org\/hibernate\/validator\/internal\/util\/ConcurrentReferenceHashMap.java",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Replaces the entry for a key only if currently mapped to a given value. This is equivalent to  {@code\n if (map.containsKey(key) &amp;&amp; Objects.equals(map.get(key), oldValue)) {\n   map.put(key, newValue);\n   return true;\n } else\n   return false;\n } except that the action is performed atomically.",
        "class": "An advanced hash table supporting configurable garbage collection semantics of keys and values, optional referential-equality, full concurrency of retrievals, and adjustable expected concurrency for updates. This table is designed around specific advanced use-cases. If there is any doubt whether this table is for you, you most likely should be using {@link java.util.concurrent.ConcurrentHashMap} instead. This table supports strong, weak, and soft keys and values. By default keys are weak, and values are strong. Such a configuration offers similar behavior to {@link java.util.WeakHashMap}, entries of this table are periodically removed once their corresponding keys are no longer referenced outside of this table. In other words, this table will not prevent a key from being discarded by the garbage collector. Once a key has been discarded by the collector, the corresponding entry is no longer visible to this table; however, the entry may occupy space until a future table operation decides to reclaim it. For this reason, summary functions such as {@code size} and {@code isEmpty} might return a value greater than the observed number of entries. In order to support a high level of concurrency, stale entries are only reclaimed during blocking (usually mutating) operations. Enabling soft keys allows entries in this table to remain until their space is absolutely needed by the garbage collector. This is unlike weak keys which can be reclaimed as soon as they are no longer referenced by a normal strong reference. The primary use case for soft keys is a cache, which ideally occupies memory that is not in use for as long as possible. By default, values are held using a normal strong reference. This provides the commonly desired guarantee that a value will always have at least the same life-span as it's key. For this reason, care should be taken to ensure that a value never refers, either directly or indirectly, to its key, thereby preventing reclamation. If this is unavoidable, then it is recommended to use the same reference type in use for the key. However, it should be noted that non-strong values may disappear before their corresponding key. While this table does allow the use of both strong keys and values, it is recommended to use {@link java.util.concurrent.ConcurrentHashMap} for such a configuration, since it is optimized for that case. Just like {@link java.util.concurrent.ConcurrentHashMap}, this class obeys the same functional specification as {@link java.util.Hashtable}, and includes versions of methods corresponding to each method of {@code Hashtable}. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with {@code Hashtable} in programs that rely on its thread safety but not on its synchronization details. Retrieval operations (including {@code get}) generally do not block, so may overlap with update operations (including {@code put} and {@code remove}). Retrievals reflect the results of the most recently completed update operations holding upon their onset. For aggregate operations such as {@code putAll} and {@code clear}, concurrent retrievals may reflect insertion or removal of only some entries. Similarly, Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator\/enumeration. They do not throw {@link ConcurrentModificationException}. However, iterators are designed to be used by only one thread at a time. The allowed concurrency among update operations is guided by the optional {@code concurrencyLevel} constructor argument (default {@code 16}), which is used as a hint for internal sizing. The table is internally partitioned to try to permit the indicated number of concurrent updates without contention. Because placement in hash tables is essentially random, the actual concurrency will vary. Ideally, you should choose a value to accommodate as many threads as will ever concurrently modify the table. Using a significantly higher value than you need can waste space and time, and a significantly lower value can lead to thread contention. But overestimates and underestimates within an order of magnitude do not usually have much noticeable impact. A value of one is appropriate when it is known that only one thread will modify and all others will only read. Also, resizing this or any other kind of hash table is a relatively slow operation, so, when possible, it is a good idea to provide estimates of expected table sizes in constructors. This class and its views and iterators implement all of the optional methods of the {@link Map} and {@link Iterator} interfaces. Like {@link Hashtable} but unlike {@link HashMap}, this class does not allow {@code null} to be used as a key or value. This class is a member of the Java Collections Framework."
      },
      "framework": "hibernate",
      "discovery": "manual",
      "name": "org.hibernate.validator.internal.util.ConcurrentReferenceHashMap.replace",
      "jar": null,
      "comment": "Counter example for sanitizer",
      "parameters": [
        "java.lang.Object",
        "java.lang.Object",
        "java.lang.Object"
      ],
      "return": "boolean",
      "dataIn": {
        "parameters": [
          0,
          1,
          2,
          0,
          1,
          2
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/WebServer.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Switch client filtering on\/off.",
        "class": "The {@link WebServer} is a minimal HTTP server, that might be used as an embedded web server. Use of the {@link WebServer} has grown very popular amongst users of Apache XML-RPC. Why this is the case, can hardly be explained, because the {@link WebServer} is at best a workaround, compared to full blown servlet engines like Tomcat or Jetty. For example, under heavy load it will almost definitely be slower than a real servlet engine, because it does neither support proper keepalive (multiple requests per physical connection) nor chunked mode (in other words, it cannot stream requests). If you still insist in using the {@link WebServer}, it is recommended to use its subclass, the {@link ServletWebServer} instead, which offers a minimal subset of the servlet API. In other words, you keep yourself the option to migrate to a real servlet engine later. Use of the {@link WebServer} goes roughly like this: First of all, create a property file (for example \"MyHandlers.properties\") and add it to your jar file. The property keys are handler names and the property values are the handler classes. Once that is done, create an instance of WebServer:    final int port = 8088;\n   final String propertyFile = \"MyHandler.properties\";\n\n   PropertyHandlerMapping mapping = new PropertyHandlerMapping();\n   ClassLoader cl = Thread.currentThread().getContextClassLoader();\n   mapping.load(cl, propertyFile);\n   WebServer webServer = new WebServer(port);\n   XmlRpcServerConfigImpl config = new XmlRpcServerConfigImpl();\n   XmlRpcServer server = webServer.getXmlRpcServer();\n   server.setConfig(config);\n   server.setHandlerMapping(mapping);\n   webServer.start();"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.WebServer.setParanoid",
      "jar": null,
      "comment": "Counter example for sanitizer (set)",
      "parameters": [
        "boolean"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Given an attribute value string formated according to the rules specified in RFC 2253, returns the unformated value. Escapes and quotes are stripped away, and hex-encoded UTF-8 is converted to equivalent UTF-16 characters. Returns a string value as a String, and a binary value as a byte array. Legal and illegal values are defined in RFC 2253. This method is generous in accepting the values and does not catch all illegal values. Therefore, passing in an illegal value might not necessarily trigger an IllegalArgumentException.",
        "class": "This class represents a relative distinguished name, or RDN, which is a component of a distinguished name as specified by RFC 2253. An example of an RDN is \"OU=Sales+CN=J.Smith\". In this example, the RDN consist of multiple attribute type\/value pairs. The RDN is parsed as described in the class description for {@link javax.naming.ldap.LdapName LdapName}. The Rdn class represents an RDN as attribute type\/value mappings, which can be viewed using {@link javax.naming.directory.Attributes Attributes}. In addition, it contains convenience methods that allow easy retrieval of type and value when the Rdn consist of a single type\/value pair, which is how it appears in a typical usage. It also contains helper methods that allow escaping of the unformatted attribute value and unescaping of the value formatted according to the escaping syntax defined in RFC2253. For methods that take or return attribute value as an Object, the value is either a String (in unescaped form) or a byte array. Rdn will properly parse all valid RDNs, but does not attempt to detect all possible violations when parsing invalid RDNs. It is \"generous\" in accepting invalid RDNs. The \"validity\" of a name is determined ultimately when it is supplied to an LDAP server, which may accept or reject the name based on factors such as its schema information and interoperability considerations. The following code example shows how to construct an Rdn using the constructor that takes type and value as arguments:       Rdn rdn = new Rdn(\"cn\", \"Juicy, Fruit\");\n      System.out.println(rdn.toString());\n The last line will print cn=Juicy\\, Fruit. The {@link #unescapeValue(String) unescapeValue()} method can be used to unescape the escaped comma resulting in the original value \"Juicy, Fruit\". The {@link #escapeValue(Object) escapeValue()} method adds the escape back preceding the comma. This class can be instantiated by a string representation of the RDN defined in RFC 2253 as shown in the following code example:       Rdn rdn = new Rdn(\"cn=Juicy\\\\, Fruit\");\n      System.out.println(rdn.toString());\n The last line will print cn=Juicy\\, Fruit. Concurrent multithreaded read-only access of an instance of Rdn need not be synchronized. Unless otherwise noted, the behavior of passing a null argument to a constructor or method in this class will cause NullPointerException to be thrown."
      },
      "framework": "ldap",
      "discovery": "manual",
      "name": "javax.naming.ldap.Rdn.unescapeValue",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/docs.oracle.com\/javaee\/7\/api\/javax\/mail\/internet\/MimeMultipart.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "javax.mail.internet.MimeMultipart.stripLinearWhiteSpace",
      "jar": null,
      "comment": "",
      "parameters": [
        "byte[]"
      ],
      "return": "byte[]",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/WebServer.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.WebServer.class$",
      "jar": null,
      "comment": "Counter example for sanitizer (String as param, but implicit method)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.Class",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Writes a double value to the client, with no carriage return-line feed (CRLF) at the end.",
        "class": "Provides an output stream for sending binary data to the client. A ServletOutputStream object is normally retrieved via the {@link ServletResponse#getOutputStream} method. This is an abstract class that the servlet container implements. Subclasses of this class must implement the java.io.OutputStream.write(int) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletOutputStream.print",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "double"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/web\/socket\/adapter\/jetty\/JettyWebSocketSession.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Return whether the connection is still open.",
        "class": "A {@link WebSocketSession} for use with the Jetty 9.3\/9.4 WebSocket API."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.adapter.jetty.JettyWebSocketSession.isOpen",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "http:\/\/xmldb-org.sourceforge.net\/xapi\/api\/org\/xmldb\/api\/base\/XMLDBException.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "XMLDBException is thrown for all errors in the XML:DB API. It contains two error codes one an XML:DB error code as defined in ErrorCodes and one vendor specific. If the error being thrown is only vendor specific then errorCode MUST be set to ErrorCodes.VENDOR_ERROR."
      },
      "framework": "generalJava",
      "discovery": "manual",
      "name": "org.xmldb.api.base.XMLDBException.printStackTrace",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.io.PrintWriter"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/HttpAuthenticator.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Attempt to provide requisite proxy authentication credentials to the given method in the given context using the given authentication scheme.",
        "class": "Utility methods for HTTP authorization and authentication. This class provides utility methods for generating responses to HTTP www and proxy authentication challenges. A client SHOULD assume that all paths at or deeper than the depth of the last symbolic element in the path field of the Request-URI also are within the protection space specified by the basic realm value of the current challenge. A client MAY preemptively send the corresponding Authorization header with requests for resources in that space without receipt of another challenge from the server. Similarly, when a client sends a request to a proxy, it may reuse a userid and password in the Proxy-Authorization header field without receiving another challenge from the proxy server."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.HttpAuthenticator.authenticateProxy",
      "jar": null,
      "comment": "Depricated method. The credentials are provided in the HttpState. The authentication is added to the header of the HttpMethod.",
      "parameters": [
        "org.apache.commons.httpclient.auth.AuthScheme",
        "org.apache.commons.httpclient.HttpMethod",
        "org.apache.commons.httpclient.HttpConnection",
        "org.apache.commons.httpclient.HttpState"
      ],
      "return": "boolean",
      "dataIn": {
        "parameters": [
          3,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encoder for XML and XHTML attribute content. See {@link #forHtmlAttribute(String)} for description of encoding and context.",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forXmlAttribute",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/annotation\/SecurityConfigurerAdapter.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.SecurityConfigurerAdapter.and",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [],
      "return": "org.springframework.security.config.'annotation'.SecurityBuilder",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/web\/client\/AsyncRestTemplate.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "Spring's central class for asynchronous client-side HTTP access. Exposes similar methods as {@link RestTemplate}, but returns {@link ListenableFuture} wrappers as opposed to concrete results. The {@code AsyncRestTemplate} exposes a synchronous {@link RestTemplate} via the {@link #getRestOperations()} method and shares its {@linkplain #setErrorHandler error handler} and {@linkplain #setMessageConverters message converters} with that {@code RestTemplate}. Note: by default {@code AsyncRestTemplate} relies on standard JDK facilities to establish HTTP connections. You can switch to use a different HTTP library such as Apache HttpComponents, Netty, and OkHttp by using a constructor accepting an {@link AsyncClientHttpRequestFactory}. For more information, please refer to the {@link RestTemplate} API documentation."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.client.AsyncRestTemplate.logResponseStatus",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [
        "org.springframework.http.HttpMethod",
        "java.net.URI",
        "org.springframework.http.client.ClientHttpResponse"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/SecurityNamespaceHandler.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "Parses elements from the \"security\" namespace (http:\/\/www.springframework.org\/schema\/security)."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.SecurityNamespaceHandler.<init>",
      "jar": null,
      "comment": "Counter example for authentication (init)",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to call addIntHeader(String name, int value) on the wrapped response object.",
        "class": "Provides a convenient implementation of the HttpServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletResponseWrapper.addIntHeader",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.ClientProperties.getHostname",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "http:\/\/grepcode.com\/file\/repo1.maven.org\/maven2\/xerces\/xercesImpl\/2.6.2\/org\/apache\/xerces\/impl\/xpath\/regex\/REUtil.java",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xerces.impl.xpath.regex.REUtil.dumpString",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/ServletConnection.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Performs the task.",
        "class": "{@link org.apache.xmlrpc.webserver.ServletWebServer ServletWebServer's} {@link org.apache.xmlrpc.util.ThreadPool.Task} for handling a single servlet connection."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.ServletConnection.run",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encodes data for an XML CDATA section. On the chance that the input contains a terminating {@code \"]]>\"}, it will be replaced by {@code \"]]>]]>\"}.\n As with all XML contexts, characters that are invalid according to the\n XML specification will be replaced by a space character.   Caller must\n provide the CDATA section boundaries.\n\n \n     &lt;xml-data&gt;&lt;![CDATA[&lt;%=Encode.forCDATA(...)%&gt;]]&gt;&lt;\/xml-data&gt;",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forCDATA",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Gets the contents of this URL. This method is a shorthand for:      openConnection().getContent()",
        "class": "Class {@code URL} represents a Uniform Resource Locator, a pointer to a \"resource\" on the World Wide Web. A resource can be something as simple as a file or a directory, or it can be a reference to a more complicated object, such as a query to a database or to a search engine. More information on the types of URLs and their formats can be found at: Types of URL In general, a URL can be broken into several parts. Consider the following example:      http:\/\/www.example.com\/docs\/resource1.html\n The URL above indicates that the protocol to use is {@code http} (HyperText Transfer Protocol) and that the information resides on a host machine named {@code www.example.com}. The information on that host machine is named {@code \/docs\/resource1.html}. The exact meaning of this name on the host machine is both protocol dependent and host dependent. The information normally resides in a file, but it could be generated on the fly. This component of the URL is called the path component. A URL can optionally specify a \"port\", which is the port number to which the TCP connection is made on the remote host machine. If the port is not specified, the default port for the protocol is used instead. For example, the default port for {@code http} is {@code 80}. An alternative port could be specified as:      http:\/\/www.example.com:1080\/docs\/resource1.html\n The syntax of {@code URL} is defined by RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax, amended by RFC 2732: Format for Literal IPv6 Addresses in URLs. The Literal IPv6 address format also supports scope_ids. The syntax and usage of scope_ids is described here. A URL may have appended to it a \"fragment\", also known as a \"ref\" or a \"reference\". The fragment is indicated by the sharp sign character \"#\" followed by more characters. For example,      http:\/\/java.sun.com\/index.html#chapter1\n This fragment is not technically part of the URL. Rather, it indicates that after the specified resource is retrieved, the application is specifically interested in that part of the document that has the tag {@code chapter1} attached to it. The meaning of a tag is resource specific. An application can also specify a \"relative URL\", which contains only enough information to reach the resource relative to another URL. Relative URLs are frequently used within HTML pages. For example, if the contents of the URL:      http:\/\/java.sun.com\/index.html\n contained within it the relative URL:      FAQ.html\n it would be a shorthand for:      http:\/\/java.sun.com\/FAQ.html\n The relative URL need not specify all the components of a URL. If the protocol, host name, or port number is missing, the value is inherited from the fully specified URL. The file component must be specified. The optional fragment is not inherited. The URL class does not itself encode or decode any URL components according to the escaping mechanism defined in RFC2396. It is the responsibility of the caller to encode any fields, which need to be escaped prior to calling URL, and also to decode any escaped fields, that are returned from URL. Furthermore, because URL has no knowledge of URL escaping, it does not recognise equivalence between the encoded or decoded form of the same URL. For example, the two URLs:     http:\/\/foo.com\/hello world\/ and http:\/\/foo.com\/hello%20world would be considered not equal to each other. Note, the {@link java.net.URI} class does perform escaping of its component fields in certain circumstances. The recommended way to manage the encoding and decoding of URLs is to use {@link java.net.URI}, and to convert between these two classes using {@link #toURI()} and {@link URI#toURL()}. The {@link URLEncoder} and {@link URLDecoder} classes can also be used, but only for HTML form encoding, which is not the same as the encoding scheme defined in RFC2396."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.net.URL.getContent",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/core\/userdetails\/User.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Indicates whether the user's credentials (password) has expired. Expired credentials prevent authentication.",
        "class": "Models core user information retrieved by a {@link UserDetailsService}. Developers may use this class directly, subclass it, or write their own {@link UserDetails} implementation from scratch. {@code equals} and {@code hashcode} implementations are based on the {@code username} property only, as the intention is that lookups of the same user principal object (in a user registry, for example) will match where the objects represent the same user, not just when all the properties (authorities, password for example) are the same. Note that this implementation is not immutable. It implements the {@code CredentialsContainer} interface, in order to allow the password to be erased after authentication. This may cause side-effects if you are storing instances in-memory and reusing them. If so, make sure you return a copy from your {@code UserDetailsService} each time it is invoked."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.core.userdetails.User.isCredentialsNonExpired",
      "jar": null,
      "comment": "Returnes whether the program is authenticated.",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getLocalName() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getLocalName",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/xml.apache.org\/xalan-j\/apidocs\/org\/apache\/xalan\/xsltc\/compiler\/util\/Util.html",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE306",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Replace a certain character in a string with a new substring.",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xalan.xsltc.compiler.util.Util.replace",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String",
        "java.lang.String[]"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0,
          1,
          2
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/annotation\/web\/builders\/HttpSecurity.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.web.builders.HttpSecurity.headers",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [],
      "return": "org.springframework.security.config.'annotation'.web.configurers.HeadersConfigurer",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Log a FINE message. If the logger is currently enabled for the FINE message level then the given message is forwarded to all the registered output Handler objects.",
        "class": "A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the {@code getLogger} factory methods may be garbage collected at any time if a strong reference to the Logger is not kept. Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree. The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent. On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree. Each Logger may have a {@code ResourceBundle} associated with it. The {@code ResourceBundle} may be specified by name, using the {@link #getLogger(java.lang.String, java.lang.String)} factory method, or by value - using the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method. This bundle will be used for localizing logging messages. If a Logger does not have its own {@code ResourceBundle} or resource bundle name, then it will inherit the {@code ResourceBundle} or resource bundle name from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument. These methods take a {@link Supplier}{@code } function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       \/\/ collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled. \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n When looking for a {@code ResourceBundle}, the logger will first look at whether a bundle was specified using {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then only whether a resource bundle name was specified through the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. If no {@code ResourceBundle} or no resource bundle name is found, then it will use the nearest {@code ResourceBundle} or resource bundle name inherited from its parent tree. When a {@code ResourceBundle} was inherited or specified through the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then that {@code ResourceBundle} will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a {@code ResourceBundle} object, using the default Locale at the time of logging. When mapping resource bundle names to {@code ResourceBundle} objects, the logger will first try to use the Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class loader} to map the given resource bundle name to a {@code ResourceBundle}. If the thread context class loader is {@code null}, it will try the {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader} instead. If the {@code ResourceBundle} is still not found, it will use the class loader of the first caller of the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string. There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name. There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message. There are convenience methods for tracing method entries (the \"entering\" methods), method returns (the \"exiting\" methods) and throwing exceptions (the \"throwing\" methods). Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string. For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.logging.Logger.fine",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Performs a final update on the digest using the specified array of bytes, then completes the digest computation. That is, this method first calls {@link #update(byte[]) update(input)}, passing the input array to the {@code update} method, then calls {@link #digest() digest()}.",
        "class": "This MessageDigest class provides applications the functionality of a message digest algorithm, such as SHA-1 or SHA-256. Message digests are secure one-way hash functions that take arbitrary-sized data and output a fixed-length hash value. A MessageDigest object starts out initialized. The data is processed through it using the {@link #update(byte) update} methods. At any point {@link #reset() reset} can be called to reset the digest. Once all the data to be updated has been updated, one of the {@link #digest() digest} methods should be called to complete the hash computation. The {@code digest} method can be called once for a given number of updates. After {@code digest} has been called, the MessageDigest object is reset to its initialized state. Implementations are free to implement the Cloneable interface. Client applications can test cloneability by attempting cloning and catching the CloneNotSupportedException: {@code\n MessageDigest md = MessageDigest.getInstance(\"SHA\");\n\n try {\n     md.update(toChapter1);\n     MessageDigest tc1 = md.clone();\n     byte[] toChapter1Digest = tc1.digest();\n     md.update(toChapter2);\n     ...etc.\n } catch (CloneNotSupportedException cnse) {\n     throw new DigestException(\"couldn't make digest of partial content\");\n }\n } Note that if a given implementation is not cloneable, it is still possible to compute intermediate digests by instantiating several instances, if the number of digests is known in advance. Note that this class is abstract and extends from {@code MessageDigestSpi} for historical reasons. Application developers should only take notice of the methods defined in this {@code MessageDigest} class; all the methods in the superclass are intended for cryptographic service providers who wish to supply their own implementations of message digest algorithms. Every implementation of the Java platform is required to support the following standard {@code MessageDigest} algorithms: {@code MD5} {@code SHA-1} {@code SHA-256} These algorithms are described in the MessageDigest section of the Java Cryptography Architecture Standard Algorithm Name Documentation. Consult the release documentation for your implementation to see if any other algorithms are supported."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.security.MessageDigest.digest",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "byte[]"
      ],
      "return": "byte[]",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/annotation\/web\/configurers\/ExpressionUrlAuthorizationConfigurer.AuthorizedUrl.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer.access$200",
      "jar": null,
      "comment": "Counter example for sanitizer (implicit method)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink",
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Finds a resource with a given name. The rules for searching resources associated with a given class are implemented by the defining {@linkplain ClassLoader class loader} of the class. This method delegates to this object's class loader. If this object was loaded by the bootstrap class loader, the method delegates to {@link ClassLoader#getSystemResourceAsStream}. Before delegation, an absolute resource name is constructed from the given resource name using this algorithm: If the {@code name} begins with a {@code '\/'} ('\\u002f'), then the absolute name of the resource is the portion of the {@code name} following the {@code '\/'}. Otherwise, the absolute name is of the following form: {@code modified_package_name\/name} Where the {@code modified_package_name} is the package name of this object with {@code '\/'} substituted for {@code '.'} ('\\u002e').",
        "class": "Instances of the class {@code Class} represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a {@code Class} object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code int}, {@code long}, {@code float}, and {@code double}), and the keyword {@code void} are also represented as {@code Class} objects. {@code Class} has no public constructor. Instead {@code Class} objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the {@code defineClass} method in the class loader. The following example uses a {@code Class} object to print the class name of an object:      void printClassName(Object obj) {\n         System.out.println(\"The class of \" + obj +\n                            \" is \" + obj.getClass().getName());\n     }\n It is also possible to get the {@code Class} object for a named type (or for void) using a class literal. See Section 15.8.2 of The Javaâ„¢ Language Specification. For example: {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.Class.getResourceAsStream",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.io.InputStream",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/xmldb-org.sourceforge.net\/xapi\/api\/org\/xmldb\/api\/DatabaseManager.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE306",
        "CWE601"
      ],
      "javadoc": {
        "method": "Removes the URI_PREFIX from the front of the URI. This is so the database can focus on handling its own URIs.",
        "class": "DatabaseManager is the entry point for the API and enables you to get the initial Collection references necessary to do anything useful with the API. DatabaseManager is intended to be provided as a concrete implementation in a particular programming language. Individual language mappings should define the exact syntax and semantics of its use."
      },
      "framework": "xmldb",
      "discovery": "manual",
      "name": "org.xmldb.api.DatabaseManager.stripURIPrefix",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns a {@code Method} object that reflects the specified public member method of the class or interface represented by this {@code Class} object. The {@code name} parameter is a {@code String} specifying the simple name of the desired method. The {@code parameterTypes} parameter is an array of {@code Class} objects that identify the method's formal parameter types, in declared order. If {@code parameterTypes} is {@code null}, it is treated as if it were an empty array. If the {@code name} is \"{@code }\" or \"{@code }\" a {@code NoSuchMethodException} is raised. Otherwise, the method to be reflected is determined by the algorithm that follows. Let C be the class or interface represented by this object: C is searched for a matching method, as defined below. If a matching method is found, it is reflected. If no matching method is found by step 1 then: If C is a class other than {@code Object}, then this algorithm is invoked recursively on the superclass of C. If C is the class {@code Object}, or if C is an interface, then the superinterfaces of C (if any) are searched for a matching method. If any such method is found, it is reflected. To find a matching method in a class or interface C: If C declares exactly one public method with the specified name and exactly the same formal parameter types, that is the method reflected. If more than one such method is found in C, and one of these methods has a return type that is more specific than any of the others, that method is reflected; otherwise one of the methods is chosen arbitrarily. Note that there may be more than one matching method in a class because while the Java language forbids a class to declare multiple methods with the same signature but different return types, the Java virtual machine does not. This increased flexibility in the virtual machine can be used to implement various language features. For example, covariant returns can be implemented with {@linkplain java.lang.reflect.Method#isBridge bridge methods}; the bridge method and the method being overridden would have the same signature but different return types. If this {@code Class} object represents an array type, then this method does not find the {@code clone()} method. Static methods declared in superinterfaces of the class or interface represented by this {@code Class} object are not considered members of the class or interface.",
        "class": "Instances of the class {@code Class} represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a {@code Class} object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code int}, {@code long}, {@code float}, and {@code double}), and the keyword {@code void} are also represented as {@code Class} objects. {@code Class} has no public constructor. Instead {@code Class} objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the {@code defineClass} method in the class loader. The following example uses a {@code Class} object to print the class name of an object:      void printClassName(Object obj) {\n         System.out.println(\"The class of \" + obj +\n                            \" is \" + obj.getClass().getName());\n     }\n It is also possible to get the {@code Class} object for a named type (or for void) using a class literal. See Section 15.8.2 of The Javaâ„¢ Language Specification. For example: {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.Class.getMethod",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.Class[]"
      ],
      "return": "java.lang.reflect.Method",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/DigestScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces a digest authorization string for the given set of {@link Credentials}, method name and URI.",
        "class": "Digest authentication scheme as defined in RFC 2617. Both MD5 (default) and MD5-sess are supported. Currently only qop=auth or no qop is supported. qop=auth-int is unsupported. If auth and auth-int are provided, auth is used. Credential charset is configured via the {@link org.apache.commons.httpclient.params.HttpMethodParams#CREDENTIAL_CHARSET credential charset} parameter. Since the digest username is included as clear text in the generated Authentication header, the charset of the username must be compatible with the {@link org.apache.commons.httpclient.params.HttpMethodParams#HTTP_ELEMENT_CHARSET http element charset}. TODO: make class more stateful regarding repeated authentication requests"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.DigestScheme.authenticate",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "org.apache.commons.httpclient.Credentials",
        "org.apache.commons.httpclient.HttpMethod"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encodes for CSS URL contexts. The context must be surrounded by {@code \"url(\"} and {@code \")\"}. It is safe for use in both style blocks and attributes in HTML. Note: this does not do any checking on the quality or safety of the URL itself. The caller should insure that the URL is safe for embedding (e.g. input validation) by other means. Example JSP Usage      );\">\n\n     \n         background: url();\n     \n Encoding Notes The following characters are encoded using hexidecimal encodings: {@code U+0000} - {@code U+001f}, {@code \"}, {@code '}, {@code \\}, {@code }, {@code U+007f}, line separator ({@code U+2028}), paragraph separator ({@code U+2029}). Any character requiring encoding is encoded as {@code \\xxx} where {@code xxx} is the shortest hexidecimal representation of its Unicode code point (after decoding surrogate pairs if necessary). This encoding is never zero padded. Thus, for example, the tab character is encoded as {@code \\9}, not {@code \\0009}. The encoder looks ahead 1 character in the input and appends a space to an encoding to avoid the next character becoming part of the hexidecimal encoded sequence. Thus \u201C{@code '1}\u201D is encoded as \u201C{@code \\27 1}\u201D, and not as \u201C{@code \\271}\u201D. If a space is not necessary, it is not included, thus \u201C{@code 'x}\u201D is encoded as \u201C{@code \\27x}\u201D, and not as \u201C{@code \\27 x}\u201D. Surrogate pairs are passed through only if valid. Invalid surrogate pairs are replaced by an underscore (_). Unicode \"non-characters\" are replaced by underscores (_).",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forCssUrl",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/4.0.0.RELEASE\/apidocs\/org\/springframework\/security\/config\/annotation\/authentication\/builders\/AuthenticationManagerBuilder.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.jdbcAuthentication",
      "jar": null,
      "comment": "Authentication to JDBC. The owner of the return object can manipulate users to a JDBC connection.",
      "parameters": [],
      "return": "org.springframework.security.config.'annotation'.authentication.configurers.provisioning.JdbcUserDetailsManagerConfigurer",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/conn\/DefaultClientConnection.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE601"
      ],
      "javadoc": {
        "method": "Sends the request line and all headers over the connection.",
        "class": "Default implementation of an operated client connection. The following parameters can be used to customize the behavior of this class: {@link org.apache.http.params.CoreProtocolPNames#STRICT_TRANSFER_ENCODING} {@link org.apache.http.params.CoreProtocolPNames#HTTP_ELEMENT_CHARSET} {@link org.apache.http.params.CoreConnectionPNames#SOCKET_BUFFER_SIZE} {@link org.apache.http.params.CoreConnectionPNames#MAX_LINE_LENGTH} {@link org.apache.http.params.CoreConnectionPNames#MAX_HEADER_COUNT}"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.conn.DefaultClientConnection.sendRequestHeader",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.apache.http.HttpRequest"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/HttpServletRequestImpl.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.HttpServletRequestImpl.access$000",
      "jar": null,
      "comment": "Counter example for sanitizer (implicit method)",
      "parameters": [
        "org.apache.xmlrpc.webserver.HttpServletRequestImpl"
      ],
      "return": "int",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/2.5.x\/api\/org\/springframework\/web\/servlet\/tags\/EscapeBodyTag.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE601"
      ],
      "javadoc": {
        "method": "Read the unescaped body content from the page.",
        "class": "Custom JSP tag to escape its enclosed body content, applying HTML escaping and\/or JavaScript escaping. Provides a \"htmlEscape\" property for explicitly specifying whether to apply HTML escaping. If not set, a page-level default (e.g. from the HtmlEscapeTag) or an application-wide default (the \"defaultHtmlEscape\" context-param in web.xml) is used. Provides a \"javaScriptEscape\" property for specifying whether to apply JavaScript escaping. Can be combined with HTML escaping or used standalone."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.servlet.tags.EscapeBodyTag.readBodyContent",
      "jar": null,
      "comment": "Source training set",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/3.2.2.RELEASE_to_4.0.0.M1\/Spring%20Framework%203.2.2.RELEASE\/org\/springframework\/web\/util\/UrlPathHelper.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Decode the given source string with a URLDecoder. The encoding will be taken from the request, falling back to the default \"ISO-8859-1\". The default implementation uses URLDecoder.decode(input, enc).",
        "class": "Helper class for URL path matching. Provides support for URL paths in RequestDispatcher includes and support for consistent URL decoding. Used by {@link org.springframework.web.servlet.handler.AbstractUrlHandlerMapping}, {@link org.springframework.web.servlet.mvc.multiaction.AbstractUrlMethodNameResolver} and {@link org.springframework.web.servlet.support.RequestContext} for path matching and\/or URI determination."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.util.UrlPathHelper.decodeRequestString",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "javax.servlet.http.HttpServletRequest",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/commons.apache.org\/proper\/commons-validator\/apidocs\/org\/apache\/commons\/validator\/util\/ValidatorUtils.html",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE306",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Replace part of a String with another value.",
        "class": "Basic utility methods. The use of FastHashMap is deprecated and will be replaced in a future release."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.validator.util.ValidatorUtils.replace",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0,
          1,
          2
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/test\/web\/servlet\/request\/MockHttpServletRequestBuilder.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Set a request attribute.",
        "class": "Default builder for {@link MockHttpServletRequest} required as input to perform requests in {@link MockMvc}. Application tests will typically access this builder through the static factory methods in {@link MockMvcRequestBuilders}. Although this class cannot be extended, additional ways to initialize the {@code MockHttpServletRequest} can be plugged in via {@link #with(RequestPostProcessor)}."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder.requestAttr",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.lang.String",
        "java.lang.Object"
      ],
      "return": "org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/web\/socket\/sockjs\/transport\/handler\/JsonpReceivingTransportHandler.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.sockjs.transport.handler.JsonpReceivingTransportHandler.readMessages",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "org.springframework.http.server.ServerHttpRequest"
      ],
      "return": "java.lang.String[]",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/google\/google-auth-library-java\/blob\/master\/oauth2_http\/java\/com\/google\/auth\/oauth2\/DefaultCredentialsProvider.java",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": "Provides the Application Default Credential from the environment. An instance represents the per-process state used to get and cache the credential and allows overriding the state and environment for testing purposes."
      },
      "framework": "oauth",
      "discovery": "manual",
      "name": "com.google.auth.oauth2.DefaultCredentialsProvider.getDefaultCredentialsUnsynchronized",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "com.google.api.client.http.HttpTransport"
      ],
      "return": "com.google.auth.oauth2.GoogleCredentials",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/expression\/spel\/ast\/LongLiteral.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Check whether a node can be compiled to bytecode. The reasoning in each node may be different but will typically involve checking whether the exit type descriptor of the node is known and any relevant child nodes are compilable.",
        "class": "Expression language AST node that represents a long integer literal."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.expression.spel.ast.LongLiteral.isCompilable",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/annotation\/web\/builders\/HttpSecurity.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.web.builders.HttpSecurity.rememberMe",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [],
      "return": "org.springframework.security.config.'annotation'.web.configurers.RememberMeConfigurer",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Constructs a cookie with the specified name and value. The name must conform to RFC 2109. However, vendors may provide a configuration option that allows cookie names conforming to the original Netscape Cookie Specification to be accepted. The name of a cookie cannot be changed once the cookie has been created. The value can be anything the server chooses to send. Its value is probably of interest only to the server. The cookie's value can be changed after creation with the setValue method. By default, cookies are created according to the Netscape cookie specification. The version can be changed with the setVersion method.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.<init>",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/OWASP\/java-html-sanitizer\/blob\/master\/src\/main\/java\/org\/owasp\/html\/Encoding.java",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE306",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Leaves in the input buffer only code-units that comprise XML safe chars.",
        "class": "Encoders and decoders for HTML."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "org.owasp.html.Encoding.stripBannedCodeunits",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.StringBuilder"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0,
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/OWASP\/json-sanitizer\/blob\/master\/src\/main\/java\/com\/google\/json\/JsonSanitizer.java",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": "Given JSON-like content, converts it to valid JSON. This can be attached at either end of a data-pipeline to help satisfy Postel's principle: be conservative in what you do, be liberal in what you accept from others Applied to JSON-like content from others, it will produce well-formed JSON that should satisfy any parser you use. Applied to your output before you send, it will coerce minor mistakes in encoding and make it easier to embed your JSON in HTML and XML. Input The sanitizer takes JSON like content, and interprets it as JS eval would. Specifically, it deals with these non-standard constructs. {@code '...'} Single quoted strings are converted to JSON strings. {@code \\xAB} Hex escapes are converted to JSON unicode escapes. {@code \\012} Octal escapes are converted to JSON unicode escapes. {@code 0xAB} Hex integer literals are converted to JSON decimal numbers. {@code 012} Octal integer literals are converted to JSON decimal numbers. {@code +.5} Decimal numbers are coerced to JSON's stricter format. {@code [0,,2]} Elisions in arrays are filled with {@code null}. {@code [1,2,3,]} Trailing commas are removed. {foo:\"bar\"} Unquoted property names are quoted. \/\/comments JS style line and block comments are removed. (...) Grouping parentheses are removed. The sanitizer fixes missing punctuation, end quotes, and mismatched or missing close brackets. If an input contains only white-space then the valid JSON string {@code null} is substituted. Output The output is well-formed JSON as defined by RFC 4627. The output satisfies three additional properties: The output will not contain the substring (case-insensitively) {@code \"The output will not contain the substring {@code \"]]>\"} so can be embedded inside an XML CDATA section without further encoding. The output is a valid Javascript expression, so can be parsed by Javascript's eval builtin (after being wrapped in parentheses) or by JSON.parse. Specifically, the output will not contain any string literals with embedded JS newlines (U+2028 Paragraph separator or U+2029 Line separator). The output contains only valid Unicode scalar values (no isolated UTF-16 surrogates) that are allowed in XML unescaped. Security Since the output is well-formed JSON, passing it to eval will have no side-effects and no free variables, so is neither a code-injection vector, nor a vector for exfiltration of secrets. This library only ensures that the JSON string â†’ Javascript object phase has no side effects and resolves no free variables, and cannot control how other client side code later interprets the resulting Javascript object. So if client-side code takes a part of the parsed data that is controlled by an attacker and passes it back through a powerful interpreter like {@code eval} or {@code innerHTML} then that client-side code might suffer unintended side-effects. Efficiency The sanitize method will return the input string without allocating a new buffer when the input is already valid JSON that satisfies the properties above. Thus, if used on input that is usually well formed, it has minimal memory overhead. The sanitize method takes O(n) time where n is the length in UTF-16 code-units."
      },
      "framework": "json",
      "discovery": "manual",
      "name": "com.google.json.JsonSanitizer.replace",
      "jar": null,
      "comment": "",
      "parameters": [
        "int",
        "int",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0,
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/HttpServletRequestImpl.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE601"
      ],
      "javadoc": {
        "method": "",
        "class": "Stub implementation of a {@link javax.servlet.http.HttpServletRequest} with lots of unimplemented methods. I implemented only those, which are required for testing the {@link org.apache.xmlrpc.webserver.XmlRpcServlet}. Perhaps someone else is adding more at a later time?"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.HttpServletRequestImpl.readLine",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "byte[]"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Prints a long integer. The string produced by {@link java.lang.String#valueOf(long)} is translated into bytes according to the platform's default character encoding, and these bytes are written in exactly the manner of the {@link #write(int)} method.",
        "class": "A PrintStream adds functionality to another output stream, namely the ability to print representations of various data values conveniently. Two other features are provided as well. Unlike other output streams, a PrintStream never throws an IOException; instead, exceptional situations merely set an internal flag that can be tested via the checkError method. Optionally, a PrintStream can be created so as to flush automatically; this means that the flush method is automatically invoked after a byte array is written, one of the println methods is invoked, or a newline character or byte ('\\n') is written. All characters printed by a PrintStream are converted into bytes using the platform's default character encoding. The {@link PrintWriter} class should be used in situations that require writing characters rather than bytes."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.PrintStream.print",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "long"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "A validator performs syntax and possibly semantic validation of a single piece of data from an untrusted source."
      },
      "framework": "owaspesapi",
      "discovery": "manual",
      "name": "org.owasp.esapi.reference.validation.StringValidationRule.addBlacklistPattern",
      "jar": null,
      "comment": "Counter example for sanitizer (validation)",
      "parameters": [
        "java.util.regex.Pattern"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/web\/socket\/BinaryMessage.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Create a new binary WebSocket message with the given byte[] payload.",
        "class": "A binary WebSocket message."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.BinaryMessage.<init>",
      "jar": null,
      "comment": "Counter example for sanitizer (byte[] as param, but init)",
      "parameters": [
        "byte[]"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Construct an XPath object. (Needs review -sc) This method initializes an XPathParser\/ Compiler and compiles the expression.",
        "class": "The XPath class wraps an expression object and provides general services for execution of that expression."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.apache.xpath.XPath.<init>",
      "jar": "apache-xml-xalan.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "javax.xml.transform.SourceLocator",
        "org.apache.xml.utils.PrefixResolver",
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE306",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Replaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence. The replacement proceeds from the beginning of the string to the end, for example, replacing \"aa\" with \"b\" in the string \"aaa\" will result in \"ba\" rather than \"ab\".",
        "class": "The {@code String} class represents character strings. All string literals in Java programs, such as {@code \"abc\"}, are implemented as instances of this class. Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared. For example:      String str = \"abc\";\n is equivalent to:      char data[] = {'a', 'b', 'c'};\n     String str = new String(data);\n Here are some more examples of how strings can be used:      System.out.println(\"abc\");\n     String cde = \"cde\";\n     System.out.println(\"abc\" + cde);\n     String c = \"abc\".substring(2,3);\n     String d = cde.substring(1, 2);\n The class {@code String} includes methods for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings, and for creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode Standard version specified by the {@link java.lang.Character Character} class. The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. String concatenation is implemented through the {@code StringBuilder}(or {@code StringBuffer}) class and its {@code append} method. String conversions are implemented through the method {@code toString}, defined by {@code Object} and inherited by all classes in Java. For additional information on string concatenation and conversion, see Gosling, Joy, and Steele, The Java Language Specification. Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a {@link NullPointerException} to be thrown. A {@code String} represents a string in the UTF-16 format in which supplementary characters are represented by surrogate pairs (see the section Unicode Character Representations in the {@code Character} class for more information). Index values refer to {@code char} code units, so a supplementary character uses two positions in a {@code String}. The {@code String} class provides methods for dealing with Unicode code points (i.e., characters), in addition to those for dealing with Unicode code units (i.e., {@code char} values)."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "java.lang.String.replace",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.CharSequence",
        "java.lang.CharSequence"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "When using ProxyPass, requestCycle().getHttpServletRequest(). getRemoteAddr() returns the IP of the machine forwarding the request. In order to maintain the clients ip address, the server places it in the X-Forwarded-For Header. Proxies may also mask the original client IP with tokens like \"hidden\" or \"unknown\". If so, the last proxy ip address is returned.",
        "class": "Default client info object for web applications."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.request.WebClientInfo.getRemoteAddr",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [
        "org.apache.wicket.request.cycle.RequestCycle"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078"
      ],
      "javadoc": {
        "method": "Loads the native library specified by the filename argument. The filename argument must be an absolute path name. If the filename argument, when stripped of any platform-specific library prefix, path, and file extension, indicates a library whose name is, for example, L, and a native library called L is statically linked with the VM, then the JNI_OnLoad_L function exported by the library is invoked rather than attempting to load a dynamic library. A filename matching the argument does not have to exist in the file system. See the JNI Specification for more details. Otherwise, the filename argument is mapped to a native library image in an implementation-dependent manner. The call System.load(name) is effectively equivalent to the call:  Runtime.getRuntime().load(name)",
        "class": "The System class contains several useful class fields and methods. It cannot be instantiated. Among the facilities provided by the System class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.System.load",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/NTLMScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces NTLM authorization string for the given set of {@link Credentials}.",
        "class": "An implementation of the Microsoft proprietary NTLM authentication scheme. For a detailed explanation of the NTLM scheme please see http:\/\/davenport.sourceforge.net\/ntlm.html."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.NTLMScheme.authenticate",
      "jar": null,
      "comment": "Depricated method. The credentials are provided. The authentication string is returned.",
      "parameters": [
        "org.apache.commons.httpclient.Credentials",
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/javax\/security\/auth\/login\/LoginContext.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "ldap",
      "discovery": "manual",
      "name": "com.novell.ldap.spml.NoAuthImpl.logout",
      "jar": null,
      "comment": "Puts the program is an unauthenticated state.",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/grepcode.com\/file\/repo1.maven.org\/maven2\/org.apache.axis2\/axis2-kernel\/1.4\/org\/apache\/axis2\/util\/Utils.java",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.axis2.util.Utils.sanitizeWebOutput",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/util\/FieldUtils.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "Offers static methods for directly manipulating fields."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.springframework.security.util.FieldUtils.setProtectedFieldValue",
      "jar": null,
      "comment": "Counter example for sanitizer (set)",
      "parameters": [
        "java.lang.String",
        "java.lang.Object",
        "java.lang.Object"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/mock\/web\/MockBodyContent.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Print an array of characters and then terminate the line. This method behaves as though it invokes print(char[]) and then println().",
        "class": "Mock implementation of the {@link javax.servlet.jsp.tagext.BodyContent} class. Used for testing the web framework; only necessary for testing applications when testing custom JSP tags."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.mock.web.MockBodyContent.println",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "char[]"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/xref\/org\/apache\/commons\/httpclient\/HttpMethodDirector.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": "Handles the process of executing a method including authentication, redirection and retries."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.HttpMethodDirector.authenticateHost",
      "jar": null,
      "comment": "The authentication string is added to the http method.",
      "parameters": [
        "org.apache.commons.httpclient.HttpMethod"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Performs percent-encoding of a URL according to RFC 3986. The provided URL is assumed to a valid URL. This method does not do any checking on the quality or safety of the URL itself. In many applications it may be better to use {@link java.net.URI} instead. Note: this is a particularly dangerous context to put untrusted content in, as for example a \"javascript:\" URL provided by a malicious user would be \"properly\" escaped, and still execute. Encoding Table The following characters are not encoded:  U+20:   !   # $   & ' ( ) * + , - . \/ 0 1 2 3 4 5 6 7 8 9 : ;   =   ?\n U+40: @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [   ]   _\n U+60:   a b c d e f g h i j k l m n o p q r s t u v w x y z       ~\n Encoding Notes The single-quote character({@code '}) is not encoded. This encoding is not intended to be used standalone. The output should be encoded to the target context. For example: {@code ...}. (Note, the single-quote character ({@code '}) is not encoded.) URL encoding is an encoding for bytes, not unicode. The input string is thus first encoded as a sequence of UTF-8 byte. The bytes are then encoded as {@code %xx} where {@code xx} is the two-digit hexidecimal representation of the byte. (The implementation does this as one step for performance.) Surrogate pairs are first decoded to a Unicode code point before encoding as UTF-8. Invalid characters (e.g. partial or invalid surrogate pairs), are replaced with a hyphen ({@code -}) character.",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forUri",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/spring-projects\/spring-security\/blob\/master\/config\/src\/main\/java\/org\/springframework\/security\/config\/http\/LogoutBeanDefinitionParser.java",
      "type": [
        "authentication",
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862",
        "CWE601"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.http.LogoutBeanDefinitionParser.getLogoutRequestMatcher",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "org.springframework.beans.factory.config.BeanDefinition",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getHeader(String name) on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getHeader",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getParameterValues(String name) on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getParameterValues",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String[]",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/static.javadoc.io\/org.owasp.esapi\/esapi\/2.0.1\/org\/owasp\/esapi\/reference\/validation\/CreditCardValidationRule.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "A validator performs syntax and possibly semantic validation of Credit Card String from an untrusted source."
      },
      "framework": "owaspesapi",
      "discovery": "manual",
      "name": "org.owasp.esapi.reference.validation.CreditCardValidationRule.setMaxCardLength",
      "jar": null,
      "comment": "Counter example for sanitizer (validation)",
      "parameters": [
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService.access$200",
      "jar": null,
      "comment": "Counter example for sanitizer (implicit method)",
      "parameters": [
        "org.springframework.web.socket.sockjs.transport.TransportHandlingSockJsService"
      ],
      "return": "org.apache.commons.logging.Log",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Loads all of the properties represented by the XML document on the specified input stream into this properties table. The XML document must have the following DOCTYPE declaration:  \n Furthermore, the document must satisfy the properties DTD described above. An implementation is required to read XML documents that use the \"{@code UTF-8}\" or \"{@code UTF-16}\" encoding. An implementation may support additional encodings. The specified stream is closed after this method returns.",
        "class": "The {@code Properties} class represents a persistent set of properties. The {@code Properties} can be saved to a stream or loaded from a stream. Each key and its corresponding value in the property list is a string. A property list can contain another property list as its \"defaults\"; this second property list is searched if the property key is not found in the original property list. Because {@code Properties} inherits from {@code Hashtable}, the {@code put} and {@code putAll} methods can be applied to a {@code Properties} object. Their use is strongly discouraged as they allow the caller to insert entries whose keys or values are not {@code Strings}. The {@code setProperty} method should be used instead. If the {@code store} or {@code save} method is called on a \"compromised\" {@code Properties} object that contains a non-{@code String} key or value, the call will fail. Similarly, the call to the {@code propertyNames} or {@code list} method will fail if it is called on a \"compromised\" {@code Properties} object that contains a non-{@code String} key. The {@link #load(java.io.Reader) load(Reader)} \/ {@link #store(java.io.Writer, java.lang.String) store(Writer, String)} methods load and store properties from and to a character based stream in a simple line-oriented format specified below. The {@link #load(java.io.InputStream) load(InputStream)} \/ {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)} methods work the same way as the load(Reader)\/store(Writer, String) pair, except the input\/output stream is encoded in ISO 8859-1 character encoding. Characters that cannot be directly represented in this encoding can be written using Unicode escapes as defined in section 3.3 of The Javaâ„¢ Language Specification; only a single 'u' character is allowed in an escape sequence. The native2ascii tool can be used to convert property files to and from other character encodings. The {@link #loadFromXML(InputStream)} and {@link #storeToXML(OutputStream, String, String)} methods load and store properties in a simple XML format. By default the UTF-8 character encoding is used, however a specific encoding may be specified if required. Implementations are required to support UTF-8 and UTF-16 and may support other encodings. An XML properties document has the following DOCTYPE declaration:  \n Note that the system URI (http:\/\/java.sun.com\/dtd\/properties.dtd) is not accessed when exporting or importing properties; it merely serves as a string to uniquely identify the DTD, which is:     \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n This class is thread-safe: multiple threads can share a single Properties object without the need for external synchronization."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.util.Properties.loadFromXML",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.io.InputStream"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getCharacterEncoding() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getCharacterEncoding",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.server.standard.WebLogicRequestUpgradeStrategy.access$800",
      "jar": null,
      "comment": "Counter example for sanitizer (implicit method)",
      "parameters": [
        "java.lang.String",
        "java.lang.String",
        "java.lang.Class[]"
      ],
      "return": "java.lang.reflect.Method",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/annotation\/web\/configurers\/LogoutConfigurer.html",
      "type": [
        "authentication",
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "Gets the {@link LogoutHandler} instances that will be used.",
        "class": "Adds logout support. Other {@link SecurityConfigurer} instances may invoke {@link #addLogoutHandler(LogoutHandler)} in the {@link #init(HttpSecurity)} phase. Security Filters The following Filters are populated {@link LogoutFilter} Shared Objects Created No shared Objects are created Shared Objects Used No shared objects are used."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.web.configurers.LogoutConfigurer.getLogoutHandlers",
      "jar": null,
      "comment": "",
      "parameters": [],
      "return": "java.util.List",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/client\/HttpAuthenticator.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.client.HttpAuthenticator.authenticate",
      "jar": null,
      "comment": "Depricated method. The authentication string is added to the http response.",
      "parameters": [
        "org.apache.http.HttpHost",
        "org.apache.http.HttpResponse",
        "org.apache.http.client.AuthenticationStrategy",
        "org.apache.http.auth.AuthState",
        "org.apache.http.protocol.HttpContext"
      ],
      "return": "boolean",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/3.2.8.RELEASE_to_3.2.9.RELEASE\/Spring%20Framework%203.2.8.RELEASE\/org\/springframework\/web\/util\/OpaqueUriComponents.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Encode all URI components using their specific encoding rules, and returns the result as a new {@code UriComponents} instance.",
        "class": "Extension of {@link UriComponents} for opaque URIs."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.util.OpaqueUriComponents.encode",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "org.springframework.web.util.UriComponents",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Helper method to write out the index to disk.",
        "class": "Keeps an index of all blog entries from a specific author, allowing efficient access at runtime."
      },
      "framework": "pebble",
      "discovery": "manual",
      "name": "net.sourceforge.pebble.index.AuthorIndex.writeIndex",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/XmlRpcServlet.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.XmlRpcServlet.class$",
      "jar": null,
      "comment": "Counter example for sanitizer (String as param, but implicit method)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.Class",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/4.3.9.RELEASE\/javadoc-api\/org\/springframework\/format\/datetime\/joda\/DateTimeParser.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Parse a text String to produce a T.",
        "class": "Parses Joda {@link DateTime} instances using a {@link DateTimeFormatter}."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.format.datetime.joda.DateTimeParser.parse",
      "jar": null,
      "comment": "Counter example for sources.",
      "parameters": [
        "java.lang.String",
        "java.util.Locale"
      ],
      "return": "org.joda.time.DateTime",
      "dataIn": {
        "parameters": [
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/2.0.0\/api\/org\/springframework\/beans\/factory\/support\/DisposableBeanAdapter.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Serializes a copy of the state of this class, filtering out non-serializable BeanPostProcessors.",
        "class": "Adapter that implements the {@link DisposableBean} and {@link Runnable} interfaces performing various destruction steps on a given bean instance: DestructionAwareBeanPostProcessors; the bean implementing DisposableBean itself; a custom destroy method specified on the bean definition."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.beans.factory.support.DisposableBeanAdapter.writeReplace",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE306",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Replaces each substring of this string that matches the given regular expression with the given replacement. An invocation of this method of the form str{@code .replaceAll(}regex{@code ,} repl{@code )} yields exactly the same result as the expression {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#compile compile}(regex).{@link java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(str).{@link java.util.regex.Matcher#replaceAll replaceAll}(repl) Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}. Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special meaning of these characters, if desired.",
        "class": "The {@code String} class represents character strings. All string literals in Java programs, such as {@code \"abc\"}, are implemented as instances of this class. Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared. For example:      String str = \"abc\";\n is equivalent to:      char data[] = {'a', 'b', 'c'};\n     String str = new String(data);\n Here are some more examples of how strings can be used:      System.out.println(\"abc\");\n     String cde = \"cde\";\n     System.out.println(\"abc\" + cde);\n     String c = \"abc\".substring(2,3);\n     String d = cde.substring(1, 2);\n The class {@code String} includes methods for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings, and for creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode Standard version specified by the {@link java.lang.Character Character} class. The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. String concatenation is implemented through the {@code StringBuilder}(or {@code StringBuffer}) class and its {@code append} method. String conversions are implemented through the method {@code toString}, defined by {@code Object} and inherited by all classes in Java. For additional information on string concatenation and conversion, see Gosling, Joy, and Steele, The Java Language Specification. Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a {@link NullPointerException} to be thrown. A {@code String} represents a string in the UTF-16 format in which supplementary characters are represented by surrogate pairs (see the section Unicode Character Representations in the {@code Character} class for more information). Index values refer to {@code char} code units, so a supplementary character uses two positions in a {@code String}. The {@code String} class provides methods for dealing with Unicode code points (i.e., characters), in addition to those for dealing with Unicode code units (i.e., {@code char} values)."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "java.lang.String.replaceAll",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Log a CONFIG message. If the logger is currently enabled for the CONFIG message level then the given message is forwarded to all the registered output Handler objects.",
        "class": "A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the {@code getLogger} factory methods may be garbage collected at any time if a strong reference to the Logger is not kept. Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree. The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent. On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree. Each Logger may have a {@code ResourceBundle} associated with it. The {@code ResourceBundle} may be specified by name, using the {@link #getLogger(java.lang.String, java.lang.String)} factory method, or by value - using the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method. This bundle will be used for localizing logging messages. If a Logger does not have its own {@code ResourceBundle} or resource bundle name, then it will inherit the {@code ResourceBundle} or resource bundle name from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument. These methods take a {@link Supplier}{@code } function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       \/\/ collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled. \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n When looking for a {@code ResourceBundle}, the logger will first look at whether a bundle was specified using {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then only whether a resource bundle name was specified through the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. If no {@code ResourceBundle} or no resource bundle name is found, then it will use the nearest {@code ResourceBundle} or resource bundle name inherited from its parent tree. When a {@code ResourceBundle} was inherited or specified through the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then that {@code ResourceBundle} will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a {@code ResourceBundle} object, using the default Locale at the time of logging. When mapping resource bundle names to {@code ResourceBundle} objects, the logger will first try to use the Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class loader} to map the given resource bundle name to a {@code ResourceBundle}. If the thread context class loader is {@code null}, it will try the {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader} instead. If the {@code ResourceBundle} is still not found, it will use the class loader of the first caller of the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string. There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name. There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message. There are convenience methods for tracing method entries (the \"entering\" methods), method returns (the \"exiting\" methods) and throwing exceptions (the \"throwing\" methods). Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string. For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.logging.Logger.config",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/RequestData.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE601"
      ],
      "javadoc": {
        "method": "Returns the requests HTTP version.",
        "class": "Web servers extension of {@link org.apache.xmlrpc.common.XmlRpcHttpRequestConfig}, which allows to store additional per request data."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.RequestData.getHttpVersion",
      "jar": null,
      "comment": "Counter example for sanitizer.",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/xref\/org\/apache\/commons\/httpclient\/HttpMethodDirector.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": "Handles the process of executing a method including authentication, redirection and retries."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.HttpMethodDirector.authenticate",
      "jar": null,
      "comment": "The authentication string is added to the http method.",
      "parameters": [
        "org.apache.commons.httpclient.HttpMethod"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/javax\/security\/auth\/login\/LoginContext.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Logout the {@code Subject}. This method invokes the {@code logout} method for each {@code LoginModule} configured for this {@code LoginContext}. Each {@code LoginModule} performs its respective logout procedure which may include removing\/destroying {@code Principal} and {@code Credential} information from the {@code Subject} and state cleanup. Note that this method invokes all LoginModules configured for the application regardless of their respective {@code Configuration} flag parameters. Essentially this means that {@code Requisite} and {@code Sufficient} semantics are ignored for this method. This guarantees that proper cleanup and state restoration can take place.",
        "class": "The {@code LoginContext} class describes the basic methods used to authenticate Subjects and provides a way to develop an application independent of the underlying authentication technology. A {@code Configuration} specifies the authentication technology, or {@code LoginModule}, to be used with a particular application. Different LoginModules can be plugged in under an application without requiring any modifications to the application itself. In addition to supporting pluggable authentication, this class also supports the notion of stacked authentication. Applications may be configured to use more than one LoginModule. For example, one could configure both a Kerberos LoginModule and a smart card LoginModule under an application. A typical caller instantiates a LoginContext with a name and a {@code CallbackHandler}. LoginContext uses the name as the index into a Configuration to determine which LoginModules should be used, and which ones must succeed in order for the overall authentication to succeed. The {@code CallbackHandler} is passed to the underlying LoginModules so they may communicate and interact with users (prompting for a username and password via a graphical user interface, for example). Once the caller has instantiated a LoginContext, it invokes the {@code login} method to authenticate a {@code Subject}. The {@code login} method invokes the configured modules to perform their respective types of authentication (username\/password, smart card pin verification, etc.). Note that the LoginModules will not attempt authentication retries nor introduce delays if the authentication fails. Such tasks belong to the LoginContext caller. If the {@code login} method returns without throwing an exception, then the overall authentication succeeded. The caller can then retrieve the newly authenticated Subject by invoking the {@code getSubject} method. Principals and Credentials associated with the Subject may be retrieved by invoking the Subject's respective {@code getPrincipals}, {@code getPublicCredentials}, and {@code getPrivateCredentials} methods. To logout the Subject, the caller calls the {@code logout} method. As with the {@code login} method, this {@code logout} method invokes the {@code logout} method for the configured modules. A LoginContext should not be used to authenticate more than one Subject. A separate LoginContext should be used to authenticate each different Subject. The following documentation applies to all LoginContext constructors: {@code Subject} If the constructor has a Subject input parameter, the LoginContext uses the caller-specified Subject object. If the caller specifies a {@code null} Subject and a {@code null} value is permitted, the LoginContext instantiates a new Subject. If the constructor does not have a Subject input parameter, the LoginContext instantiates a new Subject. {@code Configuration} If the constructor has a Configuration input parameter and the caller specifies a non-null Configuration, the LoginContext uses the caller-specified Configuration. If the constructor does not have a Configuration input parameter, or if the caller specifies a {@code null} Configuration object, the constructor uses the following call to get the installed Configuration:       config = Configuration.getConfiguration();\n For both cases, the name argument given to the constructor is passed to the {@code Configuration.getAppConfigurationEntry} method. If the Configuration has no entries for the specified name, then the {@code LoginContext} calls {@code getAppConfigurationEntry} with the name, \"other\" (the default entry name). If there is no entry for \"other\", then a {@code LoginException} is thrown. When LoginContext uses the installed Configuration, the caller requires the createLoginContext.name and possibly createLoginContext.other AuthPermissions. Furthermore, the LoginContext will invoke configured modules from within an {@code AccessController.doPrivileged} call so that modules that perform security-sensitive tasks (such as connecting to remote hosts, and updating the Subject) will require the respective permissions, but the callers of the LoginContext will not require those permissions. When LoginContext uses a caller-specified Configuration, the caller does not require any createLoginContext AuthPermission. The LoginContext saves the {@code AccessControlContext} for the caller, and invokes the configured modules from within an {@code AccessController.doPrivileged} call constrained by that context. This means the caller context (stored when the LoginContext was created) must have sufficient permissions to perform any security-sensitive tasks that the modules may perform. {@code CallbackHandler} If the constructor has a CallbackHandler input parameter, the LoginContext uses the caller-specified CallbackHandler object. If the constructor does not have a CallbackHandler input parameter, or if the caller specifies a {@code null} CallbackHandler object (and a {@code null} value is permitted), the LoginContext queries the {@code auth.login.defaultCallbackHandler} security property for the fully qualified class name of a default handler implementation. If the security property is not set, then the underlying modules will not have a CallbackHandler for use in communicating with users. The caller thus assumes that the configured modules have alternative means for authenticating the user. When the LoginContext uses the installed Configuration (instead of a caller-specified Configuration, see above), then this LoginContext must wrap any caller-specified or default CallbackHandler implementation in a new CallbackHandler implementation whose {@code handle} method implementation invokes the specified CallbackHandler's {@code handle} method in a {@code java.security.AccessController.doPrivileged} call constrained by the caller's current {@code AccessControlContext}."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "javax.security.auth.login.LoginContext.logout",
      "jar": null,
      "comment": "Puts the program is an unauthenticated state.",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Appends the toString that would be produced by {@code Object} if a class did not override toString itself. {@code null} will throw a NullPointerException for either of the two parameters.  ObjectUtils.identityToString(builder, \"\")            = builder.append(\"java.lang.String@1e23\"\n ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\"\n ObjectUtils.identityToString(builder, Boolean.TRUE)  = builder.append(\"java.lang.Boolean@7fa\")",
        "class": "Operations on {@code Object}. This class tries to handle {@code null} input gracefully. An exception will generally not be thrown for a {@code null} input. Each method documents its behaviour in more detail. #ThreadSafe#"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.lang3.ObjectUtils.identityToString",
      "jar": null,
      "comment": "Counter example for sanitizer",
      "parameters": [
        "java.lang.StringBuilder",
        "java.lang.Object"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/commons.apache.org\/proper\/commons-io\/javadocs\/api-2.5\/org\/apache\/commons\/io\/HexDump.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Dump an array of bytes to an OutputStream. The output is formatted for human inspection, with a hexadecimal offset followed by the hexadecimal values of the next 16 bytes of data and the printable ASCII characters (if any) that those bytes represent printed per each line of output. The offset argument specifies the start offset of the data array within a larger entity like a file or an incoming stream. For example, if the data array contains the third kibibyte of a file, then the offset argument should be set to 2048. The offset value printed at the beginning of each line indicates where in that larger entity the first byte on that line is located. All bytes between the given index (inclusive) and the end of the data array are dumped.",
        "class": "Dumps data in hexadecimal format. Provides a single function to take an array of bytes and display it in hexadecimal form. Origin of code: POI."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.io.HexDump.dump",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "byte[]",
        "long",
        "java.io.OutputStream",
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0,
          2
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Writes a String to the client, followed by a carriage return-line feed (CRLF).",
        "class": "Provides an output stream for sending binary data to the client. A ServletOutputStream object is normally retrieved via the {@link ServletResponse#getOutputStream} method. This is an abstract class that the servlet container implements. Subclasses of this class must implement the java.io.OutputStream.write(int) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletOutputStream.println",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/www.novell.com\/documentation\/developer\/jldap\/jldapenu\/api\/com\/novell\/ldap\/LDAPConnection.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Connects to the specified host and port. If this LDAPConnection object represents an open connection, the connection is closed first before the new connection is opened. At this point, there is no authentication, and any operations are conducted as an anonymous client. When more than one host name is specified, each host is contacted in turn until a connection can be established.",
        "class": "The central class that encapsulates the connection to a directory server through the LDAP protocol. LDAPConnection objects are used to perform common LDAP operations such as search, modify and add. In addition, LDAPConnection objects allow you to bind to an LDAP server, set connection and search constraints, and perform several other tasks. An LDAPConnection object is not connected on construction and can only be connected to one server at one port. Multiple threads may share this single connection, typically by cloning the connection object, one for each thread. An application may have more than one LDAPConnection object, connected to the same or different directory servers. Sample Code: Search.java"
      },
      "framework": "ldap",
      "discovery": "manual",
      "name": "com.novell.ldap.LDAPConnection.connect",
      "jar": null,
      "comment": "Create a connection to the host and port. ",
      "parameters": [
        "java.lang.String",
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Creates a new FileReader, given the name of the file to read from.",
        "class": "Convenience class for reading character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are appropriate. To specify these values yourself, construct an InputStreamReader on a FileInputStream. FileReader is meant for reading streams of characters. For reading streams of raw bytes, consider using a FileInputStream."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.FileReader.<init>",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Creates a new File instance by converting the given pathname string into an abstract pathname. If the given string is the empty string, then the result is the empty abstract pathname.",
        "class": "An abstract representation of file and directory pathnames. User interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames. An abstract pathname has two components: An optional system-dependent prefix string, such as a disk-drive specifier, \"\/\" for the UNIX root directory, or \"\\\\\\\\\" for a Microsoft Windows UNC pathname, and A sequence of zero or more string names. The first name in an abstract pathname may be a directory name or, in the case of Microsoft Windows UNC pathnames, a hostname. Each subsequent name in an abstract pathname denotes a directory; the last name may denote either a directory or a file. The empty abstract pathname has no prefix and an empty name sequence. The conversion of a pathname string to or from an abstract pathname is inherently system-dependent. When an abstract pathname is converted into a pathname string, each name is separated from the next by a single copy of the default separator character. The default name-separator character is defined by the system property file.separator, and is made available in the public static fields {@link #separator} and {@link #separatorChar} of this class. When a pathname string is converted into an abstract pathname, the names within it may be separated by the default name-separator character or by any other name-separator character that is supported by the underlying system. A pathname, whether abstract or in string form, may be either absolute or relative. An absolute pathname is complete in that no other information is required in order to locate the file that it denotes. A relative pathname, in contrast, must be interpreted in terms of information taken from some other pathname. By default the classes in the java.io package always resolve relative pathnames against the current user directory. This directory is named by the system property user.dir, and is typically the directory in which the Java virtual machine was invoked. The parent of an abstract pathname may be obtained by invoking the {@link #getParent} method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any File object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname \"\/usr\" is an ancestor of the directory denoted by the pathname \"\/usr\/local\/bin\". The prefix concept is used to handle root directories on UNIX platforms, and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms, as follows: For UNIX platforms, the prefix of an absolute pathname is always \"\/\". Relative pathnames have no prefix. The abstract pathname denoting the root directory has the prefix \"\/\" and an empty name sequence. For Microsoft Windows platforms, the prefix of a pathname that contains a drive specifier consists of the drive letter followed by \":\" and possibly followed by \"\\\\\" if the pathname is absolute. The prefix of a UNC pathname is \"\\\\\\\\\"; the hostname and the share name are the first two names in the name sequence. A relative pathname that does not specify a drive has no prefix. Instances of this class may or may not denote an actual file-system object such as a file or a directory. If it does denote such an object then that object resides in a partition. A partition is an operating system-specific portion of storage for a file system. A single storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may contain multiple partitions. The object, if any, will reside on the partition named by some ancestor of the absolute form of this pathname. A file system may implement restrictions to certain operations on the actual file-system object, such as reading, writing, and executing. These restrictions are collectively known as access permissions. The file system may have multiple sets of access permissions on a single object. For example, one set may apply to the object's owner, and another may apply to all other users. The access permissions on an object may cause some methods in this class to fail. Instances of the File class are immutable; that is, once created, the abstract pathname represented by a File object will never change. Interoperability with {@code java.nio.file} package The {@code java.nio.file} package defines interfaces and classes for the Java virtual machine to access files, file attributes, and file systems. This API may be used to overcome many of the limitations of the {@code java.io.File} class. The {@link #toPath toPath} method may be used to obtain a {@link Path} that uses the abstract path represented by a {@code File} object to locate a file. The resulting {@code Path} may be used with the {@link java.nio.file.Files} class to provide more efficient and extensive access to additional file operations, file attributes, and I\/O exceptions to help diagnose errors when an operation on a file fails."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.File.<init>",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/aop\/support\/StaticMethodMatcher.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.aop.support.StaticMethodMatcher.isRuntime",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Log a WARNING message. If the logger is currently enabled for the WARNING message level then the given message is forwarded to all the registered output Handler objects.",
        "class": "A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the {@code getLogger} factory methods may be garbage collected at any time if a strong reference to the Logger is not kept. Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree. The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent. On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree. Each Logger may have a {@code ResourceBundle} associated with it. The {@code ResourceBundle} may be specified by name, using the {@link #getLogger(java.lang.String, java.lang.String)} factory method, or by value - using the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method. This bundle will be used for localizing logging messages. If a Logger does not have its own {@code ResourceBundle} or resource bundle name, then it will inherit the {@code ResourceBundle} or resource bundle name from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument. These methods take a {@link Supplier}{@code } function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       \/\/ collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled. \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n When looking for a {@code ResourceBundle}, the logger will first look at whether a bundle was specified using {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then only whether a resource bundle name was specified through the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. If no {@code ResourceBundle} or no resource bundle name is found, then it will use the nearest {@code ResourceBundle} or resource bundle name inherited from its parent tree. When a {@code ResourceBundle} was inherited or specified through the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then that {@code ResourceBundle} will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a {@code ResourceBundle} object, using the default Locale at the time of logging. When mapping resource bundle names to {@code ResourceBundle} objects, the logger will first try to use the Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class loader} to map the given resource bundle name to a {@code ResourceBundle}. If the thread context class loader is {@code null}, it will try the {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader} instead. If the {@code ResourceBundle} is still not found, it will use the class loader of the first caller of the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string. There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name. There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message. There are convenience methods for tracing method entries (the \"entering\" methods), method returns (the \"exiting\" methods) and throwing exceptions (the \"throwing\" methods). Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string. For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.logging.Logger.warning",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns a {@code String} value for a CSV column enclosed in double quotes, if required. If the value contains a comma, newline or double quote, then the String value is returned enclosed in double quotes. Any double quote characters in the value are escaped with another double quote. If the value does not contain a comma, newline or double quote, then the String value is returned unchanged. see Wikipedia and RFC 4180.",
        "class": "Escapes and unescapes {@code String}s for Java, Java Script, HTML and XML. #ThreadSafe#"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.apache.commons.lang3.StringEscapeUtils.escapeCsv",
      "jar": "commons-lang3-3.10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Decodes a {@code application\/x-www-form-urlencoded} string using a specific encoding scheme. The supplied encoding is used to determine what characters are represented by any consecutive sequences of the form \"{@code %xy}\". Note: The World Wide Web Consortium Recommendation states that UTF-8 should be used. Not doing so may introduce incompatibilities.",
        "class": "Utility class for HTML form decoding. This class contains static methods for decoding a String from the application\/x-www-form-urlencoded MIME format. The conversion process is the reverse of that used by the URLEncoder class. It is assumed that all characters in the encoded string are one of the following: \"{@code a}\" through \"{@code z}\", \"{@code A}\" through \"{@code Z}\", \"{@code 0}\" through \"{@code 9}\", and \"{@code -}\", \"{@code _}\", \"{@code .}\", and \"{@code *}\". The character \"{@code %}\" is allowed but is interpreted as the start of a special escaped sequence. The following rules are applied in the conversion: The alphanumeric characters \"{@code a}\" through \"{@code z}\", \"{@code A}\" through \"{@code Z}\" and \"{@code 0}\" through \"{@code 9}\" remain the same. The special characters \"{@code .}\", \"{@code -}\", \"{@code *}\", and \"{@code _}\" remain the same. The plus sign \"{@code +}\" is converted into a space character \" \" . A sequence of the form \"{@code %xy}\" will be treated as representing a byte where xy is the two-digit hexadecimal representation of the 8 bits. Then, all substrings that contain one or more of these byte sequences consecutively will be replaced by the character(s) whose encoding would result in those consecutive bytes. The encoding scheme used to decode these characters may be specified, or if unspecified, the default encoding of the platform will be used. There are two possible ways in which this decoder could deal with illegal strings. It could either leave illegal characters alone or it could throw an {@link java.lang.IllegalArgumentException}. Which approach the decoder takes is left to the implementation."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.net.URLDecoder.decode",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to call addDateHeader(String name, long date) on the wrapped response object.",
        "class": "Provides a convenient implementation of the HttpServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletResponseWrapper.addDateHeader",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "long"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Turn special characters into escaped characters conforming to JavaScript. Handles complete character set defined in HTML 4.01 recommendation.",
        "class": "Utility class for JavaScript escaping. Escapes based on the JavaScript 1.5 recommendation. Reference: Core JavaScript 1.5 Guide"
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.springframework.web.util.JavaScriptUtils.javaScriptEscape",
      "jar": "spring-web-4.3.9.RELEASE.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.ClientProperties.getNavigatorLanguage",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Execute a SQL statement that retruns a single ResultSet",
        "class": "A Statement object is used for executing a static SQL statement and obtaining the results produced by it. Only one ResultSet per Statement can be open at any point in time. Therefore, if the reading of one ResultSet is interleaved with the reading of another, each must have been generated by different Statements. All statement execute methods implicitly close a statement's current ResultSet if an open one exists."
      },
      "framework": "java",
      "discovery": "manual",
      "name": "com.mysql.jdbc.Statement.executeQuery",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.sql.ResultSet",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Unescapes any Java literals found in the {@code String}. For example, it will turn a sequence of {@code '\\'} and {@code 'n'} into a newline character, unless the {@code '\\'} is preceded by another {@code '\\'}.",
        "class": "Escapes and unescapes {@code String}s for Java, Java Script, HTML and XML. #ThreadSafe#"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.apache.commons.lang3.StringEscapeUtils.unescapeJava",
      "jar": "commons-lang3-3.10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/scribejava\/scribejava\/blob\/master\/scribejava-core\/src\/main\/java\/com\/github\/scribejava\/core\/oauth\/OAuth20Service.java",
      "type": [
        "authentication",
        "sink"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "scribejava",
      "discovery": "manual",
      "name": "com.github.scribejava.core.oauth.OAuth20Service.sendAccessTokenRequestAsync",
      "jar": null,
      "comment": "Authenticates the request",
      "parameters": [
        "com.github.scribejava.core.model.OAuthRequestAsync",
        "com.github.scribejava.core.model.OAuthAsyncRequestCallback"
      ],
      "return": "java.util.concurrent.Future",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Reads a line of text. A line is considered to be terminated by any one of a line feed ('\\n'), a carriage return ('\\r'), or a carriage return followed immediately by a linefeed.",
        "class": "Reads text from a character-input stream, buffering characters so as to provide for the efficient reading of characters, arrays, and lines. The buffer size may be specified, or the default size may be used. The default is large enough for most purposes. In general, each read request made of a Reader causes a corresponding read request to be made of the underlying character or byte stream. It is therefore advisable to wrap a BufferedReader around any Reader whose read() operations may be costly, such as FileReaders and InputStreamReaders. For example,  BufferedReader in\n   = new BufferedReader(new FileReader(\"foo.in\"));\n will buffer the input from the specified file. Without buffering, each invocation of read() or readLine() could cause bytes to be read from the file, converted into characters, and then returned, which can be very inefficient. Programs that use DataInputStreams for textual input can be localized by replacing each DataInputStream with an appropriate BufferedReader."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.io.BufferedReader.readLine",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encoder for XML and XHTML. See {@link #forHtml(String)} for a description of the encoding and context.",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forXml",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/4.3.9.RELEASE\/javadoc-api\/org\/springframework\/mock\/web\/portlet\/MockPortletRequest.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": "Mock implementation of the {@link javax.portlet.PortletRequest} interface."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.mock.web.portlet.MockPortletRequest.setParameters",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.util.Map"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/OWASP\/WebGoat\/blob\/master\/webgoat\/src\/main\/java\/org\/owasp\/webgoat\/session\/RandomLessonTracker.java",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "hasCompleted.",
        "class": "RandomLessonTracker class."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.session.RandomLessonTracker.hasCompleted",
      "jar": null,
      "comment": "Counter example for sanitizer (has)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/crypto\/password\/StandardPasswordEncoder.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode the raw password. Generally, a good encoding algorithm applies a SHA-1 or greater hash combined with an 8-byte or greater randomly generated salt.",
        "class": "A standard {@code PasswordEncoder} implementation that uses SHA-256 hashing with 1024 iterations and a random 8-byte random salt value. It uses an additional system-wide secret value to provide additional protection. The digest algorithm is invoked on the concatenated bytes of the salt, secret and password. If you are developing a new system, {@link org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder} is a better choice both in terms of security and interoperability with other languages."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.crypto.password.StandardPasswordEncoder.encode",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.CharSequence",
        "byte[]"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getProtocol() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getProtocol",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Translates a string into {@code application\/x-www-form-urlencoded} format using a specific encoding scheme. This method uses the supplied encoding scheme to obtain the bytes for unsafe characters. Note: The World Wide Web Consortium Recommendation states that UTF-8 should be used. Not doing so may introduce incompatibilities.",
        "class": "Utility class for HTML form encoding. This class contains static methods for converting a String to the application\/x-www-form-urlencoded MIME format. For more information about HTML form encoding, consult the HTML specification. When encoding a String, the following rules apply: The alphanumeric characters \"{@code a}\" through \"{@code z}\", \"{@code A}\" through \"{@code Z}\" and \"{@code 0}\" through \"{@code 9}\" remain the same. The special characters \"{@code .}\", \"{@code -}\", \"{@code *}\", and \"{@code _}\" remain the same. The space character \" \" is converted into a plus sign \"{@code +}\". All other characters are unsafe and are first converted into one or more bytes using some encoding scheme. Then each byte is represented by the 3-character string \"{@code %xy}\", where xy is the two-digit hexadecimal representation of the byte. The recommended encoding scheme to use is UTF-8. However, for compatibility reasons, if an encoding is not specified, then the default encoding of the platform is used. For example using UTF-8 as the encoding scheme the string \"The string Ã¼@foo-bar\" would get converted to \"The+string+%C3%BC%40foo-bar\" because in UTF-8 the character Ã¼ is encoded as two bytes C3 (hex) and BC (hex), and the character @ is encoded as one byte 40 (hex)."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.net.URLEncoder.encode",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to call setContentType(String type) on the wrapped response object.",
        "class": "Provides a convenient implementation of the ServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletResponseWrapper.setContentType",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Turn HTML character references into their plain text UNICODE equivalent. Handles complete character set defined in HTML 4.01 recommendation and all reference types (decimal, hex, and entity). Correctly converts the following formats: &#Entity; - (Example: &amp;) case sensitive &#Decimal; - (Example: &#68;) &#xHex; - (Example: &#xE5;) case insensitive Gracefully handles malformed character references by copying original characters as is when encountered. Reference: http:\/\/www.w3.org\/TR\/html4\/sgml\/entities.html",
        "class": "Utility class for HTML escaping. Escapes and unescapes based on the W3C HTML 4.01 recommendation, handling character entity references. Reference: http:\/\/www.w3.org\/TR\/html4\/charset.html For a comprehensive set of String escaping utilities, consider Apache Commons Lang and its StringEscapeUtils class. We are not using that class here to avoid a runtime dependency on Commons Lang just for HTML escaping. Furthermore, Spring's HTML escaping is more flexible and 100% HTML 4.0 compliant."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.springframework.web.util.HtmlUtils.htmlUnescape",
      "jar": "spring-web-4.3.9.RELEASE.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "http:\/\/people.apache.org\/~ruwan\/axis2\/site\/1.6.0\/api\/org\/apache\/axis2\/description\/AxisService.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Prints generic WSDL error to the given output stream.",
        "class": "Class AxisService"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.axis2.description.AxisService.printWSDLError",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.io.OutputStream"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "",
      "type": [
        "authentication",
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.http.CsrfBeanDefinitionParser.getCsrfLogoutHandler",
      "jar": null,
      "comment": "",
      "parameters": [],
      "return": "org.springframework.beans.factory.config.BeanDefinition",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE862"
      ],
      "javadoc": {
        "method": "Locates the user based on the username. In the actual implementation, the search may possibly be case sensitive, or case insensitive depending on how the implementation instance is configured. In this case, the UserDetails object that comes back may have a username that is of a different case than what was actually requested..",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.authentication.CachingUserDetailsService.loadUserByUsername",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.lang.String"
      ],
      "return": "org.springframework.security.core.userdetails.UserDetails",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getServerName() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getServerName",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the {@code Class} object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by {@code getName}) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter {@code loader} is null, the class is loaded through the bootstrap class loader. The class is initialized only if the {@code initialize} parameter is {@code true} and if it has not been initialized earlier. If {@code name} denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is {@code name}. Therefore, this method cannot be used to obtain any of the {@code Class} objects representing primitive types or void. If {@code name} denotes an array class, the component type of the array class is loaded but not initialized. For example, in an instance method the expression: {@code Class.forName(\"Foo\")} is equivalent to: {@code Class.forName(\"Foo\", true, this.getClass().getClassLoader())} Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller. If the {@code loader} is {@code null}, and a security manager is present, and the caller's class loader is not null, then this method calls the security manager's {@code checkPermission} method with a {@code RuntimePermission(\"getClassLoader\")} permission to ensure it's ok to access the bootstrap class loader.",
        "class": "Instances of the class {@code Class} represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a {@code Class} object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code int}, {@code long}, {@code float}, and {@code double}), and the keyword {@code void} are also represented as {@code Class} objects. {@code Class} has no public constructor. Instead {@code Class} objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the {@code defineClass} method in the class loader. The following example uses a {@code Class} object to print the class name of an object:      void printClassName(Object obj) {\n         System.out.println(\"The class of \" + obj +\n                            \" is \" + obj.getClass().getName());\n     }\n It is also possible to get the {@code Class} object for a named type (or for void) using a class literal. See Section 15.8.2 of The Javaâ„¢ Language Specification. For example: {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.Class.forName",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "boolean",
        "java.lang.ClassLoader"
      ],
      "return": "java.lang.Class",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns an {@link java.io.InputStream InputStream} that can be used to retrieve the contents of the file.",
        "class": "An adapter of Servlet 3.0 {@link Part} to Apache Commons FileUpload's {@link FileItem}"
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.servlet.ServletPartFileItem.getInputStream",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.io.InputStream",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the contents of the file item as an array of bytes.",
        "class": "An adapter of Servlet 3.0 {@link Part} to Apache Commons FileUpload's {@link FileItem}"
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.servlet.ServletPartFileItem.get",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "byte[]",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/access\/method\/MapBasedMethodSecurityMetadataSource.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Return if the given method name matches the mapped name. The default implementation checks for \"xxx\" and \"xxx\" matches.",
        "class": "Stores a list of ConfigAttributes for a method or class signature. This class is the preferred implementation of {@link MethodSecurityMetadataSource} for XML-based definition of method security metadata. To assist in XML-based definition, wildcard support is provided."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.access.method.MapBasedMethodSecurityMetadataSource.isMatch",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/www.novell.com\/documentation\/developer\/jldap\/jldapenu\/api\/com\/novell\/ldap\/LDAPConnection.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306"
      ],
      "javadoc": {
        "method": "Synchronously disconnects from the LDAP server. Before the object can perform LDAP operations again, it must reconnect to the server by calling connect. The disconnect method abandons any outstanding requests, issues an unbind request to the server, and then closes the socket.",
        "class": "The central class that encapsulates the connection to a directory server through the LDAP protocol. LDAPConnection objects are used to perform common LDAP operations such as search, modify and add. In addition, LDAPConnection objects allow you to bind to an LDAP server, set connection and search constraints, and perform several other tasks. An LDAPConnection object is not connected on construction and can only be connected to one server at one port. Multiple threads may share this single connection, typically by cloning the connection object, one for each thread. An application may have more than one LDAPConnection object, connected to the same or different directory servers. Sample Code: Search.java"
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "com.novell.ldap.LDAPConnection.disconnect",
      "jar": null,
      "comment": "Puts the program in a unauthenticated state.",
      "parameters": [
        "com.novell.ldap.LDAPConstraints"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the absolute form of this abstract pathname. Equivalent to new File(this.{@link #getAbsolutePath}).",
        "class": "An abstract representation of file and directory pathnames. User interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames. An abstract pathname has two components: An optional system-dependent prefix string, such as a disk-drive specifier, \"\/\" for the UNIX root directory, or \"\\\\\\\\\" for a Microsoft Windows UNC pathname, and A sequence of zero or more string names. The first name in an abstract pathname may be a directory name or, in the case of Microsoft Windows UNC pathnames, a hostname. Each subsequent name in an abstract pathname denotes a directory; the last name may denote either a directory or a file. The empty abstract pathname has no prefix and an empty name sequence. The conversion of a pathname string to or from an abstract pathname is inherently system-dependent. When an abstract pathname is converted into a pathname string, each name is separated from the next by a single copy of the default separator character. The default name-separator character is defined by the system property file.separator, and is made available in the public static fields {@link #separator} and {@link #separatorChar} of this class. When a pathname string is converted into an abstract pathname, the names within it may be separated by the default name-separator character or by any other name-separator character that is supported by the underlying system. A pathname, whether abstract or in string form, may be either absolute or relative. An absolute pathname is complete in that no other information is required in order to locate the file that it denotes. A relative pathname, in contrast, must be interpreted in terms of information taken from some other pathname. By default the classes in the java.io package always resolve relative pathnames against the current user directory. This directory is named by the system property user.dir, and is typically the directory in which the Java virtual machine was invoked. The parent of an abstract pathname may be obtained by invoking the {@link #getParent} method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any File object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname \"\/usr\" is an ancestor of the directory denoted by the pathname \"\/usr\/local\/bin\". The prefix concept is used to handle root directories on UNIX platforms, and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms, as follows: For UNIX platforms, the prefix of an absolute pathname is always \"\/\". Relative pathnames have no prefix. The abstract pathname denoting the root directory has the prefix \"\/\" and an empty name sequence. For Microsoft Windows platforms, the prefix of a pathname that contains a drive specifier consists of the drive letter followed by \":\" and possibly followed by \"\\\\\" if the pathname is absolute. The prefix of a UNC pathname is \"\\\\\\\\\"; the hostname and the share name are the first two names in the name sequence. A relative pathname that does not specify a drive has no prefix. Instances of this class may or may not denote an actual file-system object such as a file or a directory. If it does denote such an object then that object resides in a partition. A partition is an operating system-specific portion of storage for a file system. A single storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may contain multiple partitions. The object, if any, will reside on the partition named by some ancestor of the absolute form of this pathname. A file system may implement restrictions to certain operations on the actual file-system object, such as reading, writing, and executing. These restrictions are collectively known as access permissions. The file system may have multiple sets of access permissions on a single object. For example, one set may apply to the object's owner, and another may apply to all other users. The access permissions on an object may cause some methods in this class to fail. Instances of the File class are immutable; that is, once created, the abstract pathname represented by a File object will never change. Interoperability with {@code java.nio.file} package The {@code java.nio.file} package defines interfaces and classes for the Java virtual machine to access files, file attributes, and file systems. This API may be used to overcome many of the limitations of the {@code java.io.File} class. The {@link #toPath toPath} method may be used to obtain a {@link Path} that uses the abstract path represented by a {@code File} object to locate a file. The resulting {@code Path} may be used with the {@link java.nio.file.Files} class to provide more efficient and extensive access to additional file operations, file attributes, and I\/O exceptions to help diagnose errors when an operation on a file fails."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "java.io.File.getAbsoluteFile",
      "jar": null,
      "comment": "Source training set",
      "parameters": [],
      "return": "java.io.File",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/commons.apache.org\/proper\/commons-jxpath\/apidocs\/org\/apache\/commons\/jxpath\/ri\/parser\/XPathParser.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.jxpath.ri.parser.XPathParser.unescape",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/jca\/cci\/connection\/SingleConnectionFactory.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Close the given Connection.",
        "class": "A CCI ConnectionFactory adapter that returns the same Connection on all {@code getConnection} calls, and ignores calls to {@code Connection.close()}. Useful for testing and standalone environments, to keep using the same Connection for multiple CciTemplate calls, without having a pooling ConnectionFactory, also spanning any number of transactions. You can either pass in a CCI Connection directly, or let this factory lazily create a Connection via a given target ConnectionFactory."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.jca.cci.connection.SingleConnectionFactory.closeConnection",
      "jar": null,
      "comment": "Puts the state of the program to unauthenticated.",
      "parameters": [
        "javax.resource.cci.Connection"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/BasicScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Returns a basic Authorization header value for the given {@link UsernamePasswordCredentials} and charset.",
        "class": "Basic authentication scheme as defined in RFC 2617."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.BasicScheme.authenticate",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "org.apache.commons.httpclient.UsernamePasswordCredentials",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/web\/portlet\/ModelAndView.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Create a new ModelAndView given a view name and a model.",
        "class": "Holder for both Model and View in the web MVC framework. Note that these are entirely distinct. This class merely holds both to make it possible for a controller to return both model and view in a single return value. Represents a model and view returned by a handler, to be resolved by a DispatcherPortlet. The view can take the form of a String view name which will need to be resolved by a ViewResolver object; alternatively a view object can be specified directly. The model is a Map, allowing the use of multiple objects keyed by name."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.portlet.ModelAndView.<init>",
      "jar": null,
      "comment": "Counter example for sanitizer (String as param, but init)",
      "parameters": [
        "java.lang.String",
        "java.util.Map"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Decode from URL. Implementations should first canonicalize and detect any double-encoding. If this check passes, then the data is decoded using URL decoding.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.decodeFromURL",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/XmlRpcServletServer.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": "An extension of {@link org.apache.xmlrpc.server.XmlRpcServer}, which is suitable for processing servlet requests."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.XmlRpcServletServer.setResponseHeader",
      "jar": null,
      "comment": "Counter example for sanitizer (set)",
      "parameters": [
        "org.apache.xmlrpc.common.ServerStreamConnection",
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          1,
          2
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/help.collab.net\/index.jsp?topic=\/iaf-700\/pebble-soap-javadocs\/net\/sourceforge\/pebble\/domain\/Comment.html",
      "type": [
        "authentication",
        "sink"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": "Represents a blog comment."
      },
      "framework": "pebble",
      "discovery": "manual",
      "name": "net.sourceforge.pebble.domain.Comment.setAuthenticated",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "boolean"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for insertion inside a data value or function argument in JavaScript. Including user data directly inside a script is quite dangerous. Great care must be taken to prevent including user data directly into script code itself, as no amount of encoding will prevent attacks there. Please note there are some JavaScript functions that can never safely receive untrusted data as input \u2013 even if the user input is encoded. For example:",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForJavaScript",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the path on the server to which the browser returns this cookie. The cookie is visible to all subpaths on the server.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.getPath",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/String.html",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Replaces the first substring of this string that matches the given regular expression with the given replacement. An invocation of this method of the form str{@code .replaceFirst(}regex{@code ,} repl{@code )} yields exactly the same result as the expression {@link java.util.regex.Pattern}.{@link java.util.regex.Pattern#compile compile}(regex).{@link java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(str).{@link java.util.regex.Matcher#replaceFirst replaceFirst}(repl) Note that backslashes ({@code \\}) and dollar signs ({@code $}) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see {@link java.util.regex.Matcher#replaceFirst}. Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special meaning of these characters, if desired.",
        "class": "The {@code String} class represents character strings. All string literals in Java programs, such as {@code \"abc\"}, are implemented as instances of this class. Strings are constant; their values cannot be changed after they are created. String buffers support mutable strings. Because String objects are immutable they can be shared. For example:      String str = \"abc\";\n is equivalent to:      char data[] = {'a', 'b', 'c'};\n     String str = new String(data);\n Here are some more examples of how strings can be used:      System.out.println(\"abc\");\n     String cde = \"cde\";\n     System.out.println(\"abc\" + cde);\n     String c = \"abc\".substring(2,3);\n     String d = cde.substring(1, 2);\n The class {@code String} includes methods for examining individual characters of the sequence, for comparing strings, for searching strings, for extracting substrings, and for creating a copy of a string with all characters translated to uppercase or to lowercase. Case mapping is based on the Unicode Standard version specified by the {@link java.lang.Character Character} class. The Java language provides special support for the string concatenation operator ( + ), and for conversion of other objects to strings. String concatenation is implemented through the {@code StringBuilder}(or {@code StringBuffer}) class and its {@code append} method. String conversions are implemented through the method {@code toString}, defined by {@code Object} and inherited by all classes in Java. For additional information on string concatenation and conversion, see Gosling, Joy, and Steele, The Java Language Specification. Unless otherwise noted, passing a null argument to a constructor or method in this class will cause a {@link NullPointerException} to be thrown. A {@code String} represents a string in the UTF-16 format in which supplementary characters are represented by surrogate pairs (see the section Unicode Character Representations in the {@code Character} class for more information). Index values refer to {@code char} code units, so a supplementary character uses two positions in a {@code String}. The {@code String} class provides methods for dealing with Unicode code points (i.e., characters), in addition to those for dealing with Unicode code units (i.e., {@code char} values)."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "java.lang.String.replaceFirst",
      "jar": null,
      "comment": "String manipulation",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/google.github.io\/google-auth-library-java\/releases\/0.6.0\/apidocs\/com\/google\/auth\/oauth2\/UserCredentials.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns client secret of the credential from the console.",
        "class": "OAuth2 Credentials representing a user's identity and consent."
      },
      "framework": "oauth",
      "discovery": "manual",
      "name": "com.google.auth.oauth2.UserCredentials.getClientSecret",
      "jar": null,
      "comment": "Source training set",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/HttpServletResponseImpl.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Encodes the specified URL by including the session ID in it, or, if encoding is not needed, returns the URL unchanged. The implementation of this method includes the logic to determine whether the session ID needs to be encoded in the URL. For example, if the browser supports cookies, or session tracking is turned off, URL encoding is unnecessary. For robust session tracking, all URLs emitted by a servlet should be run through this method. Otherwise, URL rewriting cannot be used with browsers which do not support cookies.",
        "class": "Stub implementation of a {@link javax.servlet.http.HttpServletResponse} with lots of unimplemented methods. I implemented only those, which are required for testing the {@link org.apache.xmlrpc.webserver.XmlRpcServlet}. Perhaps someone else is adding more at a later time?"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.HttpServletResponseImpl.encodeURL",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the text contained in this TextComponent. If the underlying document is null, will give a NullPointerException. Note that text is not a bound property, so no PropertyChangeEvent is fired when it changes. To listen for changes to the text, use DocumentListener.",
        "class": "JTextComponent is the base class for swing text components. It tries to be compatible with the java.awt.TextComponent class where it can reasonably do so. Also provided are other services for additional flexibility (beyond the pluggable UI and bean support). You can find information on how to use the functionality this class provides in General Rules for Using Text Components, a section in The Java Tutorial. Caret Changes The caret is a pluggable object in swing text components. Notification of changes to the caret position and the selection are sent to implementations of the CaretListener interface that have been registered with the text component. The UI will install a default caret unless a customized caret has been set. By default the caret tracks all the document changes performed on the Event Dispatching Thread and updates it's position accordingly if an insertion occurs before or at the caret position or a removal occurs before the caret position. DefaultCaret tries to make itself visible which may lead to scrolling of a text component within JScrollPane. The default caret behavior can be changed by the {@link DefaultCaret#setUpdatePolicy} method. Note: Non-editable text components also have a caret though it may not be painted. Commands Text components provide a number of commands that can be used to manipulate the component. This is essentially the way that the component expresses its capabilities. These are expressed in terms of the swing Action interface, using the TextAction implementation. The set of commands supported by the text component can be found with the {@link #getActions} method. These actions can be bound to key events, fired from buttons, etc. Text Input The text components support flexible and internationalized text input, using keymaps and the input method framework, while maintaining compatibility with the AWT listener model. A {@link javax.swing.text.Keymap} lets an application bind key strokes to actions. In order to allow keymaps to be shared across multiple text components, they can use actions that extend TextAction. TextAction can determine which JTextComponent most recently has or had focus and therefore is the subject of the action (In the case that the ActionEvent sent to the action doesn't contain the target text component as its source). The input method framework lets text components interact with input methods, separate software components that preprocess events to let users enter thousands of different characters using keyboards with far fewer keys. JTextComponent is an active client of the framework, so it implements the preferred user interface for interacting with input methods. As a consequence, some key events do not reach the text component because they are handled by an input method, and some text input reaches the text component as committed text within an {@link java.awt.event.InputMethodEvent} instead of as a key event. The complete text input is the combination of the characters in keyTyped key events and committed text in input method events. The AWT listener model lets applications attach event listeners to components in order to bind events to actions. Swing encourages the use of keymaps instead of listeners, but maintains compatibility with listeners by giving the listeners a chance to steal an event by consuming it. Keyboard event and input method events are handled in the following stages, with each stage capable of consuming the event: Stage KeyEvent InputMethodEvent 1. input methods (generated here) 2. focus manager 3. registered key listeners registered input method listeners 4. input method handling in JTextComponent 5. keymap handling using the current keymap 6. keyboard handling in JComponent (e.g. accelerators, component navigation, etc.) To maintain compatibility with applications that listen to key events but are not aware of input method events, the input method handling in stage 4 provides a compatibility mode for components that do not process input method events. For these components, the committed text is converted to keyTyped key events and processed in the key event pipeline starting at stage 3 instead of in the input method event pipeline. By default the component will create a keymap (named DEFAULT_KEYMAP) that is shared by all JTextComponent instances as the default keymap. Typically a look-and-feel implementation will install a different keymap that resolves to the default keymap for those bindings not found in the different keymap. The minimal bindings include: inserting content into the editor for the printable keys. removing content with the backspace and del keys. caret movement forward and backward Model\/View Split The text components have a model-view split. A text component pulls together the objects used to represent the model, view, and controller. The text document model may be shared by other views which act as observers of the model (e.g. a document may be shared by multiple components). The model is defined by the {@link Document} interface. This is intended to provide a flexible text storage mechanism that tracks change during edits and can be extended to more sophisticated models. The model interfaces are meant to capture the capabilities of expression given by SGML, a system used to express a wide variety of content. Each modification to the document causes notification of the details of the change to be sent to all observers in the form of a {@link DocumentEvent} which allows the views to stay up to date with the model. This event is sent to observers that have implemented the {@link DocumentListener} interface and registered interest with the model being observed. Location Information The capability of determining the location of text in the view is provided. There are two methods, {@link #modelToView} and {@link #viewToModel} for determining this information. Undo\/Redo support Support for an edit history mechanism is provided to allow undo\/redo operations. The text component does not itself provide the history buffer by default, but does provide the UndoableEdit records that can be used in conjunction with a history buffer to provide the undo\/redo support. The support is provided by the Document model, which allows one to attach UndoableEditListener implementations. Thread Safety The swing text components provide some support of thread safe operations. Because of the high level of configurability of the text components, it is possible to circumvent the protection provided. The protection primarily comes from the model, so the documentation of AbstractDocument describes the assumptions of the protection provided. The methods that are safe to call asynchronously are marked with comments. Newlines For a discussion on how newlines are handled, see DefaultEditorKit. Printing support Several {@link #print print} methods are provided for basic document printing. If more advanced printing is needed, use the {@link #getPrintable} method. Warning: Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing. As of 1.4, support for long term storage of all JavaBeansâ„¢ has been added to the java.beans package. Please see {@link java.beans.XMLEncoder}."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "javax.swing.text.JTextComponent.getText",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/ServletWebServer.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.ServletWebServer.access$000",
      "jar": null,
      "comment": "Counter example for sanitizer (implicit method)",
      "parameters": [
        "org.apache.xmlrpc.webserver.ServletWebServer"
      ],
      "return": "javax.servlet.http.HttpServlet",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink",
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Finds a resource with a given name. The rules for searching resources associated with a given class are implemented by the defining {@linkplain ClassLoader class loader} of the class. This method delegates to this object's class loader. If this object was loaded by the bootstrap class loader, the method delegates to {@link ClassLoader#getSystemResource}. Before delegation, an absolute resource name is constructed from the given resource name using this algorithm: If the {@code name} begins with a {@code '\/'} ('\\u002f'), then the absolute name of the resource is the portion of the {@code name} following the {@code '\/'}. Otherwise, the absolute name is of the following form: {@code modified_package_name\/name} Where the {@code modified_package_name} is the package name of this object with {@code '\/'} substituted for {@code '.'} ('\\u002e').",
        "class": "Instances of the class {@code Class} represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a {@code Class} object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code int}, {@code long}, {@code float}, and {@code double}), and the keyword {@code void} are also represented as {@code Class} objects. {@code Class} has no public constructor. Instead {@code Class} objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the {@code defineClass} method in the class loader. The following example uses a {@code Class} object to print the class name of an object:      void printClassName(Object obj) {\n         System.out.println(\"The class of \" + obj +\n                            \" is \" + obj.getClass().getName());\n     }\n It is also possible to get the {@code Class} object for a named type (or for void) using a class literal. See Section 15.8.2 of The Javaâ„¢ Language Specification. For example: {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.Class.getResource",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.net.URL",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/web\/socket\/server\/support\/WebSocketHttpRequestHandler.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Process the given request, generating a response.",
        "class": "A {@link HttpRequestHandler} for processing WebSocket handshake requests. This is the main class to use when configuring a server WebSocket at a specific URL. It is a very thin wrapper around a {@link WebSocketHandler} and a {@link HandshakeHandler}, also adapting the {@link HttpServletRequest} and {@link HttpServletResponse} to {@link ServerHttpRequest} and {@link ServerHttpResponse}, respectively."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.server.support.WebSocketHttpRequestHandler.handleRequest",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "javax.servlet.http.HttpServletRequest",
        "javax.servlet.http.HttpServletResponse"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/server\/ReflectiveXmlRpcHandler.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078",
        "CWE079"
      ],
      "javadoc": {
        "method": "Performs the request and returns the result object.",
        "class": "Default implementation of {@link XmlRpcHandler}."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.server.ReflectiveXmlRpcHandler.execute",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.apache.xmlrpc.XmlRpcRequest"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/mock\/web\/MockJspWriter.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Print a boolean value. The string produced by {@link java.lang.String#valueOf(boolean)} is written to the JspWriter's buffer or, if no buffer is used, directly to the underlying writer.",
        "class": "Mock implementation of the {@link javax.servlet.jsp.JspWriter} class. Used for testing the web framework; only necessary for testing applications when testing custom JSP tags."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.mock.web.MockJspWriter.print",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [
        "boolean"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/sonatype\/WebGoat\/blob\/master\/src\/main\/java\/org\/owasp\/webgoat\/controller\/Logout.java",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "logout.",
        "class": "Logout class."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.controller.Logout.logout",
      "jar": null,
      "comment": "Puts the program in an un-authenticated state.",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "org.springframework.web.servlet.ModelAndView",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode for an operating system command shell according to the selected codec (appropriate codecs include the WindowsCodec and UnixCodec). Please note the following recommendations before choosing to use this method: 1) It is strongly recommended that applications avoid making direct OS system calls if possible as such calls are not portable, and they are potentially unsafe. Please use language provided features if at all possible, rather than native OS calls to implement the desired feature. 2) If an OS call cannot be avoided, then it is recommended that the program to be invoked be invoked directly (e.g., System.exec(\"nameofcommand\" + \"parameterstocommand\");) as this avoids the use of the command shell. The \"parameterstocommand\" should of course be validated before passing them to the OS command. 3) If you must use this method, then we recommend validating all user supplied input passed to the command shell as well, in addition to using this method in order to make the command shell invocation safe. An example use of this method would be: System.exec(\"dir \" + ESAPI.encodeForOS(WindowsCodec, \"parameter(s)tocommandwithuserinput\");",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForOS",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "org.owasp.esapi.codecs.Codec",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/docs.spring.io\/autorepo\/docs\/spring-security\/4.0.0.M1\/apidocs\/index.html?org\/springframework\/security\/config\/annotation\/authentication\/builders\/AuthenticationManagerBuilder.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder.inMemoryAuthentication",
      "jar": null,
      "comment": "the method returns a configurator for manipulation of users' details. The return object is authenticated and the owner may execute critical ops.",
      "parameters": [],
      "return": "org.springframework.security.config.'annotation'.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Constructs a new Scanner that produces values scanned from the specified channel. Bytes from the source are converted into characters using the underlying platform's {@linkplain java.nio.charset.Charset#defaultCharset() default charset}.",
        "class": "A simple text scanner which can parse primitive types and strings using regular expressions. A Scanner breaks its input into tokens using a delimiter pattern, which by default matches whitespace. The resulting tokens may then be converted into values of different types using the various next methods. For example, this code allows a user to read a number from System.in: {@code\n     Scanner sc = new Scanner(System.in);\n     int i = sc.nextInt();\n } As another example, this code allows long types to be assigned from entries in a file myNumbers: {@code\n      Scanner sc = new Scanner(new File(\"myNumbers\"));\n      while (sc.hasNextLong()) {\n          long aLong = sc.nextLong();\n      }\n } The scanner can also use delimiters other than whitespace. This example reads several items in from a string: {@code\n     String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");\n     System.out.println(s.nextInt());\n     System.out.println(s.nextInt());\n     System.out.println(s.next());\n     System.out.println(s.next());\n     s.close();\n } prints the following output: {@code\n     1\n     2\n     red\n     blue\n } The same output can be generated with this code, which uses a regular expression to parse all four tokens at once: {@code\n     String input = \"1 fish 2 fish red fish blue fish\";\n     Scanner s = new Scanner(input);\n     s.findInLine(\"(\\\\d+) fish (\\\\d+) fish (\\\\w+) fish (\\\\w+)\");\n     MatchResult result = s.match();\n     for (int i=1; i<=result.groupCount(); i++)\n         System.out.println(result.group(i));\n     s.close();\n } The default whitespace delimiter used by a scanner is as recognized by {@link java.lang.Character}.{@link java.lang.Character#isWhitespace(char) isWhitespace}. The {@link #reset} method will reset the value of the scanner's delimiter to the default whitespace delimiter regardless of whether it was previously changed. A scanning operation may block waiting for input. The {@link #next} and {@link #hasNext} methods and their primitive-type companion methods (such as {@link #nextInt} and {@link #hasNextInt}) first skip any input that matches the delimiter pattern, and then attempt to return the next token. Both hasNext and next methods may block waiting for further input. Whether a hasNext method blocks has no connection to whether or not its associated next method will block. The {@link #findInLine}, {@link #findWithinHorizon}, and {@link #skip} methods operate independently of the delimiter pattern. These methods will attempt to match the specified pattern with no regard to delimiters in the input and thus can be used in special circumstances where delimiters are not relevant. These methods may block waiting for more input. When a scanner throws an {@link InputMismatchException}, the scanner will not pass the token that caused the exception, so that it may be retrieved or skipped via some other method. Depending upon the type of delimiting pattern, empty tokens may be returned. For example, the pattern \"\\\\s+\" will return no empty tokens since it matches multiple instances of the delimiter. The delimiting pattern \"\\\\s\" could return empty tokens since it only passes one space at a time. A scanner can read text from any object which implements the {@link java.lang.Readable} interface. If an invocation of the underlying readable's {@link java.lang.Readable#read} method throws an {@link java.io.IOException} then the scanner assumes that the end of the input has been reached. The most recent IOException thrown by the underlying readable can be retrieved via the {@link #ioException} method. When a Scanner is closed, it will close its input source if the source implements the {@link java.io.Closeable} interface. A Scanner is not safe for multithreaded use without external synchronization. Unless otherwise mentioned, passing a null parameter into any method of a Scanner will cause a NullPointerException to be thrown. A scanner will default to interpreting numbers as decimal unless a different radix has been set by using the {@link #useRadix} method. The {@link #reset} method will reset the value of the scanner's radix to 10 regardless of whether it was previously changed. Localized numbers An instance of this class is capable of scanning numbers in the standard formats as well as in the formats of the scanner's locale. A scanner's initial locale is the value returned by the {@link java.util.Locale#getDefault(Locale.Category) Locale.getDefault(Locale.Category.FORMAT)} method; it may be changed via the {@link #useLocale} method. The {@link #reset} method will reset the value of the scanner's locale to the initial locale regardless of whether it was previously changed. The localized formats are defined in terms of the following parameters, which for a particular locale are taken from that locale's {@link java.text.DecimalFormat DecimalFormat} object, df, and its and {@link java.text.DecimalFormatSymbols DecimalFormatSymbols} object, dfs. LocalGroupSeparator The character used to separate thousands groups, i.e., dfs.{@link java.text.DecimalFormatSymbols#getGroupingSeparator getGroupingSeparator()} LocalDecimalSeparator The character used for the decimal point, i.e., dfs.{@link java.text.DecimalFormatSymbols#getDecimalSeparator getDecimalSeparator()} LocalPositivePrefix The string that appears before a positive number (may be empty), i.e., df.{@link java.text.DecimalFormat#getPositivePrefix getPositivePrefix()} LocalPositiveSuffix The string that appears after a positive number (may be empty), i.e., df.{@link java.text.DecimalFormat#getPositiveSuffix getPositiveSuffix()} LocalNegativePrefix The string that appears before a negative number (may be empty), i.e., df.{@link java.text.DecimalFormat#getNegativePrefix getNegativePrefix()} LocalNegativeSuffix The string that appears after a negative number (may be empty), i.e., df.{@link java.text.DecimalFormat#getNegativeSuffix getNegativeSuffix()} LocalNaN The string that represents not-a-number for floating-point values, i.e., dfs.{@link java.text.DecimalFormatSymbols#getNaN getNaN()} LocalInfinity The string that represents infinity for floating-point values, i.e., dfs.{@link java.text.DecimalFormatSymbols#getInfinity getInfinity()} Number syntax The strings that can be parsed as numbers by an instance of this class are specified in terms of the following regular-expression grammar, where Rmax is the highest digit in the radix being used (for example, Rmax is 9 in base 10). NonAsciiDigit: A non-ASCII character c for which {@link java.lang.Character#isDigit Character.isDigit}(c) returns true Non0Digit: [1-Rmax] | NonASCIIDigit Digit: [0-Rmax] | NonASCIIDigit GroupedNumeral: ( Non0Digit Digit? Digit? ( LocalGroupSeparator Digit Digit Digit )+ ) Numeral: ( ( Digit+ ) | GroupedNumeral ) Integer: ( [-+]? ( Numeral ) ) | LocalPositivePrefix Numeral LocalPositiveSuffix | LocalNegativePrefix Numeral LocalNegativeSuffix DecimalNumeral: Numeral | Numeral LocalDecimalSeparator Digit* | LocalDecimalSeparator Digit+ Exponent: ( [eE] [+-]? Digit+ ) Decimal: ( [-+]? DecimalNumeral Exponent? ) | LocalPositivePrefix DecimalNumeral LocalPositiveSuffix Exponent? | LocalNegativePrefix DecimalNumeral LocalNegativeSuffix Exponent? HexFloat: [-+]? 0[xX][0-9a-fA-F]*\\.[0-9a-fA-F]+ ([pP][-+]?[0-9]+)? NonNumber: NaN | LocalNan | Infinity | LocalInfinity SignedNonNumber: ( [-+]? NonNumber ) | LocalPositivePrefix NonNumber LocalPositiveSuffix | LocalNegativePrefix NonNumber LocalNegativeSuffix Float: Decimal | HexFloat | SignedNonNumber Whitespace is not significant in the above regular expressions."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.util.Scanner.<init>",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.nio.channels.ReadableByteChannel"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/4.0.0.M1_to_4.2.0.M2\/Spring%20Framework%204.0.0.M1\/org\/springframework\/test\/context\/transaction\/TransactionalTestExecutionListener.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078"
      ],
      "javadoc": {
        "method": "Run all {@link AfterTransaction @AfterTransaction} methods for the specified {@linkplain TestContext test context}. If one of the methods fails, the caught exception will be logged as an error, and the remaining methods will be given a chance to execute. After all methods have executed, the first caught exception, if any, will be rethrown.",
        "class": "{@code TestExecutionListener} that provides support for executing tests within test-managed transactions by honoring Spring's {@link org.springframework.transaction.annotation.Transactional @Transactional} annotation. Test-managed Transactions Test-managed transactions are transactions that are managed declaratively via this listener or programmatically via {@link TestTransaction}. Such transactions should not be confused with Spring-managed transactions (i.e., those managed directly by Spring within the {@code ApplicationContext} loaded for tests) or application-managed transactions (i.e., those managed programmatically within application code that is invoked via tests). Spring-managed and application-managed transactions will typically participate in test-managed transactions; however, caution should be taken if Spring-managed or application-managed transactions are configured with any propagation type other than {@link org.springframework.transaction.annotation.Propagation#REQUIRED REQUIRED} or {@link org.springframework.transaction.annotation.Propagation#SUPPORTS SUPPORTS}. Enabling and Disabling Transactions Annotating a test method with {@code @Transactional} causes the test to be run within a transaction that will, by default, be automatically rolled back after completion of the test. If a test class is annotated with {@code @Transactional}, each test method within that class hierarchy will be run within a transaction. Test methods that are not annotated with {@code @Transactional} (at the class or method level) will not be run within a transaction. Furthermore, tests that are annotated with {@code @Transactional} but have the {@link org.springframework.transaction.annotation.Transactional#propagation propagation} type set to {@link org.springframework.transaction.annotation.Propagation#NOT_SUPPORTED NOT_SUPPORTED} will not be run within a transaction. Declarative Rollback and Commit Behavior By default, test transactions will be automatically rolled back after completion of the test; however, transactional commit and rollback behavior can be configured declaratively via the {@link Commit @Commit} and {@link Rollback @Rollback} annotations at the class level and at the method level. Programmatic Transaction Management As of Spring Framework 4.1, it is possible to interact with test-managed transactions programmatically via the static methods in {@link TestTransaction}. {@code TestTransaction} may be used within test methods, before methods, and after methods. Executing Code outside of a Transaction When executing transactional tests, it is sometimes useful to be able to execute certain set up or tear down code outside of a transaction. {@code TransactionalTestExecutionListener} provides such support for methods annotated with {@link BeforeTransaction @BeforeTransaction} or {@link AfterTransaction @AfterTransaction}. As of Spring Framework 4.3, {@code @BeforeTransaction} and {@code @AfterTransaction} may also be declared on Java 8 based interface default methods. Configuring a Transaction Manager {@code TransactionalTestExecutionListener} expects a {@link PlatformTransactionManager} bean to be defined in the Spring {@code ApplicationContext} for the test. In case there are multiple instances of {@code PlatformTransactionManager} within the test's {@code ApplicationContext}, a qualifier may be declared via {@link org.springframework.transaction.annotation.Transactional @Transactional} (e.g., {@code @Transactional(\"myTxMgr\")} or {@code @Transactional(transactionManger = \"myTxMgr\")}, or {@link org.springframework.transaction.annotation.TransactionManagementConfigurer TransactionManagementConfigurer} can be implemented by an {@link org.springframework.context.annotation.Configuration @Configuration} class. See {@link TestContextTransactionUtils#retrieveTransactionManager} for details on the algorithm used to look up a transaction manager in the test's {@code ApplicationContext}."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.test.context.transaction.TransactionalTestExecutionListener.runAfterTransactionMethods",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.springframework.test.context.TestContext"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Specifies a comment that describes a cookie's purpose. The comment is useful if the browser presents the cookie to the user. Comments are not supported by Netscape Version 0 cookies.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.setComment",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/web\/context\/request\/RequestContextListener.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "Servlet 2.4+ listener that exposes the request to the current thread, through both {@link org.springframework.context.i18n.LocaleContextHolder} and {@link RequestContextHolder}. To be registered as listener in web.xml. Alternatively, Spring's {@link org.springframework.web.filter.RequestContextFilter} and Spring's {@link org.springframework.web.servlet.DispatcherServlet} also expose the same request context to the current thread. In contrast to this listener, advanced options are available there (e.g. \"threadContextInheritable\"). This listener is mainly for use with third-party servlets, e.g. the JSF FacesServlet. Within Spring's own web support, DispatcherServlet's processing is perfectly sufficient."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.context.request.RequestContextListener.requestInitialized",
      "jar": null,
      "comment": "Counter example for source",
      "parameters": [
        "javax.servlet.ServletRequestEvent"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Unescapes a string containing XML entity escapes to a string containing the actual Unicode characters corresponding to the escapes. Supports only the five basic XML entities (gt, lt, quot, amp, apos). Does not support DTDs or external entities. Note that numerical \\\\u Unicode codes are unescaped to their respective Unicode characters. This may change in future releases.",
        "class": "Escapes and unescapes {@code String}s for Java, Java Script, HTML and XML. #ThreadSafe#"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.apache.commons.lang3.StringEscapeUtils.unescapeXml",
      "jar": "commons-lang3-3.10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/sonatype\/WebGoat\/blob\/master\/src\/main\/java\/org\/owasp\/webgoat\/session\/ParameterParser.java",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Description of the Method",
        "class": "************************************************************************************************* This file is part of WebGoat, an Open Web Application Security Project utility. For details, please see http:\/\/www.owasp.org\/ Copyright (c) 2002 - 20014 Bruce Mayhew This program is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. Getting Source ============== Source for this application is maintained at https:\/\/github.com\/WebGoat\/WebGoat, a repository for free software projects."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.session.ParameterParser.update",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "javax.servlet.ServletRequest"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/annotation\/web\/configurers\/UrlAuthorizationConfigurer.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Creates a String for specifying that a user requires one of many roles.",
        "class": "Adds URL based authorization using {@link DefaultFilterInvocationSecurityMetadataSource}. At least one {@link org.springframework.web.bind.annotation.RequestMapping} needs to be mapped to {@link ConfigAttribute}'s for this {@link SecurityContextConfigurer} to have meaning. Security Filters Usage includes applying the {@link UrlAuthorizationConfigurer} and then modifying the StandardInterceptUrlRegistry. For example:  protected void configure(HttpSecurity http) throws Exception {\n \thttp.apply(new UrlAuthorizationConfigurer()).getRegistry()\n \t\t\t.antMatchers(\"\/users**\", \"\/sessions\/**\").hasRole(\"USER\")\n \t\t\t.antMatchers(\"\/signup\").hasRole(\"ANONYMOUS\").anyRequest().hasRole(\"USER\");\n }\n The following Filters are populated {@link org.springframework.security.web.access.intercept.FilterSecurityInterceptor} Shared Objects Created The following shared objects are populated to allow other {@link org.springframework.security.config.annotation.SecurityConfigurer}'s to customize: {@link org.springframework.security.web.access.intercept.FilterSecurityInterceptor} Shared Objects Used The following shared objects are used: AuthenticationManager"
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.web.configurers.UrlAuthorizationConfigurer.hasAnyRole",
      "jar": null,
      "comment": "Counter example for sanitizer (has)",
      "parameters": [
        "java.lang.String[]"
      ],
      "return": "java.lang.String[]",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/commons.apache.org\/proper\/commons-lang\/javadocs\/api-3.1\/org\/apache\/commons\/lang3\/text\/StrSubstitutor.html",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Replaces all the occurrences of variables with their matching values from the resolver using the given source as a template. The source is not altered by this method.",
        "class": "Substitutes variables within a string by values. This class takes a piece of text and substitutes all the variables within it. The default definition of a variable is {@code ${variableName}}. The prefix and suffix can be changed via constructors and set methods. Variable values are typically resolved from a map, but could also be resolved from system properties, or by supplying a custom variable resolver. The simplest example is to use this class to replace Java System properties. For example:  StrSubstitutor.replaceSystemProperties(\n      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n Typical usage of this class follows the following pattern: First an instance is created and initialized with the map that contains the values for the available variables. If a prefix and\/or suffix for variables should be used other than the default ones, the appropriate settings can be performed. After that the {@code replace()} method can be called passing in the source text for interpolation. In the returned text all variable references (as long as their values are known) will be resolved. The following example demonstrates this:  Map valuesMap = HashMap();\n valuesMap.put(\"animal\", \"quick brown fox\");\n valuesMap.put(\"target\", \"lazy dog\");\n String templateString = \"The ${animal} jumps over the ${target}.\";\n StrSubstitutor sub = new StrSubstitutor(valuesMap);\n String resolvedString = sub.replace(templateString);\n yielding:       The quick brown fox jumps over the lazy dog.\n Also, this class allows to set a default value for unresolved variables. The default value for a variable can be appended to the variable name after the variable default value delimiter. The default value of the variable default value delimiter is ':-', as in bash and other *nix shells, as those are arguably where the default ${} delimiter set originated. The variable default value delimiter can be manually set by calling {@link #setValueDelimiterMatcher(StrMatcher)}, {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}. The following shows an example with variable default value settings:  Map valuesMap = HashMap();\n valuesMap.put(\"animal\", \"quick brown fox\");\n valuesMap.put(\"target\", \"lazy dog\");\n String templateString = \"The ${animal} jumps over the ${target}. ${undefined.number:-1234567890}.\";\n StrSubstitutor sub = new StrSubstitutor(valuesMap);\n String resolvedString = sub.replace(templateString);\n yielding:       The quick brown fox jumps over the lazy dog. 1234567890.\n In addition to this usage pattern there are some static convenience methods that cover the most common use cases. These methods can be used without the need of manually creating an instance. However if multiple replace operations are to be performed, creating and reusing an instance of this class will be more efficient. Variable replacement works in a recursive way. Thus, if a variable value contains a variable then that variable will also be replaced. Cyclic replacements are detected and will cause an exception to be thrown. Sometimes the interpolation's result must contain a variable prefix. As an example take the following source text:    The variable ${${name}} must be used.\n Here only the variable's name referred to in the text should be replaced resulting in the text (assuming that the value of the {@code name} variable is {@code x}):    The variable ${x} must be used.\n To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do not conflict with the result text you want to produce. The other possibility is to use the escape character, by default '$'. If this character is placed before a variable reference, this reference is ignored and won't be replaced. For example:    The variable $${${name}} must be used.\n In some complex scenarios you might even want to perform substitution in the names of variables, for instance  ${jre-${java.specification.version}}\n {@code StrSubstitutor} supports this recursive substitution in variable names, but it has to be enabled explicitly by setting the {@link #setEnableSubstitutionInVariables(boolean) enableSubstitutionInVariables} property to true. This class is not thread safe."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.lang3.text.StrSubstitutor.replace",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.CharSequence"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/HttpAuthenticator.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Attempt to provide default proxy authentication credentials to the given method in the given context using basic authentication scheme.",
        "class": "Utility methods for HTTP authorization and authentication. This class provides utility methods for generating responses to HTTP www and proxy authentication challenges. A client SHOULD assume that all paths at or deeper than the depth of the last symbolic element in the path field of the Request-URI also are within the protection space specified by the basic realm value of the current challenge. A client MAY preemptively send the corresponding Authorization header with requests for resources in that space without receipt of another challenge from the server. Similarly, when a client sends a request to a proxy, it may reuse a userid and password in the Proxy-Authorization header field without receiving another challenge from the proxy server."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.HttpAuthenticator.authenticateProxyDefault",
      "jar": null,
      "comment": "Depricated method. The credentials are provided in the HttpState. The authentication is added to the header of the HttpMethod.",
      "parameters": [
        "org.apache.commons.httpclient.HttpMethod",
        "org.apache.commons.httpclient.HttpConnection",
        "org.apache.commons.httpclient.HttpState"
      ],
      "return": "boolean",
      "dataIn": {
        "parameters": [
          2,
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "",
      "type": [
        "authentication"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "",
        "class": "A WebSocket connection manager that is given a URI, an {@link Endpoint}, connects to a WebSocket server through the {@link #start()} and {@link #stop()} methods. If {@link #setAutoStartup(boolean)} is set to {@code true} this will be done automatically when the Spring ApplicationContext is refreshed."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.client.standard.EndpointConnectionManager.isConnected",
      "jar": null,
      "comment": "Returnes whether the program is connected.",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/io\/File.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the canonical form of this abstract pathname. Equivalent to new File(this.{@link #getCanonicalPath}).",
        "class": "An abstract representation of file and directory pathnames. User interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames. An abstract pathname has two components: An optional system-dependent prefix string, such as a disk-drive specifier, \"\/\" for the UNIX root directory, or \"\\\\\\\\\" for a Microsoft Windows UNC pathname, and A sequence of zero or more string names. The first name in an abstract pathname may be a directory name or, in the case of Microsoft Windows UNC pathnames, a hostname. Each subsequent name in an abstract pathname denotes a directory; the last name may denote either a directory or a file. The empty abstract pathname has no prefix and an empty name sequence. The conversion of a pathname string to or from an abstract pathname is inherently system-dependent. When an abstract pathname is converted into a pathname string, each name is separated from the next by a single copy of the default separator character. The default name-separator character is defined by the system property file.separator, and is made available in the public static fields {@link #separator} and {@link #separatorChar} of this class. When a pathname string is converted into an abstract pathname, the names within it may be separated by the default name-separator character or by any other name-separator character that is supported by the underlying system. A pathname, whether abstract or in string form, may be either absolute or relative. An absolute pathname is complete in that no other information is required in order to locate the file that it denotes. A relative pathname, in contrast, must be interpreted in terms of information taken from some other pathname. By default the classes in the java.io package always resolve relative pathnames against the current user directory. This directory is named by the system property user.dir, and is typically the directory in which the Java virtual machine was invoked. The parent of an abstract pathname may be obtained by invoking the {@link #getParent} method of this class and consists of the pathname's prefix and each name in the pathname's name sequence except for the last. Each directory's absolute pathname is an ancestor of any File object with an absolute abstract pathname which begins with the directory's absolute pathname. For example, the directory denoted by the abstract pathname \"\/usr\" is an ancestor of the directory denoted by the pathname \"\/usr\/local\/bin\". The prefix concept is used to handle root directories on UNIX platforms, and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms, as follows: For UNIX platforms, the prefix of an absolute pathname is always \"\/\". Relative pathnames have no prefix. The abstract pathname denoting the root directory has the prefix \"\/\" and an empty name sequence. For Microsoft Windows platforms, the prefix of a pathname that contains a drive specifier consists of the drive letter followed by \":\" and possibly followed by \"\\\\\" if the pathname is absolute. The prefix of a UNC pathname is \"\\\\\\\\\"; the hostname and the share name are the first two names in the name sequence. A relative pathname that does not specify a drive has no prefix. Instances of this class may or may not denote an actual file-system object such as a file or a directory. If it does denote such an object then that object resides in a partition. A partition is an operating system-specific portion of storage for a file system. A single storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may contain multiple partitions. The object, if any, will reside on the partition named by some ancestor of the absolute form of this pathname. A file system may implement restrictions to certain operations on the actual file-system object, such as reading, writing, and executing. These restrictions are collectively known as access permissions. The file system may have multiple sets of access permissions on a single object. For example, one set may apply to the object's owner, and another may apply to all other users. The access permissions on an object may cause some methods in this class to fail. Instances of the File class are immutable; that is, once created, the abstract pathname represented by a File object will never change. Interoperability with {@code java.nio.file} package The {@code java.nio.file} package defines interfaces and classes for the Java virtual machine to access files, file attributes, and file systems. This API may be used to overcome many of the limitations of the {@code java.io.File} class. The {@link #toPath toPath} method may be used to obtain a {@link Path} that uses the abstract path represented by a {@code File} object to locate a file. The resulting {@code Path} may be used with the {@link java.nio.file.Files} class to provide more efficient and extensive access to additional file operations, file attributes, and I\/O exceptions to help diagnose errors when an operation on a file fails."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "java.io.File.getCanonicalFile",
      "jar": null,
      "comment": "Source training set",
      "parameters": [],
      "return": "java.io.File",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Removes the system property indicated by the specified key. First, if a security manager exists, its SecurityManager.checkPermission method is called with a PropertyPermission(key, \"write\") permission. This may result in a SecurityException being thrown. If no exception is thrown, the specified property is removed.",
        "class": "The System class contains several useful class fields and methods. It cannot be instantiated. Among the facilities provided by the System class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.lang.System.clearProperty",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to set the character encoding on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.setCharacterEncoding",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/javax\/security\/auth\/login\/LoginContext.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Perform the authentication. This method invokes the {@code login} method for each LoginModule configured for the name specified to the {@code LoginContext} constructor, as determined by the login {@code Configuration}. Each {@code LoginModule} then performs its respective type of authentication (username\/password, smart card pin verification, etc.). This method completes a 2-phase authentication process by calling each configured LoginModule's {@code commit} method if the overall authentication succeeded (the relevant REQUIRED, REQUISITE, SUFFICIENT, and OPTIONAL LoginModules succeeded), or by calling each configured LoginModule's {@code abort} method if the overall authentication failed. If authentication succeeded, each successful LoginModule's {@code commit} method associates the relevant Principals and Credentials with the {@code Subject}. If authentication failed, each LoginModule's {@code abort} method removes\/destroys any previously stored state. If the {@code commit} phase of the authentication process fails, then the overall authentication fails and this method invokes the {@code abort} method for each configured {@code LoginModule}. If the {@code abort} phase fails for any reason, then this method propagates the original exception thrown either during the {@code login} phase or the {@code commit} phase. In either case, the overall authentication fails. In the case where multiple LoginModules fail, this method propagates the exception raised by the first {@code LoginModule} which failed. Note that if this method enters the {@code abort} phase (either the {@code login} or {@code commit} phase failed), this method invokes all LoginModules configured for the application regardless of their respective {@code Configuration} flag parameters. Essentially this means that {@code Requisite} and {@code Sufficient} semantics are ignored during the {@code abort} phase. This guarantees that proper cleanup and state restoration can take place.",
        "class": "The {@code LoginContext} class describes the basic methods used to authenticate Subjects and provides a way to develop an application independent of the underlying authentication technology. A {@code Configuration} specifies the authentication technology, or {@code LoginModule}, to be used with a particular application. Different LoginModules can be plugged in under an application without requiring any modifications to the application itself. In addition to supporting pluggable authentication, this class also supports the notion of stacked authentication. Applications may be configured to use more than one LoginModule. For example, one could configure both a Kerberos LoginModule and a smart card LoginModule under an application. A typical caller instantiates a LoginContext with a name and a {@code CallbackHandler}. LoginContext uses the name as the index into a Configuration to determine which LoginModules should be used, and which ones must succeed in order for the overall authentication to succeed. The {@code CallbackHandler} is passed to the underlying LoginModules so they may communicate and interact with users (prompting for a username and password via a graphical user interface, for example). Once the caller has instantiated a LoginContext, it invokes the {@code login} method to authenticate a {@code Subject}. The {@code login} method invokes the configured modules to perform their respective types of authentication (username\/password, smart card pin verification, etc.). Note that the LoginModules will not attempt authentication retries nor introduce delays if the authentication fails. Such tasks belong to the LoginContext caller. If the {@code login} method returns without throwing an exception, then the overall authentication succeeded. The caller can then retrieve the newly authenticated Subject by invoking the {@code getSubject} method. Principals and Credentials associated with the Subject may be retrieved by invoking the Subject's respective {@code getPrincipals}, {@code getPublicCredentials}, and {@code getPrivateCredentials} methods. To logout the Subject, the caller calls the {@code logout} method. As with the {@code login} method, this {@code logout} method invokes the {@code logout} method for the configured modules. A LoginContext should not be used to authenticate more than one Subject. A separate LoginContext should be used to authenticate each different Subject. The following documentation applies to all LoginContext constructors: {@code Subject} If the constructor has a Subject input parameter, the LoginContext uses the caller-specified Subject object. If the caller specifies a {@code null} Subject and a {@code null} value is permitted, the LoginContext instantiates a new Subject. If the constructor does not have a Subject input parameter, the LoginContext instantiates a new Subject. {@code Configuration} If the constructor has a Configuration input parameter and the caller specifies a non-null Configuration, the LoginContext uses the caller-specified Configuration. If the constructor does not have a Configuration input parameter, or if the caller specifies a {@code null} Configuration object, the constructor uses the following call to get the installed Configuration:       config = Configuration.getConfiguration();\n For both cases, the name argument given to the constructor is passed to the {@code Configuration.getAppConfigurationEntry} method. If the Configuration has no entries for the specified name, then the {@code LoginContext} calls {@code getAppConfigurationEntry} with the name, \"other\" (the default entry name). If there is no entry for \"other\", then a {@code LoginException} is thrown. When LoginContext uses the installed Configuration, the caller requires the createLoginContext.name and possibly createLoginContext.other AuthPermissions. Furthermore, the LoginContext will invoke configured modules from within an {@code AccessController.doPrivileged} call so that modules that perform security-sensitive tasks (such as connecting to remote hosts, and updating the Subject) will require the respective permissions, but the callers of the LoginContext will not require those permissions. When LoginContext uses a caller-specified Configuration, the caller does not require any createLoginContext AuthPermission. The LoginContext saves the {@code AccessControlContext} for the caller, and invokes the configured modules from within an {@code AccessController.doPrivileged} call constrained by that context. This means the caller context (stored when the LoginContext was created) must have sufficient permissions to perform any security-sensitive tasks that the modules may perform. {@code CallbackHandler} If the constructor has a CallbackHandler input parameter, the LoginContext uses the caller-specified CallbackHandler object. If the constructor does not have a CallbackHandler input parameter, or if the caller specifies a {@code null} CallbackHandler object (and a {@code null} value is permitted), the LoginContext queries the {@code auth.login.defaultCallbackHandler} security property for the fully qualified class name of a default handler implementation. If the security property is not set, then the underlying modules will not have a CallbackHandler for use in communicating with users. The caller thus assumes that the configured modules have alternative means for authenticating the user. When the LoginContext uses the installed Configuration (instead of a caller-specified Configuration, see above), then this LoginContext must wrap any caller-specified or default CallbackHandler implementation in a new CallbackHandler implementation whose {@code handle} method implementation invokes the specified CallbackHandler's {@code handle} method in a {@code java.security.AccessController.doPrivileged} call constrained by the caller's current {@code AccessControlContext}."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "javax.security.auth.login.LoginContext.login",
      "jar": null,
      "comment": "Login",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/XmlRpcServletServer.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078",
        "CWE079"
      ],
      "javadoc": {
        "method": "Processes the servlet request.",
        "class": "An extension of {@link org.apache.xmlrpc.server.XmlRpcServer}, which is suitable for processing servlet requests."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.XmlRpcServletServer.execute",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "javax.servlet.http.HttpServletRequest",
        "javax.servlet.http.HttpServletResponse"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/jms\/connection\/UserCredentialsConnectionFactoryAdapter.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Determine whether there are currently thread-bound credentials, using them if available, falling back to the statically specified username and password (i.e. values of the bean properties) else.",
        "class": "An adapter for a target JMS {@link javax.jms.ConnectionFactory}, applying the given user credentials to every standard {@code createConnection()} call, that is, implicitly invoking {@code createConnection(username, password)} on the target. All other methods simply delegate to the corresponding methods of the target ConnectionFactory. Can be used to proxy a target JNDI ConnectionFactory that does not have user credentials configured. Client code can work with the ConnectionFactory without passing in username and password on every {@code createConnection()} call. In the following example, client code can simply transparently work with the preconfigured \"myConnectionFactory\", implicitly accessing \"myTargetConnectionFactory\" with the specified user credentials.  &lt;bean id=\"myTargetConnectionFactory\" class=\"org.springframework.jndi.JndiObjectFactoryBean\"&gt;\n   &lt;property name=\"jndiName\" value=\"java:comp\/env\/jms\/mycf\"\/&gt;\n &lt;\/bean&gt;\n\n &lt;bean id=\"myConnectionFactory\" class=\"org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter\"&gt;\n   &lt;property name=\"targetConnectionFactory\" ref=\"myTargetConnectionFactory\"\/&gt;\n   &lt;property name=\"username\" value=\"myusername\"\/&gt;\n   &lt;property name=\"password\" value=\"mypassword\"\/&gt;\n &lt;\/bean&gt; If the \"username\" is empty, this proxy will simply delegate to the standard {@code createConnection()} method of the target ConnectionFactory. This can be used to keep a UserCredentialsConnectionFactoryAdapter bean definition just for the option of implicitly passing in user credentials if the particular target ConnectionFactory requires it."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.jms.connection.UserCredentialsConnectionFactoryAdapter.createTopicConnection",
      "jar": null,
      "comment": "",
      "parameters": [],
      "return": "javax.jms.TopicConnection",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the original filename in the client's filesystem, as provided by the browser (or other client software). In most cases, this will be the base file name, without path information. However, some clients, such as the Opera browser, do include path information.",
        "class": "An adapter of Servlet 3.0 {@link Part} to Apache Commons FileUpload's {@link FileItem}"
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.servlet.ServletPartFileItem.getName",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/docs.spring.io\/autorepo\/docs\/spring-security\/3.1.8.CI-SNAPSHOT\/apidocs\/org\/springframework\/security\/authentication\/rcp\/RemoteAuthenticationProvider.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Performs authentication with the same contract as {@link org.springframework.security.authentication.AuthenticationManager#authenticate(Authentication)} .",
        "class": "Client-side object which queries a {@link RemoteAuthenticationManager} to validate an authentication request. A new Authentication object is created by this class comprising the request Authentication object's principal, credentials and the GrantedAuthority[]s returned by the RemoteAuthenticationManager. The RemoteAuthenticationManager should not require any special username or password setting on the remoting client proxy factory to execute the call. Instead the entire authentication request must be encapsulated solely within the Authentication request object. In practical terms this means the RemoteAuthenticationManager will not be protected by BASIC or any other HTTP-level authentication. If authentication fails, a RemoteAuthenticationException will be thrown. This exception should be caught and displayed to the user, enabling them to retry with alternative credentials etc."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.authentication.rcp.RemoteAuthenticationProvider.authenticate",
      "jar": null,
      "comment": "The input object is authenticated and returned.",
      "parameters": [
        "org.springframework.security.core.Authentication"
      ],
      "return": "org.springframework.security.core.Authentication",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "http:\/\/grepcode.com\/file\/repo1.maven.org\/maven2\/org.apache.xmlrpc\/xmlrpc-server\/3.1\/org\/apache\/xmlrpc\/webserver\/ServletOutputStreamImpl.java",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": "Default implementation of a servlet output stream. Handles output of HTTP headers."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.ServletOutputStreamImpl.write",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "byte[]",
        "int",
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.ConnectionServer.writeResponse",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.apache.xmlrpc.common.XmlRpcStreamRequestConfig",
        "java.io.OutputStream",
        "java.lang.Object"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Specifies the attributes that will be returned as part of the search. null indicates that all attributes will be returned. An empty array indicates no attributes are returned.",
        "class": "This class encapsulates factors that determine scope of search and what gets returned as a result of the search. A SearchControls instance is not synchronized against concurrent multithreaded access. Multiple threads trying to access and modify a single SearchControls instance should lock the object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.naming.directory.SearchControls.setReturningAttributes",
      "jar": "jndi-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String[]"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Decodes HTML entities.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.decodeForHTML",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078"
      ],
      "javadoc": {
        "method": "Loads the native library specified by the libname argument. The libname argument must not contain any platform specific prefix, file extension or path. If a native library called libname is statically linked with the VM, then the JNI_OnLoad_libname function exported by the library is invoked. See the JNI Specification for more details. Otherwise, the libname argument is loaded from a system library location and mapped to a native library image in an implementation- dependent manner. The call System.loadLibrary(name) is effectively equivalent to the call  Runtime.getRuntime().loadLibrary(name)",
        "class": "The System class contains several useful class fields and methods. It cannot be instantiated. Among the facilities provided by the System class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.System.loadLibrary",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/Connection.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Writes the response header to the output stream.",
        "class": "Handler for a single clients connection. This implementation is able to do HTTP keepalive. In other words, it can serve multiple requests via a single, physical connection."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.Connection.writeResponseHeader",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.apache.xmlrpc.webserver.RequestData",
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "See the general contract of the readUTF method of DataInput. Bytes for this operation are read from the contained input stream.",
        "class": "A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way. An application uses a data output stream to write data that can later be read by a data input stream. DataInputStream is not necessarily safe for multithreaded access. Thread safety is optional and is the responsibility of users of methods in this class."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.DataInputStream.readUTF",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Helper method to write out the index to disk.",
        "class": "Represents the tag index for a blog."
      },
      "framework": "pebble",
      "discovery": "manual",
      "name": "net.sourceforge.pebble.index.EmailSubscriptionList.writeIndex",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "http:\/\/grepcode.com\/file\/repo1.maven.org\/maven2\/org.apache.ws.commons.axiom\/axiom-api\/1.2.12\/org\/apache\/axiom\/om\/impl\/SwitchingWrapper.java",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "This is a very important method. It keeps the navigator one step ahead and pushes it one event ahead. If the nextNode is null then navigable is set to false. At the same time the parser and builder are set up for the upcoming event generation.",
        "class": "Class used internally by {@link OMStAXWrapper}."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.axiom.om.impl.SwitchingWrapper.updateLastNode",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/commons.apache.org\/proper\/commons-bcel\/apidocs\/org\/apache\/bcel\/util\/JavaWrapper.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078"
      ],
      "javadoc": {
        "method": "Runs the main method of the given class with the arguments passed in argv",
        "class": "Java interpreter replacement, i.e., wrapper that uses its own ClassLoader to modify\/generate classes as they're requested. You can take this as a template for your own applications. Call this wrapper with: java org.apache.bcel.util.JavaWrapper &lt;real.class.name&gt; [arguments] To use your own class loader you can set the \"bcel.classloader\" system property java org.apache.bcel.util.JavaWrapper -Dbcel.classloader=foo.MyLoader &lt;real.class.name&gt; [arguments]"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.bcel.util.JavaWrapper.runMain",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.lang.String",
        "java.lang.String[]"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Constructs an initial DirContext using the supplied environment. Environment properties are discussed in the javax.naming.InitialContext class description. This constructor will not modify environment or save a reference to it, but may save a clone. Caller should not modify mutable keys and values in environment after it has been passed to the constructor.",
        "class": "This class is the starting context for performing directory operations. The documentation in the class description of InitialContext (including those for synchronization) apply here."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.naming.directory.InitialDirContext.<init>",
      "jar": "jndi-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.util.Hashtable"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Searches for the property with the specified key in this property list. If the key is not found in this property list, the default property list, and its defaults, recursively, are then checked. The method returns {@code null} if the property is not found.",
        "class": "The {@code Properties} class represents a persistent set of properties. The {@code Properties} can be saved to a stream or loaded from a stream. Each key and its corresponding value in the property list is a string. A property list can contain another property list as its \"defaults\"; this second property list is searched if the property key is not found in the original property list. Because {@code Properties} inherits from {@code Hashtable}, the {@code put} and {@code putAll} methods can be applied to a {@code Properties} object. Their use is strongly discouraged as they allow the caller to insert entries whose keys or values are not {@code Strings}. The {@code setProperty} method should be used instead. If the {@code store} or {@code save} method is called on a \"compromised\" {@code Properties} object that contains a non-{@code String} key or value, the call will fail. Similarly, the call to the {@code propertyNames} or {@code list} method will fail if it is called on a \"compromised\" {@code Properties} object that contains a non-{@code String} key. The {@link #load(java.io.Reader) load(Reader)} \/ {@link #store(java.io.Writer, java.lang.String) store(Writer, String)} methods load and store properties from and to a character based stream in a simple line-oriented format specified below. The {@link #load(java.io.InputStream) load(InputStream)} \/ {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)} methods work the same way as the load(Reader)\/store(Writer, String) pair, except the input\/output stream is encoded in ISO 8859-1 character encoding. Characters that cannot be directly represented in this encoding can be written using Unicode escapes as defined in section 3.3 of The Javaâ„¢ Language Specification; only a single 'u' character is allowed in an escape sequence. The native2ascii tool can be used to convert property files to and from other character encodings. The {@link #loadFromXML(InputStream)} and {@link #storeToXML(OutputStream, String, String)} methods load and store properties in a simple XML format. By default the UTF-8 character encoding is used, however a specific encoding may be specified if required. Implementations are required to support UTF-8 and UTF-16 and may support other encodings. An XML properties document has the following DOCTYPE declaration:  \n Note that the system URI (http:\/\/java.sun.com\/dtd\/properties.dtd) is not accessed when exporting or importing properties; it merely serves as a string to uniquely identify the DTD, which is:     \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n This class is thread-safe: multiple threads can share a single Properties object without the need for external synchronization."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.Properties.getProperty",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078"
      ],
      "javadoc": {
        "method": "Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds plus the specified number of nanoseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.",
        "class": "A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently. Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon. When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). The Java Virtual Machine continues to execute threads until either of the following occurs: The exit method of class Runtime has been called and the security manager has permitted the exit operation to take place. All threads that are not daemon threads have died, either by returning from the call to the run method or by throwing an exception that propagates beyond the run method. There are two ways to create a new thread of execution. One is to declare a class to be a subclass of Thread. This subclass should override the run method of class Thread. An instance of the subclass can then be allocated and started. For example, a thread that computes primes larger than a stated value could be written as follows:      class PrimeThread extends Thread {\n         long minPrime;\n         PrimeThread(long minPrime) {\n             this.minPrime = minPrime;\n         }\n\n         public void run() {\n             \/\/ compute primes larger than minPrime\n             Â .Â .Â .\n         }\n     }\n The following code would then create a thread and start it running:      PrimeThread p = new PrimeThread(143);\n     p.start();\n The other way to create a thread is to declare a class that implements the Runnable interface. That class then implements the run method. An instance of the class can then be allocated, passed as an argument when creating Thread, and started. The same example in this other style looks like the following:      class PrimeRun implements Runnable {\n         long minPrime;\n         PrimeRun(long minPrime) {\n             this.minPrime = minPrime;\n         }\n\n         public void run() {\n             \/\/ compute primes larger than minPrime\n             Â .Â .Â .\n         }\n     }\n The following code would then create a thread and start it running:      PrimeRun p = new PrimeRun(143);\n     new Thread(p).start();\n Every thread has a name for identification purposes. More than one thread may have the same name. If a name is not specified when a thread is created, a new name is generated for it. Unless otherwise noted, passing a {@code null} argument to a constructor or method in this class will cause a {@link NullPointerException} to be thrown."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.Thread.sleep",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "long",
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns a {@code Field} object that reflects the specified declared field of the class or interface represented by this {@code Class} object. The {@code name} parameter is a {@code String} that specifies the simple name of the desired field. If this {@code Class} object represents an array type, then this method does not find the {@code length} field of the array type.",
        "class": "Instances of the class {@code Class} represent classes and interfaces in a running Java application. An enum is a kind of class and an annotation is a kind of interface. Every array also belongs to a class that is reflected as a {@code Class} object that is shared by all arrays with the same element type and number of dimensions. The primitive Java types ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code int}, {@code long}, {@code float}, and {@code double}), and the keyword {@code void} are also represented as {@code Class} objects. {@code Class} has no public constructor. Instead {@code Class} objects are constructed automatically by the Java Virtual Machine as classes are loaded and by calls to the {@code defineClass} method in the class loader. The following example uses a {@code Class} object to print the class name of an object:      void printClassName(Object obj) {\n         System.out.println(\"The class of \" + obj +\n                            \" is \" + obj.getClass().getName());\n     }\n It is also possible to get the {@code Class} object for a named type (or for void) using a class literal. See Section 15.8.2 of The Javaâ„¢ Language Specification. For example: {@code System.out.println(\"The name of class Foo is: \"+Foo.class.getName());}"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.lang.Class.getDeclaredField",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.reflect.Field",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/xref\/org\/apache\/commons\/httpclient\/HttpMethodDirector.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": "Handles the process of executing a method including authentication, redirection and retries."
      },
      "framework": "apachecommons",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.HttpMethodDirector.authenticateProxy",
      "jar": null,
      "comment": "The authentication string is added to the http method.",
      "parameters": [
        "org.apache.commons.httpclient.HttpMethod"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/static.javadoc.io\/org.springframework\/spring\/2.0.3\/org\/springframework\/web\/filter\/RequestContextFilter.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Set whether to expose the LocaleContext and RequestAttributes as inheritable for child threads (using an {@link java.lang.InheritableThreadLocal}). Default is \"false\", to avoid side effects on spawned background threads. Switch this to \"true\" to enable inheritance for custom child threads which are spawned during request processing and only used for this request (that is, ending after their initial task, without reuse of the thread). WARNING: Do not use inheritance for child threads if you are accessing a thread pool which is configured to potentially add new threads on demand (e.g. a JDK {@link java.util.concurrent.ThreadPoolExecutor}), since this will expose the inherited context to such a pooled thread.",
        "class": "Servlet 2.3 Filter that exposes the request to the current thread, through both {@link org.springframework.context.i18n.LocaleContextHolder} and {@link RequestContextHolder}. To be registered as filter in web.xml. Alternatively, Spring's {@link org.springframework.web.context.request.RequestContextListener} and Spring's {@link org.springframework.web.servlet.DispatcherServlet} also expose the same request context to the current thread. This filter is mainly for use with third-party servlets, e.g. the JSF FacesServlet. Within Spring's own web support, DispatcherServlet's processing is perfectly sufficient."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.filter.RequestContextFilter.setThreadContextInheritable",
      "jar": null,
      "comment": "Counter example for source",
      "parameters": [
        "boolean"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getRemoteHost() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getRemoteHost",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/grepcode.com\/file\/repo1.maven.org\/maven2\/org.apache.ws.commons.axiom\/axiom-api\/1.2.12\/org\/apache\/axiom\/om\/impl\/SwitchingWrapper.java",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.axiom.om.impl.SwitchingWrapper.updateCompleteStatus",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getLocalAddr() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getLocalAddr",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/KerberosScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces KERBEROS authorization Header based on token created by processChallenge.",
        "class": "KERBEROS authentication scheme."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.auth.KerberosScheme.authenticate",
      "jar": null,
      "comment": "The authentication string is calculated from the credentials and returned as a header.",
      "parameters": [
        "org.apache.http.auth.Credentials",
        "org.apache.http.HttpRequest",
        "org.apache.http.protocol.HttpContext"
      ],
      "return": "org.apache.http.Header",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encoder for XML comments. NOT FOR USE WITH (X)HTML CONTEXTS. (X)HTML comments may be interpreted by browsers as something other than a comment, typically in vendor specific extensions (e.g. {@code }). For (X)HTML it is recommend that unsafe content never be included in a comment. The caller must provide the comment start and end sequences. This method replaces all invalid XML characters with spaces, and replaces the \"--\" sequence (which is invalid in XML comments) with \"-~\" (hyphen-tilde). This encoding behavior may change in future releases. If the comments need to be decoded, the caller will need to come up with their own encode\/decode system.      out.println(\"\");\n     out.println(\"\");\n     out.println(\"\");\n     out.println(\"\");",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forXmlComment",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "This method encodes for HTML text content. It does not escape quotation characters and is thus unsafe for use with HTML attributes. Use either forHtml or forHtmlAttribute for those methods. Example JSP Usage      \n Encoding Table Input Result {@code &} {@code &} {@code } {@code >} Additional Notes Single-quote character ({@code '}) and double-quote character ({@code \"}) do not require encoding in HTML blocks, unlike other HTML contexts. The encoding of the greater-than sign ({@code >}) is not strictly required, but is included for maximum compatibility. Carriage return (U+0D), line-feed (U+0A), horizontal tab (U+09) and space (U+20) are valid in quoted attributes and in block in an unescaped form. Surrogate pairs are passed through only if valid. Characters that are not valid according to the XML specification are replaced by a space character as they could lead to parsing errors. In particular only {@code #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]} are considered valid.",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forHtmlContent",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for use in an XPath query. NB: The reference implementation encodes almost everything and may over-encode. The difficulty with XPath encoding is that XPath has no built in mechanism for escaping characters. It is possible to use XQuery in a parameterized way to prevent injection. For more information, refer to this article which specifies the following list of characters as the most dangerous: ^&\"*';<>(). This paper suggests disallowing ' and \" in queries.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForXPath",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/WebGoat\/WebGoat-Legacy\/blob\/master\/src\/main\/java\/org\/owasp\/webgoat\/session\/DatabaseUtilities.java",
      "type": [
        "authentication",
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE306"
      ],
      "javadoc": {
        "method": "",
        "class": "This file is part of WebGoat, an Open Web Application Security Project utility. For details, please see http:\/\/www.owasp.org\/ Copyright (c) 2002 - 20014 Bruce Mayhew This program is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. Getting Source ============== Source for this application is maintained at https:\/\/github.com\/WebGoat\/WebGoat, a repository for free software projects."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.session.DatabaseUtilities.getHsqldbConnection",
      "jar": null,
      "comment": "creates a database connection",
      "parameters": [
        "java.lang.String",
        "org.owasp.webgoat.session.WebgoatContext"
      ],
      "return": "java.sql.Connection",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getContentType() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getContentType",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.sockjs.transport.handler.XhrStreamingTransportHandler.access$000",
      "jar": null,
      "comment": "Counter example for sanitizer (returns byte[], but implicit method)",
      "parameters": [],
      "return": "byte[]",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/authentication\/jaas\/SecurityContextLoginModule.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Log out the Subject.",
        "class": "An implementation of {@link LoginModule} that uses a Spring Security {@link org.springframework.security.core.context.SecurityContext SecurityContext} to provide authentication. This LoginModule provides opposite functionality to the {@link JaasAuthenticationProvider} API, and should not really be used in conjunction with it. The {@link JaasAuthenticationProvider} allows Spring Security to authenticate against Jaas. The SecurityContextLoginModule allows a Jaas based application to authenticate against Spring Security. If there is no Authentication in the {@link SecurityContextHolder} the login() method will throw a LoginException by default. This functionality can be changed with the ignoreMissingAuthentication option by setting it to \"true\". Setting ignoreMissingAuthentication=true will tell the SecurityContextLoginModule to simply return false and be ignored if the authentication is null."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.authentication.jaas.SecurityContextLoginModule.logout",
      "jar": null,
      "comment": "Puts the program is an unauthenticated state.",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Assigns a new value to this Cookie. If you use a binary value, you may want to use BASE64 encoding. With Version 0 cookies, values should not contain white space, brackets, parentheses, equals signs, commas, double quotes, slashes, question marks, at signs, colons, and semicolons. Empty values may not behave the same way on all browsers.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.setValue",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Update the persistent instance with the identifier of the given detached instance. If there is a persistent instance with the same identifier, an exception is thrown. This operation cascades to associated instances if the association is mapped with {@code cascade=\"save-update\"}",
        "class": "Concrete implementation of a Session. Exposes two interfaces: {@link org.hibernate.Session} to the application {@link org.hibernate.engine.spi.SessionImplementor} to other Hibernate components (SPI) This class is not thread-safe."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.hibernate.internal.SessionImpl.update",
      "jar": "hibernate-core-5.2.10.Final.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.Object"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/jdbc\/core\/JdbcTemplate.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Issue a single SQL execute, typically a DDL statement.",
        "class": "This is the central class in the JDBC core package. It simplifies the use of JDBC and helps to avoid common errors. It executes core JDBC workflow, leaving application code to provide SQL and extract results. This class executes SQL queries or updates, initiating iteration over ResultSets and catching JDBC exceptions and translating them to the generic, more informative exception hierarchy defined in the org.springframework.dao package. Code using this class need only implement callback interfaces, giving them a clearly defined contract. The {@link PreparedStatementCreator} callback interface creates a prepared statement given a Connection, providing SQL and any necessary parameters. The {@link ResultSetExtractor} interface extracts values from a ResultSet. See also {@link PreparedStatementSetter} and {@link RowMapper} for two popular alternative callback interfaces. Can be used within a service implementation via direct instantiation with a DataSource reference, or get prepared in an application context and given to services as bean reference. Note: The DataSource should always be configured as a bean in the application context, in the first case given to the service directly, in the second case to the prepared template. Because this class is parameterizable by the callback interfaces and the {@link org.springframework.jdbc.support.SQLExceptionTranslator} interface, there should be no need to subclass it. All SQL operations performed by this class are logged at debug level, using \"org.springframework.jdbc.core.JdbcTemplate\" as log category."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.jdbc.core.JdbcTemplate.execute",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Log a LogRecord. All the other logging methods in this class call through this method to actually perform any logging. Subclasses can override this single method to capture all log activity.",
        "class": "A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the {@code getLogger} factory methods may be garbage collected at any time if a strong reference to the Logger is not kept. Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree. The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent. On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree. Each Logger may have a {@code ResourceBundle} associated with it. The {@code ResourceBundle} may be specified by name, using the {@link #getLogger(java.lang.String, java.lang.String)} factory method, or by value - using the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method. This bundle will be used for localizing logging messages. If a Logger does not have its own {@code ResourceBundle} or resource bundle name, then it will inherit the {@code ResourceBundle} or resource bundle name from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument. These methods take a {@link Supplier}{@code } function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       \/\/ collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled. \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n When looking for a {@code ResourceBundle}, the logger will first look at whether a bundle was specified using {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then only whether a resource bundle name was specified through the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. If no {@code ResourceBundle} or no resource bundle name is found, then it will use the nearest {@code ResourceBundle} or resource bundle name inherited from its parent tree. When a {@code ResourceBundle} was inherited or specified through the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then that {@code ResourceBundle} will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a {@code ResourceBundle} object, using the default Locale at the time of logging. When mapping resource bundle names to {@code ResourceBundle} objects, the logger will first try to use the Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class loader} to map the given resource bundle name to a {@code ResourceBundle}. If the thread context class loader is {@code null}, it will try the {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader} instead. If the {@code ResourceBundle} is still not found, it will use the class loader of the first caller of the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string. There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name. There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message. There are convenience methods for tracing method entries (the \"entering\" methods), method returns (the \"exiting\" methods) and throwing exceptions (the \"throwing\" methods). Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string. For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.logging.Logger.log",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.util.logging.LogRecord"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/shiro.apache.org\/static\/1.2.1\/apidocs\/org\/apache\/shiro\/subject\/support\/DelegatingSubject.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Performs a login attempt for this Subject\/user. If unsuccessful, an {@link AuthenticationException} is thrown, the subclass of which identifies why the attempt failed. If successful, the account data associated with the submitted principals\/credentials will be associated with this {@code Subject} and the method will return quietly. Upon returning quietly, this {@code Subject} instance can be considered authenticated and {@link #getPrincipal() getPrincipal()} will be non-null and {@link #isAuthenticated() isAuthenticated()} will be {@code true}.",
        "class": "Implementation of the {@code Subject} interface that delegates method calls to an underlying {@link org.apache.shiro.mgt.SecurityManager SecurityManager} instance for security checks. It is essentially a {@code SecurityManager} proxy. This implementation does not maintain state such as roles and permissions (only {@code Subject} {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless architecture. It instead asks the underlying {@code SecurityManager} every time to perform the authorization check. A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would be \"hit\" every time a method is called. This is not necessarily the case and is up to the implementation of the underlying {@code SecurityManager} instance. If caching of authorization data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered much more elegant to let the underlying {@code SecurityManager} implementation or its delegate components manage caching, not this class. A {@code SecurityManager} is considered a business-tier component, where caching strategies are better managed. Applications from large and clustered to simple and JVM-local all benefit from stateless architectures. This implementation plays a part in the stateless programming paradigm and should be used whenever possible."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.shiro.subject.support.DelegatingSubject.login",
      "jar": null,
      "comment": "Login with the tocken.",
      "parameters": [
        "org.apache.shiro.authc.AuthenticationToken"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Writes an array of characters. This method cannot be inherited from the Writer class because it must suppress I\/O exceptions.",
        "class": "Prints formatted representations of objects to a text-output stream. This class implements all of the print methods found in {@link PrintStream}. It does not contain methods for writing raw bytes, for which a program should use unencoded byte streams. Unlike the {@link PrintStream} class, if automatic flushing is enabled it will be done only when one of the println, printf, or format methods is invoked, rather than whenever a newline character happens to be output. These methods use the platform's own notion of line separator rather than the newline character. Methods in this class never throw I\/O exceptions, although some of its constructors may. The client may inquire as to whether any errors have occurred by invoking {@link #checkError checkError()}."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.PrintWriter.write",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "char[]"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Prints a character and then terminates the line. This method behaves as though it invokes {@link #print(char)} and then {@link #println()}.",
        "class": "Prints formatted representations of objects to a text-output stream. This class implements all of the print methods found in {@link PrintStream}. It does not contain methods for writing raw bytes, for which a program should use unencoded byte streams. Unlike the {@link PrintStream} class, if automatic flushing is enabled it will be done only when one of the println, printf, or format methods is invoked, rather than whenever a newline character happens to be output. These methods use the platform's own notion of line separator rather than the newline character. Methods in this class never throw I\/O exceptions, although some of its constructors may. The client may inquire as to whether any errors have occurred by invoking {@link #checkError checkError()}."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.PrintWriter.println",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "char"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getReader() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getReader",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.io.BufferedReader",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/OWASP\/WebGoat\/blob\/master\/webgoat\/src\/main\/java\/org\/owasp\/webgoat\/HammerHead.java",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Description of the Method",
        "class": "************************************************************************************************* This file is part of WebGoat, an Open Web Application Security Project utility. For details, please see http:\/\/www.owasp.org\/ Copyright (c) 2002 - 20014 Bruce Mayhew This program is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. Getting Source ============== Source for this application is maintained at https:\/\/github.com\/WebGoat\/WebGoat, a repository for free software projects."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.HammerHead.log",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "javax.servlet.http.HttpServletRequest",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.oracle.com\/javase\/7\/docs\/api\/java\/lang\/Runtime.html#exec(java.lang.String)",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078"
      ],
      "javadoc": {
        "method": "Executes the specified string command in a separate process. This is a convenience method. An invocation of the form exec(command) behaves in exactly the same way as the invocation {@link #exec(String, String[], File) exec}(command, null, null).",
        "class": "Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running. The current runtime can be obtained from the getRuntime method. An application cannot create its own instance of this class."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "java.lang.Runtime.exec",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.Process",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.oracle.com\/javaee\/6\/api\/javax\/servlet\/ServletRequestWrapper.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE601"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to return getParameter(String name) on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "javageneral",
      "discovery": "manual",
      "name": "javax.servlet.ServletRequestWrapper.getParameter",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/OWASP\/WebGoat\/blob\/master\/webgoat\/src\/main\/java\/org\/owasp\/webgoat\/session\/WebSession.java",
      "type": [
        "authentication"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Gets the authenticated attribute of the WebSession object",
        "class": "************************************************************************************************* This file is part of WebGoat, an Open Web Application Security Project utility. For details, please see http:\/\/www.owasp.org\/ Copyright (c) 2002 - 20014 Bruce Mayhew This program is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. Getting Source ============== Source for this application is maintained at https:\/\/github.com\/WebGoat\/WebGoat, a repository for free software projects."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.session.WebSession.isAuthenticated",
      "jar": null,
      "comment": "Puts the program is an unauthenticated state.",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/help.collab.net\/index.jsp?topic=\/iaf-700\/pebble-soap-javadocs\/net\/sourceforge\/pebble\/domain\/Comment.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "",
        "class": "Represents a blog comment."
      },
      "framework": "pebble",
      "discovery": "manual",
      "name": "net.sourceforge.pebble.domain.Comment.isAuthenticated",
      "jar": null,
      "comment": "Returnes whether the program is authenticated.",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Specifies a path for the cookie to which the client should return the cookie. The cookie is visible to all the pages in the directory you specify, and all the pages in that directory's subdirectories. A cookie's path must include the servlet that set the cookie, for example, \/catalog, which makes the cookie visible to all directories on the server under \/catalog. Consult RFC 2109 (available on the Internet) for more information on setting path names for cookies.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.setPath",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getRemoteUser() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getRemoteUser",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "See the general contract of the readLine method of DataInput. Bytes for this operation are read from the contained input stream.",
        "class": "A data input stream lets an application read primitive Java data types from an underlying input stream in a machine-independent way. An application uses a data output stream to write data that can later be read by a data input stream. DataInputStream is not necessarily safe for multithreaded access. Thread safety is optional and is the responsibility of users of methods in this class."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.DataInputStream.readLine",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/web\/socket\/server\/standard\/GlassFishRequestUpgradeStrategy.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.server.standard.GlassFishRequestUpgradeStrategy.handleSuccess",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [
        "javax.servlet.http.HttpServletRequest",
        "javax.servlet.http.HttpServletResponse",
        "org.glassfish.tyrus.spi.WebSocketEngine$UpgradeInfo",
        "org.glassfish.tyrus.core.TyrusUpgradeResponse"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encodes for unquoted HTML attribute values. {@link #forHtml(String)} or {@link #forHtmlAttribute(String)} should usually be preferred over this method as quoted attributes are XHTML compliant. When using this method, the caller is not required to provide quotes around the attribute (since it is encoded for such context). The caller should make sure that the attribute value does not abut unsafe characters--and thus should usually err on the side of including a space character after the value. Use of this method is discouraged as quoted attributes are generally more compatible and safer. Also note, that no attempt has been made to optimize this encoding, though it is still probably faster than other encoding libraries. Example JSP Usage       >\n Encoding Table Input Result {@code U+0009} (horizontal tab) {@code } {@code U+000A} (line feed) {@code } {@code U+000C} (form feed) {@code } {@code U+000D} (carriage return) {@code } {@code U+0020} (space) {@code } {@code &} {@code &} {@code } {@code >} {@code \"} {@code \"} {@code '} {@code '} {@code \/} {@code \/} {@code =} {@code =} {@code `} {@code `} {@code U+0085} (next line) {@code \u2026} {@code U+2028} (line separator) {@code \u2028} {@code U+2029} (paragraph separator) {@code \u2029} Additional Notes The following characters are not encoded: {@code 0-9, a-z, A-Z}, {@code !}, {@code #}, {@code $}, {@code %}, {@code (}, {@code )}, {@code *}, {@code +}, {@code ,}, {@code -}, {@code .}, {@code [}, {@code \\}, {@code ]}, {@code ^}, {@code _}, {@code }}. Surrogate pairs are passed through only if valid. Invalid surrogate pairs are replaced by a hyphen (-). Characters in the C0 and C1 control blocks and not otherwise listed above are considered invalid and replaced by a hyphen (-) character. Unicode \"non-characters\" are replaced by hyphens (-).",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forHtmlUnquotedAttribute",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Sets the system property indicated by the specified key. First, if a security manager exists, its SecurityManager.checkPermission method is called with a PropertyPermission(key, \"write\") permission. This may result in a SecurityException being thrown. If no exception is thrown, the specified property is set to the given value.",
        "class": "The System class contains several useful class fields and methods. It cannot be instantiated. Among the facilities provided by the System class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.lang.System.setProperty",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.ClientProperties.getNavigatorPlatform",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/commons.apache.org\/proper\/commons-jxpath\/apidocs\/org\/apache\/commons\/jxpath\/ri\/JXPathContextReferenceImpl.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Traverses the xpath and returns the resulting object. Primitive types are wrapped into objects.",
        "class": "The reference implementation of JXPathContext."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.jxpath.ri.JXPathContextReferenceImpl.getValue",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/sonatype\/WebGoat\/blob\/master\/src\/main\/java\/org\/owasp\/webgoat\/session\/LessonSession.java",
      "type": [
        "authentication",
        "sink"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "setAuthenticated.",
        "class": "This file is part of WebGoat, an Open Web Application Security Project utility. For details, please see http:\/\/www.owasp.org\/ Copyright (c) 2002 - 20014 Bruce Mayhew This program is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. Getting Source ============== Source for this application is maintained at https:\/\/github.com\/WebGoat\/WebGoat, a repository for free software projects. Represents a virtual session for a lesson. Lesson-specific session data may be stored here."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.session.LessonSession.setAuthenticated",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "boolean"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "This method encodes for JavaScript strings contained within HTML script attributes (such as {@code onclick}). It is NOT safe for use in script blocks. The caller MUST provide the surrounding quotation characters. This method performs the same encode as {@link #forJavaScript(String)} with the exception that \/ is not escaped. Unless you are interested in saving a few bytes of output or are writing a framework on top of this library, it is recommend that you use {@link #forJavaScript(String)} over this method. Example JSP Usage:     ');\">",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forJavaScriptAttribute",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for use in Cascading Style Sheets (CSS) content.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForCSS",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/shiro.apache.org\/static\/1.2.1\/apidocs\/org\/apache\/shiro\/subject\/support\/DelegatingSubject.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "Returns {@code true} if this Subject\/user proved their identity during their current session by providing valid credentials matching those known to the system, {@code false} otherwise. Note that even if this Subject's identity has been remembered via 'remember me' services, this method will still return {@code false} unless the user has actually logged in with proper credentials during their current session. See the {@link #isRemembered() isRemembered()} method JavaDoc for more.",
        "class": "Implementation of the {@code Subject} interface that delegates method calls to an underlying {@link org.apache.shiro.mgt.SecurityManager SecurityManager} instance for security checks. It is essentially a {@code SecurityManager} proxy. This implementation does not maintain state such as roles and permissions (only {@code Subject} {@link #getPrincipals() principals}, such as usernames or user primary keys) for better performance in a stateless architecture. It instead asks the underlying {@code SecurityManager} every time to perform the authorization check. A common misconception in using this implementation is that an EIS resource (RDBMS, etc) would be \"hit\" every time a method is called. This is not necessarily the case and is up to the implementation of the underlying {@code SecurityManager} instance. If caching of authorization data is desired (to eliminate EIS round trips and therefore improve database performance), it is considered much more elegant to let the underlying {@code SecurityManager} implementation or its delegate components manage caching, not this class. A {@code SecurityManager} is considered a business-tier component, where caching strategies are better managed. Applications from large and clustered to simple and JVM-local all benefit from stateless architectures. This implementation plays a part in the stateless programming paradigm and should be used whenever possible."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.shiro.subject.support.DelegatingSubject.isAuthenticated",
      "jar": null,
      "comment": "Check if the program is authenticated.",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Writes the specified message to a servlet log file, prepended by the servlet's name. See {@link ServletContext#log(String)}.",
        "class": "Defines a generic, protocol-independent servlet. To write an HTTP servlet for use on the Web, extend {@link javax.servlet.http.HttpServlet} instead. GenericServlet implements the Servlet and ServletConfig interfaces. GenericServlet may be directly extended by a servlet, although it's more common to extend a protocol-specific subclass such as HttpServlet. GenericServlet makes writing servlets easier. It provides simple versions of the lifecycle methods init and destroy and of the methods in the ServletConfig interface. GenericServlet also implements the log method, declared in the ServletContext interface. To write a generic servlet, you need only override the abstract service method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.GenericServlet.log",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/HttpServletResponseImpl.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Gets the value of the response header with the given name. If a response header with the given name exists and contains multiple values, the value that was added first will be returned. This method considers only response headers set or added via {@link #setHeader}, {@link #addHeader}, {@link #setDateHeader}, {@link #addDateHeader}, {@link #setIntHeader}, or {@link #addIntHeader}, respectively.",
        "class": "Stub implementation of a {@link javax.servlet.http.HttpServletResponse} with lots of unimplemented methods. I implemented only those, which are required for testing the {@link org.apache.xmlrpc.webserver.XmlRpcServlet}. Perhaps someone else is adding more at a later time?"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.HttpServletResponseImpl.getHeader",
      "jar": null,
      "comment": "Counter example for sanitizer.",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to call setCharacterEncoding(String charset) on the wrapped response object.",
        "class": "Provides a convenient implementation of the ServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletResponseWrapper.setCharacterEncoding",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Searches in the named context or object for entries that satisfy the given search filter. Performs the search as specified by the search controls. The interpretation of filterExpr is based on RFC 2254. It may additionally contain variables of the form {i} -- where i is an integer -- that refer to objects in the filterArgs array. The interpretation of filterExpr is otherwise identical to that of the filter parameter of the method search(Name, String, SearchControls). When a variable {i} appears in a search filter, it indicates that the filter argument filterArgs[i] is to be used in that place. Such variables may be used wherever an attr, value, or matchingrule production appears in the filter grammar of RFC 2254, section 4. When a string-valued filter argument is substituted for a variable, the filter is interpreted as if the string were given in place of the variable, with any characters having special significance within filters (such as '*') having been escaped according to the rules of RFC 2254. For directories that do not use a string representation for some or all of their attributes, the filter argument corresponding to an attribute value may be of a type other than String. Directories that support unstructured binary-valued attributes, for example, should accept byte arrays as filter arguments. The interpretation (if any) of filter arguments of any other type is determined by the service provider for that directory, which maps the filter operations onto operations with corresponding semantics in the underlying directory. This method returns an enumeration of the results. Each element in the enumeration contains the name of the object and other information about the object (see SearchResult). The name is either relative to the target context of the search (which is named by the name parameter), or it is a URL string. If the target context is included in the enumeration (as is possible when cons specifies a search scope of SearchControls.OBJECT_SCOPE or SearchControls.SUBSTREE_SCOPE), its name is the empty string. The SearchResult may also contain attributes of the matching object if the cons argument specifies that attributes be returned. If the object does not have a requested attribute, that nonexistent attribute will be ignored. Those requested attributes that the object does have will be returned. A directory might return more attributes than were requested (see Attribute Type Names in the class description) but is not allowed to return arbitrary, unrelated attributes. If a search filter with invalid variable substitutions is provided to this method, the result is undefined. When changes are made to this DirContext, the effect on enumerations returned by prior calls to this method is undefined. See also Operational Attributes in the class description.",
        "class": "This class is the starting context for performing directory operations. The documentation in the class description of InitialContext (including those for synchronization) apply here."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.naming.directory.InitialDirContext.search",
      "jar": "jndi-1.2.1.jar",
      "comment": "",
      "parameters": [
        "javax.naming.Name",
        "java.lang.String",
        "java.lang.Object[]",
        "javax.naming.directory.SearchControls"
      ],
      "return": "javax.naming.NamingEnumeration",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/docs.spring.io\/autorepo\/docs\/spring-security\/3.1.8.CI-SNAPSHOT\/apidocs\/org\/springframework\/security\/authentication\/jaas\/JaasAuthenticationProvider.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Attempts to login the user given the Authentication objects principal and credential",
        "class": "An {@link AuthenticationProvider} implementation that retrieves user details from a JAAS login configuration. This AuthenticationProvider is capable of validating {@link org.springframework.security.authentication.UsernamePasswordAuthenticationToken} requests contain the correct username and password. This implementation is backed by a JAAS configuration. The loginConfig property must be set to a given JAAS configuration file. This setter accepts a Spring {@link org.springframework.core.io.Resource} instance. It should point to a JAAS configuration file containing an index matching the {@link #setLoginContextName(java.lang.String) loginContextName} property. For example: If this JaasAuthenticationProvider were configured in a Spring WebApplicationContext the xml to set the loginConfiguration could be as follows...  \n   \/WEB-INF\/login.conf\n \n The loginContextName should coincide with a given index in the loginConfig specifed. The loginConfig file used in the JUnit tests appears as the following...  JAASTest {\n   org.springframework.security.authentication.jaas.TestLoginModule required;\n };\n Using the example login configuration above, the loginContextName property would be set as JAASTest...    JAASTest \n When using JAAS login modules as the authentication source, sometimes the LoginContext will require CallbackHandlers. The JaasAuthenticationProvider uses an internal CallbackHandler to wrap the {@link JaasAuthenticationCallbackHandler}s configured in the ApplicationContext. When the LoginContext calls the internal CallbackHandler, control is passed to each {@link JaasAuthenticationCallbackHandler} for each Callback passed. {@link JaasAuthenticationCallbackHandler}s are passed to the JaasAuthenticationProvider through the {@link #setCallbackHandlers(org.springframework.security.authentication.jaas.JaasAuthenticationCallbackHandler[]) callbackHandlers} property.  \n   \n     \n     \n     \n  \n \n After calling LoginContext.login(), the JaasAuthenticationProvider will retrieve the returned Principals from the Subject (LoginContext.getSubject().getPrincipals). Each returned principal is then passed to the configured {@link AuthorityGranter}s. An AuthorityGranter is a mapping between a returned Principal, and a role name. If an AuthorityGranter wishes to grant an Authorization a role, it returns that role name from it's {@link AuthorityGranter#grant(java.security.Principal)} method. The returned role will be applied to the Authorization object as a {@link GrantedAuthority}. AuthorityGranters are configured in spring xml as follows...  \n   \n     \n   \n  \n A configuration note: The JaasAuthenticationProvider uses the security properites &quote;login.config.url.X&quote; to configure jaas. If you would like to customize the way Jaas gets configured, create a subclass of this and override the {@link #configureJaas(Resource)} method."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.authentication.jaas.JaasAuthenticationProvider.authenticate",
      "jar": null,
      "comment": "The input object is authenticated and returned.",
      "parameters": [
        "org.springframework.security.core.Authentication"
      ],
      "return": "org.springframework.security.core.Authentication",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/3.2.2.RELEASE\/apidocs\/org\/springframework\/security\/crypto\/codec\/Hex.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "",
        "class": "Hex data encoder. Converts byte arrays (such as those obtained from message digests) into hexadecimal string representation. For internal use only."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.crypto.codec.Hex.encode",
      "jar": null,
      "comment": "",
      "parameters": [
        "byte[]"
      ],
      "return": "char[]",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/BasicScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Returns a basic Authorization header value for the given {@link Credentials} and charset.",
        "class": "Basic authentication scheme as defined in RFC 2617. The following parameters can be used to customize the behavior of this class: {@link org.apache.http.auth.params.AuthPNames#CREDENTIAL_CHARSET}"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.auth.BasicScheme.authenticate",
      "jar": null,
      "comment": "When the input is true, the tocken should be trusted.",
      "parameters": [
        "org.apache.http.auth.Credentials",
        "java.lang.String",
        "boolean"
      ],
      "return": "org.apache.http.Header",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "oauth",
      "discovery": "manual",
      "name": "org.dmfs.oauth2.client.http.requests.ResourceOwnerPasswordTokenRequest.requestEntity",
      "jar": null,
      "comment": "Source training set",
      "parameters": [],
      "return": "org.dmfs.httpclient.HttpRequestEntity",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Prints a character and then terminate the line. This method behaves as though it invokes {@link #print(char)} and then {@link #println()}.",
        "class": "A PrintStream adds functionality to another output stream, namely the ability to print representations of various data values conveniently. Two other features are provided as well. Unlike other output streams, a PrintStream never throws an IOException; instead, exceptional situations merely set an internal flag that can be tested via the checkError method. Optionally, a PrintStream can be created so as to flush automatically; this means that the flush method is automatically invoked after a byte array is written, one of the println methods is invoked, or a newline character or byte ('\\n') is written. All characters printed by a PrintStream are converted into bytes using the platform's default character encoding. The {@link PrintWriter} class should be used in situations that require writing characters rather than bytes."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.PrintStream.println",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "char"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/jhy\/jsoup\/blob\/master\/src\/main\/java\/org\/jsoup\/nodes\/Entities.java",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "HTML escape an input string. That is, {@code &lt;} is returned as {@code &lt;}",
        "class": "HTML entities, and escape routines. Source: W3C HTML named character references."
      },
      "framework": "jsoup",
      "discovery": "manual",
      "name": "org.jsoup.nodes.Entities.escape",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String",
        "javax.swing.text.Document.OutputSettings"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode input for use in a SQL query, according to the selected codec (appropriate codecs include the MySQLCodec and OracleCodec). This method is not recommended. The use of the PreparedStatement interface is the preferred approach. However, if for some reason this is impossible, then this method is provided as a weaker alternative. The best approach is to make sure any single-quotes are double-quoted. Another possible approach is to use the {escape} syntax described in the JDBC specification in section 1.5.6. However, this syntax does not work with all drivers, and requires modification of all queries.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForSQL",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "org.owasp.esapi.codecs.Codec",
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Parse parameters from the given request, handle any servlet commands, and update this session based on the parameters.",
        "class": "************************************************************************************************* This file is part of WebGoat, an Open Web Application Security Project utility. For details, please see http:\/\/www.owasp.org\/ Copyright (c) 2002 - 20014 Bruce Mayhew This program is free software; you can redistribute it and\/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. Getting Source ============== Source for this application is maintained at https:\/\/github.com\/WebGoat\/WebGoat, a repository for free software projects."
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.session.WebSession.update",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "javax.servlet.http.HttpServletRequest",
        "javax.servlet.http.HttpServletResponse",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/static.javadoc.io\/org.owasp.esapi\/esapi\/2.0.1\/org\/owasp\/esapi\/Encoder.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Encode string for use in CSS.",
        "class": "Static encoder methods for JSP EL expression functions."
      },
      "framework": "owaspesapi",
      "discovery": "manual",
      "name": "org.owasp.esapi.tags.ELEncodeFunctions.encodeForCSS",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/mock\/web\/MockBodyContent.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Terminate the current line by writing the line separator string. The line separator string is defined by the system property line.separator, and is not necessarily a single newline character ('\\n').",
        "class": "Mock implementation of the {@link javax.servlet.jsp.tagext.BodyContent} class. Used for testing the web framework; only necessary for testing applications when testing custom JSP tags."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.mock.web.MockBodyContent.println",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Adds a Substring component of initial, any or final substring matching. This method can be invoked only if startSubString was the last filter- building method called. A substring is not required to have an 'INITIAL' substring. However, when a filter contains an 'INITIAL' substring only one can be added, and it must be the first substring added. Any number of 'ANY' substrings can be added. A substring is not required to have a 'FINAL' substrings either. However, when a filter does contain a 'FINAL' substring only one can be added, and it must be the last substring added.",
        "class": "Represents an LDAP Filter. This filter object can be created from a String or can be built up programatically by adding filter components one at a time. Existing filter components can be iterated though. Each filter component has an integer identifier defined in this class. The following are basic filter components: {@link #EQUALITY_MATCH}, {@link #GREATER_OR_EQUAL}, {@link #LESS_OR_EQUAL}, {@link #SUBSTRINGS}, {@link #PRESENT}, {@link #APPROX_MATCH}, {@link #EXTENSIBLE_MATCH}. More filters can be nested together into more complex filters with the following filter components: {@link #AND}, {@link #OR}, {@link #NOT} Substrings can have three components:        Filter ::= CHOICE {\n               and             [0] SET OF Filter,\n               or              [1] SET OF Filter,\n               not             [2] Filter,\n               equalityMatch   [3] AttributeValueAssertion,\n               substrings      [4] SubstringFilter,\n               greaterOrEqual  [5] AttributeValueAssertion,\n               lessOrEqual     [6] AttributeValueAssertion,\n               present         [7] AttributeDescription,\n               approxMatch     [8] AttributeValueAssertion,\n               extensibleMatch [9] MatchingRuleAssertion }"
      },
      "framework": "ldap",
      "discovery": "manual",
      "name": "com.novell.ldap.rfc2251.RfcFilter.addSubstring",
      "jar": null,
      "comment": "Counter example for sanitizer (byte[] but nothing else)",
      "parameters": [
        "int",
        "byte[]"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          1,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/4.3.9.RELEASE\/javadoc-api\/org\/springframework\/web\/socket\/sockjs\/transport\/session\/WebSocketServerSockJsSession.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": "A SockJS session for use with the WebSocket transport."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.sockjs.transport.session.WebSocketServerSockJsSession.handleMessage",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.springframework.web.socket.TextMessage",
        "org.springframework.web.socket.WebSocketSession"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/access\/intercept\/RunAsImplAuthenticationProvider.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Performs authentication with the same contract as {@link org.springframework.security.authentication.AuthenticationManager#authenticate(Authentication)} .",
        "class": "An {@link AuthenticationProvider} implementation that can authenticate a {@link RunAsUserToken}. Configured in the bean context with a key that should match the key used by adapters to generate the RunAsUserToken. It treats as valid any RunAsUserToken instance presenting a hash code that matches the RunAsImplAuthenticationProvider-configured key. If the key does not match, a BadCredentialsException is thrown."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.access.intercept.RunAsImplAuthenticationProvider.authenticate",
      "jar": null,
      "comment": "The input object is authenticated and returned.",
      "parameters": [
        "org.springframework.security.core.Authentication"
      ],
      "return": "org.springframework.security.core.Authentication",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "returns the user agent string.",
        "class": "Default client info object for web applications."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.request.WebClientInfo.getUserAgent",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/aptivate\/openldap-jldap\/blob\/master\/com\/novell\/ldap\/spml\/SunIdm.java",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "ldap",
      "discovery": "manual",
      "name": "com.novell.ldap.spml.SunIdm.logout",
      "jar": null,
      "comment": "Puts the program is an unauthenticated state.",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/XmlRpcServletServer.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "An extension of {@link org.apache.xmlrpc.server.XmlRpcServer}, which is suitable for processing servlet requests."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.XmlRpcServletServer.getConfig",
      "jar": null,
      "comment": "Counter example for sanitizer.",
      "parameters": [
        "javax.servlet.http.HttpServletRequest"
      ],
      "return": "org.apache.xmlrpc.common.XmlRpcHttpRequestConfigImpl",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for use in HTML attributes.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForHTMLAttribute",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Escapes the characters in a {@code String} using Java String rules. Deals correctly with quotes and control-chars (tab, backslash, cr, ff, etc.) So a tab becomes the characters {@code '\\\\'} and {@code 't'}. The only difference between Java strings and JavaScript strings is that in JavaScript, a single quote and forward-slash (\/) are escaped. Example:  input string: He didn't say, \"Stop!\"\n output string: He didn't say, \\\"Stop!\\\"",
        "class": "Escapes and unescapes {@code String}s for Java, Java Script, HTML and XML. #ThreadSafe#"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.apache.commons.lang3.StringEscapeUtils.escapeJava",
      "jar": "commons-lang3-3.10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getAttributeNames() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getAttributeNames",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.util.Enumeration",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getParameterMap() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getParameterMap",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.util.Map",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/web\/context\/request\/RequestContextListener.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "Servlet 2.4+ listener that exposes the request to the current thread, through both {@link org.springframework.context.i18n.LocaleContextHolder} and {@link RequestContextHolder}. To be registered as listener in web.xml. Alternatively, Spring's {@link org.springframework.web.filter.RequestContextFilter} and Spring's {@link org.springframework.web.servlet.DispatcherServlet} also expose the same request context to the current thread. In contrast to this listener, advanced options are available there (e.g. \"threadContextInheritable\"). This listener is mainly for use with third-party servlets, e.g. the JSF FacesServlet. Within Spring's own web support, DispatcherServlet's processing is perfectly sufficient."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.context.request.RequestContextListener.requestDestroyed",
      "jar": null,
      "comment": "Counter example for source",
      "parameters": [
        "javax.servlet.ServletRequestEvent"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.ClientProperties.getNavigatorAppVersion",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/static.javadoc.io\/org.owasp.esapi\/esapi\/2.0.1\/org\/owasp\/esapi\/reference\/validation\/CreditCardValidationRule.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE079"
      ],
      "javadoc": {
        "method": "The method is similar to ValidationRuile.getSafe except that it returns a harmless object that may or may not have any similarity to the original input (in some cases you may not care). In most cases this should be the same as the getSafe method only instead of throwing an exception, return some default value.",
        "class": "A validator performs syntax and possibly semantic validation of Credit Card String from an untrusted source."
      },
      "framework": "owaspesapi",
      "discovery": "manual",
      "name": "org.owasp.esapi.reference.validation.CreditCardValidationRule.sanitize",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Reads a property list (key and element pairs) from the input byte stream. The input stream is in a simple line-oriented format as specified in {@link #load(java.io.Reader) load(Reader)} and is assumed to use the ISO 8859-1 character encoding; that is each byte is one Latin1 character. Characters not in Latin1, and certain special characters, are represented in keys and elements using Unicode escapes as defined in section 3.3 of The Javaâ„¢ Language Specification. The specified stream remains open after this method returns.",
        "class": "The {@code Properties} class represents a persistent set of properties. The {@code Properties} can be saved to a stream or loaded from a stream. Each key and its corresponding value in the property list is a string. A property list can contain another property list as its \"defaults\"; this second property list is searched if the property key is not found in the original property list. Because {@code Properties} inherits from {@code Hashtable}, the {@code put} and {@code putAll} methods can be applied to a {@code Properties} object. Their use is strongly discouraged as they allow the caller to insert entries whose keys or values are not {@code Strings}. The {@code setProperty} method should be used instead. If the {@code store} or {@code save} method is called on a \"compromised\" {@code Properties} object that contains a non-{@code String} key or value, the call will fail. Similarly, the call to the {@code propertyNames} or {@code list} method will fail if it is called on a \"compromised\" {@code Properties} object that contains a non-{@code String} key. The {@link #load(java.io.Reader) load(Reader)} \/ {@link #store(java.io.Writer, java.lang.String) store(Writer, String)} methods load and store properties from and to a character based stream in a simple line-oriented format specified below. The {@link #load(java.io.InputStream) load(InputStream)} \/ {@link #store(java.io.OutputStream, java.lang.String) store(OutputStream, String)} methods work the same way as the load(Reader)\/store(Writer, String) pair, except the input\/output stream is encoded in ISO 8859-1 character encoding. Characters that cannot be directly represented in this encoding can be written using Unicode escapes as defined in section 3.3 of The Javaâ„¢ Language Specification; only a single 'u' character is allowed in an escape sequence. The native2ascii tool can be used to convert property files to and from other character encodings. The {@link #loadFromXML(InputStream)} and {@link #storeToXML(OutputStream, String, String)} methods load and store properties in a simple XML format. By default the UTF-8 character encoding is used, however a specific encoding may be specified if required. Implementations are required to support UTF-8 and UTF-16 and may support other encodings. An XML properties document has the following DOCTYPE declaration:  \n Note that the system URI (http:\/\/java.sun.com\/dtd\/properties.dtd) is not accessed when exporting or importing properties; it merely serves as a string to uniquely identify the DTD, which is:     \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n This class is thread-safe: multiple threads can share a single Properties object without the need for external synchronization."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.util.Properties.load",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.io.InputStream"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/spring-projects\/spring-framework\/blob\/master\/spring-websocket\/src\/main\/java\/org\/springframework\/web\/socket\/adapter\/standard\/StandardWebSocketSession.java",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "A {@link WebSocketSession} for use with the standard WebSocket for Java API."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.adapter.standard.StandardWebSocketSession.sendTextMessage",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.springframework.web.socket.TextMessage"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/webserver\/HttpServletRequestImpl.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "Stub implementation of a {@link javax.servlet.http.HttpServletRequest} with lots of unimplemented methods. I implemented only those, which are required for testing the {@link org.apache.xmlrpc.webserver.XmlRpcServlet}. Perhaps someone else is adding more at a later time?"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.HttpServletRequestImpl.parsePostData",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.util.Map",
        "java.io.InputStream",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          1,
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/concurrent\/DelegatingSecurityContextExecutorService.html",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "An {@link ExecutorService} which wraps each {@link Runnable} in a {@link DelegatingSecurityContextRunnable} and each {@link Callable} in a {@link DelegatingSecurityContextCallable}."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.concurrent.DelegatingSecurityContextExecutorService.getDelegate",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [],
      "return": "java.util.concurrent.ExecutorService",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getAuthType() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getAuthType",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpcomponents-client-ga\/httpclient\/apidocs\/org\/apache\/http\/impl\/auth\/NegotiateScheme.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Produces an authorization string for the given set of {@link Credentials}.",
        "class": "SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) authentication scheme."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.http.impl.auth.NegotiateScheme.authenticate",
      "jar": null,
      "comment": "Produces an authentication string for the given credentials.",
      "parameters": [
        "org.apache.http.auth.Credentials",
        "org.apache.http.HttpRequest"
      ],
      "return": "org.apache.http.Header",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Canonicalization is simply the operation of reducing a possibly encoded string down to its simplest form. This is important, because attackers frequently use encoding to change their input in a way that will bypass validation filters, but still be interpreted properly by the target of the attack. Note that data encoded more than once is not something that a normal user would generate and should be regarded as an attack. Everyone says you shouldn't do validation without canonicalizing the data first. This is easier said than done. The canonicalize method can be used to simplify just about any input down to its most basic form. Note that canonicalize doesn't handle Unicode issues, it focuses on higher level encoding and escaping schemes. In addition to simple decoding, canonicalize also handles: Perverse but legal variants of escaping schemes Multiple escaping (%2526 or &lt;) Mixed escaping (%26lt;) Nested escaping (%%316 or &%6ct;) All combinations of multiple, mixed, and nested encoding\/escaping (%253c or â”¦gt;) Using canonicalize is simple. The default is just...\n                    String clean = ESAPI.encoder().canonicalize( request.getParameter(\"input\"));\n                    You need to decode untrusted data so that it's safe for ANY downstream interpreter or decoder. For example, if your data goes into a Windows command shell, then into a database, and then to a browser, you're going to need to decode for all of those systems. You can build a custom encoder to canonicalize for your application like this...\n                    ArrayList list = new ArrayList();\n                    list.add( new WindowsCodec() );\n                    list.add( new MySQLCodec() );\n                    list.add( new PercentCodec() );\n                    Encoder encoder = new DefaultEncoder( list );\n                    String clean = encoder.canonicalize( request.getParameter( \"input\" ));\n                    In ESAPI, the Validator uses the canonicalize method before it does validation. So all you need to do is to validate as normal and you'll be protected against a host of encoded attacks.      String input = request.getParameter( \"name\" );\n                    String name = ESAPI.validator().isValidInput( \"test\", input, \"FirstName\", 20, false);\n                    However, the default canonicalize() method only decodes HTMLEntity, percent (URL) encoding, and JavaScript encoding. If you'd like to use a custom canonicalizer with your validator, that's pretty easy too.\n                    ... setup custom encoder as above\n                    Validator validator = new DefaultValidator( encoder );\n                    String input = request.getParameter( \"name\" );\n                    String name = validator.isValidInput( \"test\", input, \"name\", 20, false);\n                    Although ESAPI is able to canonicalize multiple, mixed, or nested encoding, it's safer to not accept this stuff in the first place. In ESAPI, the default is \"strict\" mode that throws an IntrusionException if it receives anything not single-encoded with a single scheme. Currently this is not configurable in ESAPI.properties, but it probably should be. Even if you disable \"strict\" mode, you'll still get warning messages in the log about each multiple encoding and mixed encoding received.      \/\/ disabling strict mode to allow mixed encoding\n                    String url = ESAPI.encoder().canonicalize( request.getParameter(\"url\"), false);",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.canonicalize",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "boolean"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns an unmodifiable string map view of the current system environment. The environment is a system-dependent mapping from names to values which is passed from parent to child processes. If the system does not support environment variables, an empty map is returned. The returned map will never contain null keys or values. Attempting to query the presence of a null key or value will throw a {@link NullPointerException}. Attempting to query the presence of a key or value which is not of type {@link String} will throw a {@link ClassCastException}. The returned map and its collection views may not obey the general contract of the {@link Object#equals} and {@link Object#hashCode} methods. The returned map is typically case-sensitive on all platforms. If a security manager exists, its {@link SecurityManager#checkPermission checkPermission} method is called with a {@link RuntimePermission}(\"getenv.*\") permission. This may result in a {@link SecurityException} being thrown. When passing information to a Java subprocess, system properties are generally preferred over environment variables.",
        "class": "The System class contains several useful class fields and methods. It cannot be instantiated. Among the facilities provided by the System class are standard input, standard output, and error output streams; access to externally defined properties and environment variables; a means of loading files and libraries; and a utility method for quickly copying a portion of an array."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "java.lang.System.getenv",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.util.Map",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Parse the given comma separated sequence of addresses into InternetAddress objects. Addresses must follow RFC822 syntax.",
        "class": "This class represents an Internet email address using the syntax of RFC822. Typical address syntax is of the form \"user@host.domain\" or \"Personal Name \"."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.mail.internet.InternetAddress.parse",
      "jar": "org.apache.stratos.cli-4.0.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "javax.mail.internet.InternetAddress[]",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Turn special characters into HTML character references. Handles complete character set defined in HTML 4.01 recommendation. Escapes all special characters to their corresponding entity reference (e.g. {@code <}). Reference: http:\/\/www.w3.org\/TR\/html4\/sgml\/entities.html",
        "class": "Utility class for HTML escaping. Escapes and unescapes based on the W3C HTML 4.01 recommendation, handling character entity references. Reference: http:\/\/www.w3.org\/TR\/html4\/charset.html For a comprehensive set of String escaping utilities, consider Apache Commons Lang and its StringEscapeUtils class. We are not using that class here to avoid a runtime dependency on Commons Lang just for HTML escaping. Furthermore, Spring's HTML escaping is more flexible and 100% HTML 4.0 compliant."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.springframework.web.util.HtmlUtils.htmlEscape",
      "jar": "spring-web-4.3.9.RELEASE.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/jsoup.org\/apidocs\/org\/jsoup\/nodes\/Node.html#before-java.lang.String-",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Insert the specified HTML into the DOM after this node (i.e. as a following sibling).",
        "class": "The base, abstract Node model. Elements, Documents, Comments etc are all Node instances."
      },
      "framework": "jsoup",
      "discovery": "manual",
      "name": "org.jsoup.nodes.Node.after",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "org.jsoup.nodes.Node",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Gets the domain name of this Cookie. Domain names are formatted according to RFC 2109.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.getDomain",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/sanketsahoo25\/webgoat\/blob\/master\/webgoat-container\/src\/main\/java\/org\/owasp\/webgoat\/service\/LessonInfoService.java",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "handleException.",
        "class": ""
      },
      "framework": "webgoat",
      "discovery": "manual",
      "name": "org.owasp.webgoat.service.LessonInfoService.handleException",
      "jar": null,
      "comment": "Counter example for sink",
      "parameters": [
        "java.lang.Exception"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the selected text contained in this TextComponent. If the selection is null or the document empty, returns null.",
        "class": "JTextComponent is the base class for swing text components. It tries to be compatible with the java.awt.TextComponent class where it can reasonably do so. Also provided are other services for additional flexibility (beyond the pluggable UI and bean support). You can find information on how to use the functionality this class provides in General Rules for Using Text Components, a section in The Java Tutorial. Caret Changes The caret is a pluggable object in swing text components. Notification of changes to the caret position and the selection are sent to implementations of the CaretListener interface that have been registered with the text component. The UI will install a default caret unless a customized caret has been set. By default the caret tracks all the document changes performed on the Event Dispatching Thread and updates it's position accordingly if an insertion occurs before or at the caret position or a removal occurs before the caret position. DefaultCaret tries to make itself visible which may lead to scrolling of a text component within JScrollPane. The default caret behavior can be changed by the {@link DefaultCaret#setUpdatePolicy} method. Note: Non-editable text components also have a caret though it may not be painted. Commands Text components provide a number of commands that can be used to manipulate the component. This is essentially the way that the component expresses its capabilities. These are expressed in terms of the swing Action interface, using the TextAction implementation. The set of commands supported by the text component can be found with the {@link #getActions} method. These actions can be bound to key events, fired from buttons, etc. Text Input The text components support flexible and internationalized text input, using keymaps and the input method framework, while maintaining compatibility with the AWT listener model. A {@link javax.swing.text.Keymap} lets an application bind key strokes to actions. In order to allow keymaps to be shared across multiple text components, they can use actions that extend TextAction. TextAction can determine which JTextComponent most recently has or had focus and therefore is the subject of the action (In the case that the ActionEvent sent to the action doesn't contain the target text component as its source). The input method framework lets text components interact with input methods, separate software components that preprocess events to let users enter thousands of different characters using keyboards with far fewer keys. JTextComponent is an active client of the framework, so it implements the preferred user interface for interacting with input methods. As a consequence, some key events do not reach the text component because they are handled by an input method, and some text input reaches the text component as committed text within an {@link java.awt.event.InputMethodEvent} instead of as a key event. The complete text input is the combination of the characters in keyTyped key events and committed text in input method events. The AWT listener model lets applications attach event listeners to components in order to bind events to actions. Swing encourages the use of keymaps instead of listeners, but maintains compatibility with listeners by giving the listeners a chance to steal an event by consuming it. Keyboard event and input method events are handled in the following stages, with each stage capable of consuming the event: Stage KeyEvent InputMethodEvent 1. input methods (generated here) 2. focus manager 3. registered key listeners registered input method listeners 4. input method handling in JTextComponent 5. keymap handling using the current keymap 6. keyboard handling in JComponent (e.g. accelerators, component navigation, etc.) To maintain compatibility with applications that listen to key events but are not aware of input method events, the input method handling in stage 4 provides a compatibility mode for components that do not process input method events. For these components, the committed text is converted to keyTyped key events and processed in the key event pipeline starting at stage 3 instead of in the input method event pipeline. By default the component will create a keymap (named DEFAULT_KEYMAP) that is shared by all JTextComponent instances as the default keymap. Typically a look-and-feel implementation will install a different keymap that resolves to the default keymap for those bindings not found in the different keymap. The minimal bindings include: inserting content into the editor for the printable keys. removing content with the backspace and del keys. caret movement forward and backward Model\/View Split The text components have a model-view split. A text component pulls together the objects used to represent the model, view, and controller. The text document model may be shared by other views which act as observers of the model (e.g. a document may be shared by multiple components). The model is defined by the {@link Document} interface. This is intended to provide a flexible text storage mechanism that tracks change during edits and can be extended to more sophisticated models. The model interfaces are meant to capture the capabilities of expression given by SGML, a system used to express a wide variety of content. Each modification to the document causes notification of the details of the change to be sent to all observers in the form of a {@link DocumentEvent} which allows the views to stay up to date with the model. This event is sent to observers that have implemented the {@link DocumentListener} interface and registered interest with the model being observed. Location Information The capability of determining the location of text in the view is provided. There are two methods, {@link #modelToView} and {@link #viewToModel} for determining this information. Undo\/Redo support Support for an edit history mechanism is provided to allow undo\/redo operations. The text component does not itself provide the history buffer by default, but does provide the UndoableEdit records that can be used in conjunction with a history buffer to provide the undo\/redo support. The support is provided by the Document model, which allows one to attach UndoableEditListener implementations. Thread Safety The swing text components provide some support of thread safe operations. Because of the high level of configurability of the text components, it is possible to circumvent the protection provided. The protection primarily comes from the model, so the documentation of AbstractDocument describes the assumptions of the protection provided. The methods that are safe to call asynchronously are marked with comments. Newlines For a discussion on how newlines are handled, see DefaultEditorKit. Printing support Several {@link #print print} methods are provided for basic document printing. If more advanced printing is needed, use the {@link #getPrintable} method. Warning: Serialized objects of this class will not be compatible with future Swing releases. The current serialization support is appropriate for short term storage or RMI between applications running the same version of Swing. As of 1.4, support for long term storage of all JavaBeansâ„¢ has been added to the java.beans package. Please see {@link java.beans.XMLEncoder}."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "javax.swing.text.JTextComponent.getSelectedText",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encodes for a Java string. This method will use \"\\b\", \"\\t\", \"\\r\", \"\\f\", \"\\n\", \"\\\"\", \"\\'\", \"\\\\\", octal and unicode escapes. Valid surrogate pairing is not checked. The caller must provide the enclosing quotation characters. This method is useful for when writing code generators and outputting debug messages.      out.println(\"public class Hello {\");\n     out.println(\"    public static void main(String[] args) {\");\n     out.println(\"        System.out.println(\\\"\" + Encode.forJava(message) + \"\\\");\");\n     out.println(\"    }\");\n     out.println(\"}\");",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forJava",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Writes a single character.",
        "class": "Writes text to a character-output stream, buffering characters so as to provide for the efficient writing of single characters, arrays, and strings. The buffer size may be specified, or the default size may be accepted. The default is large enough for most purposes. A newLine() method is provided, which uses the platform's own notion of line separator as defined by the system property line.separator. Not all platforms use the newline character ('\\n') to terminate lines. Calling this method to terminate each output line is therefore preferred to writing a newline character directly. In general, a Writer sends its output immediately to the underlying character or byte stream. Unless prompt output is required, it is advisable to wrap a BufferedWriter around any Writer whose write() operations may be costly, such as FileWriters and OutputStreamWriters. For example,  PrintWriter out\n   = new PrintWriter(new BufferedWriter(new FileWriter(\"foo.out\")));\n will buffer the PrintWriter's output to the file. Without buffering, each invocation of a print() method would cause characters to be converted into bytes that would then be written immediately to the file, which can be very inefficient."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.BufferedWriter.write",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for use in an LDAP distinguished name.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForDN",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode for use in a URL. This method performs URL encoding on the entire string.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForURL",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order. The returned array will be double the length of the passed array, as it takes two characters to represent any given byte.",
        "class": "Converts hexadecimal Strings. The charset used for certain operation can be set, the default is set in {@link #DEFAULT_CHARSET_NAME} This class is thread-safe."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.commons.codec.binary.Hex.encodeHex",
      "jar": "org.apache.stratos.cli-4.0.0.jar",
      "comment": "",
      "parameters": [
        "byte[]"
      ],
      "return": "char[]",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.servlet.ServletPartFileItem.getFileName",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [
        "javax.servlet.http.Part"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/static.javadoc.io\/org.owasp.esapi\/esapi\/2.0.1\/org\/owasp\/esapi\/reference\/validation\/",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE079"
      ],
      "javadoc": {
        "method": "The method is similar to ValidationRuile.getSafe except that it returns a harmless object that may or may not have any similarity to the original input (in some cases you may not care). In most cases this should be the same as the getSafe method only instead of throwing an exception, return some default value. Calls sanitize(String, String, DateFormat) with DateFormat.getInstance()",
        "class": "A validator performs syntax and possibly semantic validation of a single piece of data from an untrusted source."
      },
      "framework": "owaspesapi",
      "discovery": "manual",
      "name": "org.owasp.esapi.reference.validation.DateValidationRule.sanitize",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/shiro.apache.org\/static\/1.2.1\/apidocs\/org\/apache\/shiro\/subject\/support\/DefaultSubjectContext.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "Returns {@code true} if the constructed {@code Subject} should be considered authenticated, {@code false} otherwise.  Be careful setting this value to {@code true} - you should know what you are doing and have a good reason for ignoring Shiro's default authentication state mechanisms.",
        "class": "Default implementation of the {@link SubjectContext} interface. Note that the getters and setters are not simple pass-through methods to an underlying attribute; the getters will employ numerous heuristics to acquire their data attribute as best as possible (for example, if {@link #getPrincipals} is invoked, if the principals aren't in the backing map, it might check to see if there is a subject or session in the map and attempt to acquire the principals from those objects)."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.shiro.subject.support.DefaultSubjectContext.isAuthenticated",
      "jar": null,
      "comment": "Check if the program is authenticated.",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getContextPath() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getContextPath",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for use in LDAP queries.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForLDAP",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for use in HTML using HTML entity encoding Note that the following characters: 00-08, 0B-0C, 0E-1F, and 7F-9F cannot be used in HTML.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForHTML",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/google\/google-auth-library-java\/blob\/master\/oauth2_http\/java\/com\/google\/auth\/oauth2\/UserAuthorizer.java",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE862"
      ],
      "javadoc": {
        "method": "Attempts to retrieve credentials for the approved end user consent.",
        "class": "Handles an interactive 3-Legged-OAuth2 (3LO) user consent authorization."
      },
      "framework": "oauth",
      "discovery": "manual",
      "name": "com.google.auth.oauth2.UserAuthorizer.getCredentials",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "java.lang.String"
      ],
      "return": "com.google.auth.oauth2.UserCredentials",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/www.novell.com\/documentation\/developer\/jldap\/jldapenu\/api\/com\/novell\/ldap\/LDAPConnection.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Synchronously disconnects from the LDAP server. Before the object can perform LDAP operations again, it must reconnect to the server by calling connect. The disconnect method abandons any outstanding requests, issues an unbind request to the server, and then closes the socket.",
        "class": "The central class that encapsulates the connection to a directory server through the LDAP protocol. LDAPConnection objects are used to perform common LDAP operations such as search, modify and add. In addition, LDAPConnection objects allow you to bind to an LDAP server, set connection and search constraints, and perform several other tasks. An LDAPConnection object is not connected on construction and can only be connected to one server at one port. Multiple threads may share this single connection, typically by cloning the connection object, one for each thread. An application may have more than one LDAPConnection object, connected to the same or different directory servers. Sample Code: Search.java"
      },
      "framework": "ldap",
      "discovery": "manual",
      "name": "com.novell.ldap.LDAPConnection.disconnect",
      "jar": null,
      "comment": "Puts the program in a unauthenticated state.",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/jsoup.org\/apidocs\/org\/jsoup\/nodes\/Node.html#before-java.lang.String-",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Insert the specified HTML into the DOM before this node (i.e. as a preceding sibling).",
        "class": "The base, abstract Node model. Elements, Documents, Comments etc are all Node instances."
      },
      "framework": "jsoup",
      "discovery": "manual",
      "name": "org.jsoup.nodes.Node.before",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "org.jsoup.nodes.Node",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getCookies() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getCookies",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "javax.servlet.http.Cookie[]",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getPathTranslated() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getPathTranslated",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/http\/FormLoginBeanDefinitionParser.html",
      "type": [
        "authentication",
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862",
        "CWE601"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.http.FormLoginBeanDefinitionParser.getLoginProcessingUrl",
      "jar": null,
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/jsoup.org\/apidocs\/org\/jsoup\/parser\/Parser.html#parseInput-java.lang.String-java.lang.String-",
      "type": [
        "sink",
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "Parse HTML into a Document.",
        "class": "Parses HTML into a {@link org.jsoup.nodes.Document}. Generally best to use one of the more convenient parse methods in {@link org.jsoup.Jsoup}."
      },
      "framework": "jsoup",
      "discovery": "manual",
      "name": "org.jsoup.parser.Parser.parse",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.String"
      ],
      "return": "org.jsoup.nodes.Document",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/ws.apache.org\/xmlrpc\/apidocs\/org\/apache\/xmlrpc\/client\/XmlRpcClient.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078"
      ],
      "javadoc": {
        "method": "Performs a request with the clients default configuration.",
        "class": "The main access point of an XML-RPC client. This object serves mainly as an object factory. It is designed with singletons in mind: Basically, an application should be able to hold a single instance of XmlRpcClient in a static variable, unless you would be working with different factories. Until Apache XML-RPC 2.0, this object was used both as an object factory and as a place, where configuration details (server URL, suggested encoding, user credentials and the like) have been stored. In Apache XML-RPC 3.0, the configuration details has been moved to the {@link org.apache.xmlrpc.client.XmlRpcClientConfig} object. The configuration object is designed for being passed through the actual worker methods. A configured XmlRpcClient object is thread safe: In other words, the suggested use is, that you configure the client using {@link #setTransportFactory(XmlRpcTransportFactory)} and similar methods, store it in a field and never modify it again. Without modifications, the client may be used for an arbitrary number of concurrent requests."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.client.XmlRpcClient.execute",
      "jar": null,
      "comment": "Performes a request for the method provided as the first argument.",
      "parameters": [
        "java.lang.String",
        "java.lang.Object[]"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encodes for a JavaScript string. It is safe for use in HTML script attributes (such as {@code onclick}), script blocks, JSON files, and JavaScript source. The caller MUST provide the surrounding quotation characters for the string. Since this performs additional encoding so it can work in all of the JavaScript contexts listed, it may be slightly less efficient than using one of the methods targetted to a specific JavaScript context ({@link #forJavaScriptAttribute(String)}, {@link #forJavaScriptBlock}, {@link #forJavaScriptSource}). Unless you are interested in saving a few bytes of output or are writing a framework on top of this library, it is recommend that you use this method over the others. Example JSP Usage:     ');\">\n    \n        var data = \"\";\n    \n Encoding Description Input Character Encoded Result Notes U+0008 BS \\b Backspace character U+0009 HT \\t Horizontal tab character U+000A LF \\n Line feed character U+000C FF \\f Form feed character U+000D CR \\r Carriage return character U+0022 \" \\x22 The encoding \\\" is not used here because it is not safe for use in HTML attributes. (In HTML attributes, it would also be correct to use \"\\&quot;\".) U+0026 & \\x26 Ampersand character U+0027 ' \\x27 The encoding \\' is not used here because it is not safe for use in HTML attributes. (In HTML attributes, it would also be correct to use \"\\&#39;\".) U+002F \/ \\\/ This encoding is used to avoid an input sequence \" block. U+005C \\ \\\\ U+0000 to U+001F \\x## Hexadecimal encoding is used for characters in this range that were not already mentioned in above.",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forJavaScript",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getHeaders(String name) on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getHeaders",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.util.Enumeration",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getScheme() on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getScheme",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/commons.apache.org\/proper\/commons-lang\/javadocs\/api-3.1\/org\/apache\/commons\/lang3\/text\/StrSubstitutor.html",
      "type": [
        "sink",
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089",
        "CWE078",
        "CWE306",
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Replaces all the occurrences of variables with their matching values from the resolver using the given source as a template. The source is not altered by this method. Only the specified portion of the buffer will be processed. The rest of the buffer is not processed, and is not returned.",
        "class": "Substitutes variables within a string by values. This class takes a piece of text and substitutes all the variables within it. The default definition of a variable is {@code ${variableName}}. The prefix and suffix can be changed via constructors and set methods. Variable values are typically resolved from a map, but could also be resolved from system properties, or by supplying a custom variable resolver. The simplest example is to use this class to replace Java System properties. For example:  StrSubstitutor.replaceSystemProperties(\n      \"You are running with java.version = ${java.version} and os.name = ${os.name}.\");\n Typical usage of this class follows the following pattern: First an instance is created and initialized with the map that contains the values for the available variables. If a prefix and\/or suffix for variables should be used other than the default ones, the appropriate settings can be performed. After that the {@code replace()} method can be called passing in the source text for interpolation. In the returned text all variable references (as long as their values are known) will be resolved. The following example demonstrates this:  Map valuesMap = HashMap();\n valuesMap.put(\"animal\", \"quick brown fox\");\n valuesMap.put(\"target\", \"lazy dog\");\n String templateString = \"The ${animal} jumps over the ${target}.\";\n StrSubstitutor sub = new StrSubstitutor(valuesMap);\n String resolvedString = sub.replace(templateString);\n yielding:       The quick brown fox jumps over the lazy dog.\n Also, this class allows to set a default value for unresolved variables. The default value for a variable can be appended to the variable name after the variable default value delimiter. The default value of the variable default value delimiter is ':-', as in bash and other *nix shells, as those are arguably where the default ${} delimiter set originated. The variable default value delimiter can be manually set by calling {@link #setValueDelimiterMatcher(StrMatcher)}, {@link #setValueDelimiter(char)} or {@link #setValueDelimiter(String)}. The following shows an example with variable default value settings:  Map valuesMap = HashMap();\n valuesMap.put(\"animal\", \"quick brown fox\");\n valuesMap.put(\"target\", \"lazy dog\");\n String templateString = \"The ${animal} jumps over the ${target}. ${undefined.number:-1234567890}.\";\n StrSubstitutor sub = new StrSubstitutor(valuesMap);\n String resolvedString = sub.replace(templateString);\n yielding:       The quick brown fox jumps over the lazy dog. 1234567890.\n In addition to this usage pattern there are some static convenience methods that cover the most common use cases. These methods can be used without the need of manually creating an instance. However if multiple replace operations are to be performed, creating and reusing an instance of this class will be more efficient. Variable replacement works in a recursive way. Thus, if a variable value contains a variable then that variable will also be replaced. Cyclic replacements are detected and will cause an exception to be thrown. Sometimes the interpolation's result must contain a variable prefix. As an example take the following source text:    The variable ${${name}} must be used.\n Here only the variable's name referred to in the text should be replaced resulting in the text (assuming that the value of the {@code name} variable is {@code x}):    The variable ${x} must be used.\n To achieve this effect there are two possibilities: Either set a different prefix and suffix for variables which do not conflict with the result text you want to produce. The other possibility is to use the escape character, by default '$'. If this character is placed before a variable reference, this reference is ignored and won't be replaced. For example:    The variable $${${name}} must be used.\n In some complex scenarios you might even want to perform substitution in the names of variables, for instance  ${jre-${java.specification.version}}\n {@code StrSubstitutor} supports this recursive substitution in variable names, but it has to be enabled explicitly by setting the {@link #setEnableSubstitutionInVariables(boolean) enableSubstitutionInVariables} property to true. This class is not thread safe."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.lang3.text.StrSubstitutor.replace",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.CharSequence",
        "int",
        "int"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getMethod() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getMethod",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Either {@link #save(String, Object)} or {@link #update(String, Object)} the given instance, depending upon resolution of the unsaved-value checks (see the manual for discussion of unsaved-value checking). This operation cascades to associated instances if the association is mapped with {@code cascade=\"save-update\"}",
        "class": "Concrete implementation of a Session. Exposes two interfaces: {@link org.hibernate.Session} to the application {@link org.hibernate.engine.spi.SessionImplementor} to other Hibernate components (SPI) This class is not thread-safe."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.hibernate.internal.SessionImpl.saveOrUpdate",
      "jar": "hibernate-core-5.2.10.Final.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.Object"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Replaces the entry for a key only if currently mapped to some value. This is equivalent to  {@code\n if (map.containsKey(key)) {\n   return map.put(key, value);\n } else\n   return null;\n } except that the action is performed atomically.",
        "class": "An advanced hash table supporting configurable garbage collection semantics of keys and values, optional referential-equality, full concurrency of retrievals, and adjustable expected concurrency for updates. This table is designed around specific advanced use-cases. If there is any doubt whether this table is for you, you most likely should be using {@link java.util.concurrent.ConcurrentHashMap} instead. This table supports strong, weak, and soft keys and values. By default keys are weak, and values are strong. Such a configuration offers similar behavior to {@link java.util.WeakHashMap}, entries of this table are periodically removed once their corresponding keys are no longer referenced outside of this table. In other words, this table will not prevent a key from being discarded by the garbage collector. Once a key has been discarded by the collector, the corresponding entry is no longer visible to this table; however, the entry may occupy space until a future table operation decides to reclaim it. For this reason, summary functions such as {@code size} and {@code isEmpty} might return a value greater than the observed number of entries. In order to support a high level of concurrency, stale entries are only reclaimed during blocking (usually mutating) operations. Enabling soft keys allows entries in this table to remain until their space is absolutely needed by the garbage collector. This is unlike weak keys which can be reclaimed as soon as they are no longer referenced by a normal strong reference. The primary use case for soft keys is a cache, which ideally occupies memory that is not in use for as long as possible. By default, values are held using a normal strong reference. This provides the commonly desired guarantee that a value will always have at least the same life-span as it's key. For this reason, care should be taken to ensure that a value never refers, either directly or indirectly, to its key, thereby preventing reclamation. If this is unavoidable, then it is recommended to use the same reference type in use for the key. However, it should be noted that non-strong values may disappear before their corresponding key. While this table does allow the use of both strong keys and values, it is recommended to use {@link java.util.concurrent.ConcurrentHashMap} for such a configuration, since it is optimized for that case. Just like {@link java.util.concurrent.ConcurrentHashMap}, this class obeys the same functional specification as {@link java.util.Hashtable}, and includes versions of methods corresponding to each method of {@code Hashtable}. However, even though all operations are thread-safe, retrieval operations do not entail locking, and there is not any support for locking the entire table in a way that prevents all access. This class is fully interoperable with {@code Hashtable} in programs that rely on its thread safety but not on its synchronization details. Retrieval operations (including {@code get}) generally do not block, so may overlap with update operations (including {@code put} and {@code remove}). Retrievals reflect the results of the most recently completed update operations holding upon their onset. For aggregate operations such as {@code putAll} and {@code clear}, concurrent retrievals may reflect insertion or removal of only some entries. Similarly, Iterators and Enumerations return elements reflecting the state of the hash table at some point at or since the creation of the iterator\/enumeration. They do not throw {@link ConcurrentModificationException}. However, iterators are designed to be used by only one thread at a time. The allowed concurrency among update operations is guided by the optional {@code concurrencyLevel} constructor argument (default {@code 16}), which is used as a hint for internal sizing. The table is internally partitioned to try to permit the indicated number of concurrent updates without contention. Because placement in hash tables is essentially random, the actual concurrency will vary. Ideally, you should choose a value to accommodate as many threads as will ever concurrently modify the table. Using a significantly higher value than you need can waste space and time, and a significantly lower value can lead to thread contention. But overestimates and underestimates within an order of magnitude do not usually have much noticeable impact. A value of one is appropriate when it is known that only one thread will modify and all others will only read. Also, resizing this or any other kind of hash table is a relatively slow operation, so, when possible, it is a good idea to provide estimates of expected table sizes in constructors. This class and its views and iterators implement all of the optional methods of the {@link Map} and {@link Iterator} interfaces. Like {@link Hashtable} but unlike {@link HashMap}, this class does not allow {@code null} to be used as a key or value. This class is a member of the Java Collections Framework."
      },
      "framework": "hibernate",
      "discovery": "manual",
      "name": "org.hibernate.validator.internal.util.ConcurrentReferenceHashMap.replace",
      "jar": null,
      "comment": "Counter example for sanitizer",
      "parameters": [
        "java.lang.Object",
        "java.lang.Object"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [
          0,
          1,
          0,
          1
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Creates a random access file stream to read from, and optionally to write to, the file specified by the {@link File} argument. A new {@link FileDescriptor} object is created to represent this file connection. The mode argument specifies the access mode in which the file is to be opened. The permitted values and their meanings are: Value Meaning \"r\" Open for reading only. Invoking any of the write methods of the resulting object will cause an {@link java.io.IOException} to be thrown. \"rw\" Open for reading and writing. If the file does not already exist then an attempt will be made to create it. \"rws\" Open for reading and writing, as with \"rw\", and also require that every update to the file's content or metadata be written synchronously to the underlying storage device. \"rwd\" Open for reading and writing, as with \"rw\", and also require that every update to the file's content be written synchronously to the underlying storage device. The \"rws\" and \"rwd\" modes work much like the {@link java.nio.channels.FileChannel#force(boolean) force(boolean)} method of the {@link java.nio.channels.FileChannel} class, passing arguments of true and false, respectively, except that they always apply to every I\/O operation and are therefore often more efficient. If the file resides on a local storage device then when an invocation of a method of this class returns it is guaranteed that all changes made to the file by that invocation will have been written to that device. This is useful for ensuring that critical information is not lost in the event of a system crash. If the file does not reside on a local device then no such guarantee is made. The \"rwd\" mode can be used to reduce the number of I\/O operations performed. Using \"rwd\" only requires updates to the file's content to be written to storage; using \"rws\" requires updates to both the file's content and its metadata to be written, which generally requires at least one more low-level I\/O operation. If there is a security manager, its {@code checkRead} method is called with the pathname of the {@code file} argument as its argument to see if read access to the file is allowed. If the mode allows writing, the security manager's {@code checkWrite} method is also called with the path argument to see if write access to the file is allowed.",
        "class": "Instances of this class support both reading and writing to a random access file. A random access file behaves like a large array of bytes stored in the file system. There is a kind of cursor, or index into the implied array, called the file pointer; input operations read bytes starting at the file pointer and advance the file pointer past the bytes read. If the random access file is created in read\/write mode, then output operations are also available; output operations write bytes starting at the file pointer and advance the file pointer past the bytes written. Output operations that write past the current end of the implied array cause the array to be extended. The file pointer can be read by the {@code getFilePointer} method and set by the {@code seek} method. It is generally true of all the reading routines in this class that if end-of-file is reached before the desired number of bytes has been read, an {@code EOFException} (which is a kind of {@code IOException}) is thrown. If any byte cannot be read for any reason other than end-of-file, an {@code IOException} other than {@code EOFException} is thrown. In particular, an {@code IOException} may be thrown if the stream has been closed."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.RandomAccessFile.<init>",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.io.File",
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getRequestURL() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getRequestURL",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.StringBuffer",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getRequestURI() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getRequestURI",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Gets the current value of this Cookie.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.getValue",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to call setDateHeader(String name, long date) on the wrapped response object.",
        "class": "Provides a convenient implementation of the HttpServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletResponseWrapper.setDateHeader",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "long"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/hc.apache.org\/httpclient-3.x\/apidocs\/org\/apache\/commons\/httpclient\/auth\/HttpAuthenticator.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Attempt to provide default authentication credentials to the given method in the given context using basic authentication scheme.",
        "class": "Utility methods for HTTP authorization and authentication. This class provides utility methods for generating responses to HTTP www and proxy authentication challenges. A client SHOULD assume that all paths at or deeper than the depth of the last symbolic element in the path field of the Request-URI also are within the protection space specified by the basic realm value of the current challenge. A client MAY preemptively send the corresponding Authorization header with requests for resources in that space without receipt of another challenge from the server. Similarly, when a client sends a request to a proxy, it may reuse a userid and password in the Proxy-Authorization header field without receiving another challenge from the proxy server."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.commons.httpclient.auth.HttpAuthenticator.authenticateDefault",
      "jar": null,
      "comment": "Depricated method. The credentials are provided in the HttpState. The authentication is added to the header of the HttpMethod.",
      "parameters": [
        "org.apache.commons.httpclient.HttpMethod",
        "org.apache.commons.httpclient.HttpConnection",
        "org.apache.commons.httpclient.HttpState"
      ],
      "return": "boolean",
      "dataIn": {
        "parameters": [
          2,
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to call getAttribute(String name) on the wrapped request object.",
        "class": "Provides a convenient implementation of the ServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.ServletRequestWrapper.getAttribute",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.Object",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.oracle.com\/javaee\/6\/api\/javax\/servlet\/http\/HttpServletResponseWrapper.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE601"
      ],
      "javadoc": {
        "method": "The default behavior of this method is to return sendRedirect(String location) on the wrapped response object.",
        "class": "Provides a convenient implementation of the HttpServletResponse interface that can be subclassed by developers wishing to adapt the response from a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped response object."
      },
      "framework": "javageneral",
      "discovery": "manual",
      "name": "javax.servlet.http.HttpServletResponseWrapper.sendRedirect",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/core\/authority\/mapping\/SimpleAttributes2GrantedAuthoritiesMapper.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "This class implements the Attributes2GrantedAuthoritiesMapper interface by doing a one-to-one mapping from roles to Spring Security GrantedAuthorities. Optionally a prefix can be added, and the attribute name can be converted to upper or lower case. By default, the attribute is prefixed with \"ROLE_\" unless it already starts with \"ROLE_\", and no case conversion is done."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.core.authority.mapping.SimpleAttributes2GrantedAuthoritiesMapper.isConvertAttributeToUpperCase",
      "jar": null,
      "comment": "Counter example for authentication (none)",
      "parameters": [],
      "return": "boolean",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/OWASP\/java-html-sanitizer\/blob\/master\/src\/main\/java\/org\/owasp\/html\/HtmlSanitizer.java",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE306",
        "CWE079"
      ],
      "javadoc": {
        "method": "",
        "class": "Consumes an HTML stream, and dispatches events to a policy object which decides which elements and attributes to allow."
      },
      "framework": "generaljava",
      "discovery": "manual",
      "name": "org.owasp.html.HtmlSanitizer.stripQuotes",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Encode data for use in an XML attribute. The implementation should follow the XML Encoding Standard from the W3C. The use of a real XML parser is highly encouraged. However, in the hopefully rare case that you need to make sure that data is safe for inclusion in an XML document and cannot use a parse, this method provides a safe mechanism to do so.",
        "class": "Reference implementation of the Encoder interface. This implementation takes a whitelist approach to encoding, meaning that everything not specifically identified in a list of \"immune\" characters is encoded."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.esapi.reference.DefaultEncoder.encodeForXMLAttribute",
      "jar": "esapi-2.0_rc10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/crypto\/codec\/Utf8.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "Get the bytes of the String in UTF-8 encoded form.",
        "class": "UTF-8 Charset encoder\/decoder. For internal use only."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.crypto.codec.Utf8.encode",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.CharSequence"
      ],
      "return": "byte[]",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/test\/context\/junit4\/SpringJUnit4ClassRunner.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Perform the same logic as {@link BlockJUnit4ClassRunner#runChild(FrameworkMethod, RunNotifier)}, except that tests are determined to be ignored by {@link #isTestMethodIgnored(FrameworkMethod)}.",
        "class": "{@code SpringJUnit4ClassRunner} is a custom extension of JUnit's {@link BlockJUnit4ClassRunner} which provides functionality of the Spring TestContext Framework to standard JUnit tests by means of the {@link TestContextManager} and associated support classes and annotations. To use this class, simply annotate a JUnit 4 based test class with {@code @RunWith(SpringJUnit4ClassRunner.class)} or {@code @RunWith(SpringRunner.class)}. The following list constitutes all annotations currently supported directly or indirectly by {@code SpringJUnit4ClassRunner}. (Note that additional annotations may be supported by various {@link org.springframework.test.context.TestExecutionListener TestExecutionListener} or {@link org.springframework.test.context.TestContextBootstrapper TestContextBootstrapper} implementations.) {@link Test#expected() @Test(expected=...)} {@link Test#timeout() @Test(timeout=...)} {@link org.springframework.test.annotation.Timed @Timed} {@link org.springframework.test.annotation.Repeat @Repeat} {@link Ignore @Ignore} {@link org.springframework.test.annotation.ProfileValueSourceConfiguration @ProfileValueSourceConfiguration} {@link org.springframework.test.annotation.IfProfileValue @IfProfileValue} If you would like to use the Spring TestContext Framework with a runner other than this one, use {@link SpringClassRule} and {@link SpringMethodRule}. NOTE: As of Spring Framework 4.3, this class requires JUnit 4.12 or higher."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.junit.runners.model.FrameworkMethod",
        "org.junit.runner.notification.RunNotifier"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Constructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.",
        "class": "Convenience class for writing character files. The constructors of this class assume that the default character encoding and the default byte-buffer size are acceptable. To specify these values yourself, construct an OutputStreamWriter on a FileOutputStream. Whether or not a file is available or may be created depends upon the underlying platform. Some platforms, in particular, allow a file to be opened for writing by only one FileWriter (or other file-writing object) at a time. In such situations the constructors in this class will fail if the file involved is already open. FileWriter is meant for writing streams of characters. For writing streams of raw bytes, consider using a FileOutputStream."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.FileWriter.<init>",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "boolean"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/4.3.9.RELEASE\/javadoc-api\/org\/springframework\/web\/socket\/handler\/ConcurrentWebSocketSessionDecorator.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Send a WebSocket message: either {@link TextMessage} or {@link BinaryMessage}.",
        "class": "Wrap a {@link org.springframework.web.socket.WebSocketSession WebSocketSession} to guarantee only one thread can send messages at a time. If a send is slow, subsequent attempts to send more messages from other threads will not be able to acquire the flush lock and messages will be buffered instead -- at that time, the specified buffer-size limit and send-time limit will be checked and the session closed if the limits are exceeded."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.handler.ConcurrentWebSocketSessionDecorator.sendMessage",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "org.springframework.web.socket.WebSocketMessage"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Specify default parameters for the type. This only applies to parameterized types.",
        "class": "Bean that encapsulates a Hibernate type definition. Typically defined as inner bean within a LocalSessionFactoryBean definition, as list element for the \"typeDefinitions\" bean property. For example:  \n   ...\n   \n     \n       \n         \n         \n       \n     \n   \n   ...\n  Alternatively, specify a bean id (or name) attribute for the inner bean, instead of the \"typeName\" property."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.orm.hibernate3.TypeDefinitionBean.setParameters",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.util.Properties"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getServletPath() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getServletPath",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/static.javadoc.io\/org.springframework\/spring\/2.0.4\/org\/springframework\/orm\/hibernate3\/LocalDataSourceConnectionProvider.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE089",
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "This implementation simply calls Connection.close.",
        "class": "Hibernate connection provider for local DataSource instances in an application context. This provider will be used if LocalSessionFactoryBean's \"dataSource\" property is set without a Hibernate TransactionManagerLookup."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.orm.hibernate3.LocalDataSourceConnectionProvider.closeConnection",
      "jar": null,
      "comment": "Puts the state of the program to unauthenticated.",
      "parameters": [
        "java.sql.Connection"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/4.3.9.RELEASE\/javadoc-api\/org\/springframework\/mock\/web\/MockHttpServletRequest.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Establish null as the value returned when  getUserPrincipal, getRemoteUser,  and getAuthType is called on the request.",
        "class": "Mock implementation of the {@link javax.servlet.http.HttpServletRequest} interface. The default, preferred {@link Locale} for the server mocked by this request is {@link Locale#ENGLISH}. This value can be changed via {@link #addPreferredLocale} or {@link #setPreferredLocales}. As of Spring Framework 4.0, this set of mocks is designed on a Servlet 3.0 baseline."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.mock.web.MockHttpServletRequest.logout",
      "jar": null,
      "comment": "Puts the program is an unauthenticated state.",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Remove a persistent instance from the datastore. The object argument may be an instance associated with the receiving Session or a transient instance with an identifier associated with existing persistent state. This operation cascades to associated instances if the association is mapped with {@code cascade=\"delete\"}",
        "class": "Concrete implementation of a Session. Exposes two interfaces: {@link org.hibernate.Session} to the application {@link org.hibernate.engine.spi.SessionImplementor} to other Hibernate components (SPI) This class is not thread-safe."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.hibernate.internal.SessionImpl.delete",
      "jar": "hibernate-core-5.2.10.Final.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.Object"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/autorepo\/docs\/spring-security\/3.2.1.RELEASE\/apidocs\/org\/springframework\/security\/crypto\/codec\/Base64.html",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "",
        "class": "Base64 encoder which is a reduced version of Robert Harder's public domain implementation (version 2.3.7). See http:\/\/iharder.net\/base64 for more information. For internal use only."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.crypto.codec.Base64.encodeBytesToBytes",
      "jar": null,
      "comment": "",
      "parameters": [
        "byte[]",
        "int",
        "int",
        "int"
      ],
      "return": "byte[]",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/docs.spring.io\/spring-security\/site\/docs\/current\/apidocs\/org\/springframework\/security\/config\/annotation\/web\/messaging\/MessageSecurityMetadataSourceRegistry.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": "Allows mapping security constraints using {@link MessageMatcher} to the security expressions."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.config.annotation.web.messaging.MessageSecurityMetadataSourceRegistry.hasAnyAuthority",
      "jar": null,
      "comment": "Counter example for sanitizer (has)",
      "parameters": [
        "java.lang.String[]"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "A convenience function that sanitizes a string of HTML.",
        "class": "A factory that can be used to link a sanitizer to an output receiver and that provides a convenient {@link PolicyFactory#sanitize sanitize} method and a {@link PolicyFactory#and and} method to compose policies."
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.owasp.html.PolicyFactory.sanitize",
      "jar": "owasp-java-html-sanitizer-r239.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Log a SEVERE message. If the logger is currently enabled for the SEVERE message level then the given message is forwarded to all the registered output Handler objects.",
        "class": "A Logger object is used to log messages for a specific system or application component. Loggers are normally named, using a hierarchical dot-separated namespace. Logger names can be arbitrary strings, but they should normally be based on the package name or class name of the logged component, such as java.net or javax.swing. In addition it is possible to create \"anonymous\" Loggers that are not stored in the Logger namespace. Logger objects may be obtained by calls on one of the getLogger factory methods. These will either create a new Logger or return a suitable existing Logger. It is important to note that the Logger returned by one of the {@code getLogger} factory methods may be garbage collected at any time if a strong reference to the Logger is not kept. Logging messages will be forwarded to registered Handler objects, which can forward the messages to a variety of destinations, including consoles, files, OS logs, etc. Each Logger keeps track of a \"parent\" Logger, which is its nearest existing ancestor in the Logger namespace. Each Logger has a \"Level\" associated with it. This reflects a minimum Level that this logger cares about. If a Logger's level is set to null, then its effective level is inherited from its parent, which may in turn obtain it recursively from its parent, and so on up the tree. The log level can be configured based on the properties from the logging configuration file, as described in the description of the LogManager class. However it may also be dynamically changed by calls on the Logger.setLevel method. If a logger's level is changed the change may also affect child loggers, since any child logger that has null as its level will inherit its effective level from its parent. On each logging call the Logger initially performs a cheap check of the request level (e.g., SEVERE or FINE) against the effective log level of the logger. If the request level is lower than the log level, the logging call returns immediately. After passing this initial (cheap) test, the Logger will allocate a LogRecord to describe the logging message. It will then call a Filter (if present) to do a more detailed check on whether the record should be published. If that passes it will then publish the LogRecord to its output Handlers. By default, loggers also publish to their parent's Handlers, recursively up the tree. Each Logger may have a {@code ResourceBundle} associated with it. The {@code ResourceBundle} may be specified by name, using the {@link #getLogger(java.lang.String, java.lang.String)} factory method, or by value - using the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method. This bundle will be used for localizing logging messages. If a Logger does not have its own {@code ResourceBundle} or resource bundle name, then it will inherit the {@code ResourceBundle} or resource bundle name from its parent, recursively up the tree. Most of the logger output methods take a \"msg\" argument. This msg argument may be either a raw value or a localization key. During formatting, if the logger has (or inherits) a localization {@code ResourceBundle} and if the {@code ResourceBundle} has a mapping for the msg string, then the msg string is replaced by the localized value. Otherwise the original msg string is used. Typically, formatters use java.text.MessageFormat style formatting to format parameters, so for example a format string \"{0} {1}\" would format two parameters as strings. A set of methods alternatively take a \"msgSupplier\" instead of a \"msg\" argument. These methods take a {@link Supplier}{@code } function which is invoked to construct the desired log message only when the message actually is to be logged based on the effective log level thus eliminating unnecessary message construction. For example, if the developer wants to log system health status for diagnosis, with the String-accepting version, the code would look like: \n\n   class DiagnosisMessages {\n     static String systemHealthStatus() {\n       \/\/ collect system health information\n       ...\n     }\n   }\n   ...\n   logger.log(Level.FINER, DiagnosisMessages.systemHealthStatus());\n With the above code, the health status is collected unnecessarily even when the log level FINER is disabled. With the Supplier-accepting version as below, the status will only be collected when the log level FINER is enabled. \n\n   logger.log(Level.FINER, DiagnosisMessages::systemHealthStatus);\n When looking for a {@code ResourceBundle}, the logger will first look at whether a bundle was specified using {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle}, and then only whether a resource bundle name was specified through the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. If no {@code ResourceBundle} or no resource bundle name is found, then it will use the nearest {@code ResourceBundle} or resource bundle name inherited from its parent tree. When a {@code ResourceBundle} was inherited or specified through the {@link #setResourceBundle(java.util.ResourceBundle) setResourceBundle} method, then that {@code ResourceBundle} will be used. Otherwise if the logger only has or inherited a resource bundle name, then that resource bundle name will be mapped to a {@code ResourceBundle} object, using the default Locale at the time of logging. When mapping resource bundle names to {@code ResourceBundle} objects, the logger will first try to use the Thread's {@linkplain java.lang.Thread#getContextClassLoader() context class loader} to map the given resource bundle name to a {@code ResourceBundle}. If the thread context class loader is {@code null}, it will try the {@linkplain java.lang.ClassLoader#getSystemClassLoader() system class loader} instead. If the {@code ResourceBundle} is still not found, it will use the class loader of the first caller of the {@link #getLogger(java.lang.String, java.lang.String) getLogger} factory method. Formatting (including localization) is the responsibility of the output Handler, which will typically call a Formatter. Note that formatting need not occur synchronously. It may be delayed until a LogRecord is actually written to an external sink. The logging methods are grouped in five main categories: There are a set of \"log\" methods that take a log level, a message string, and optionally some parameters to the message string. There are a set of \"logp\" methods (for \"log precise\") that are like the \"log\" methods, but also take an explicit source class name and method name. There are a set of \"logrb\" method (for \"log with resource bundle\") that are like the \"logp\" method, but also take an explicit resource bundle object for use in localizing the log message. There are convenience methods for tracing method entries (the \"entering\" methods), method returns (the \"exiting\" methods) and throwing exceptions (the \"throwing\" methods). Finally, there are a set of convenience methods for use in the very simplest cases, when a developer simply wants to log a simple string at a given log level. These methods are named after the standard Level names (\"severe\", \"warning\", \"info\", etc.) and take a single argument, a message string. For the methods that do not take an explicit source name and method name, the Logging framework will make a \"best effort\" to determine which class and method called into the logging method. However, it is important to realize that this automatically inferred information may only be approximate (or may even be quite wrong!). Virtual machines are allowed to do extensive optimizations when JITing and may entirely remove stack frames, making it impossible to reliably locate the calling class and method. All methods on Logger are multi-thread safe. Subclassing Information: Note that a LogManager class may provide its own implementation of named Loggers for any point in the namespace. Therefore, any subclasses of Logger (unless they are implemented in conjunction with a new LogManager class) should take care to obtain a Logger instance from the LogManager class and should delegate operations such as \"isLoggable\" and \"log(LogRecord)\" to that instance. Note that in order to intercept all logging output, subclasses need only override the log(LogRecord) method. All the other logging methods are implemented as calls on this log(LogRecord) method."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.util.logging.Logger.severe",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/github.com\/dmfs\/oauth2-essentials\/blob\/master\/src\/main\/java\/org\/dmfs\/oauth2\/client\/BasicOAuth2ClientCredentials.java",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Authenticates the given request using the Basic authentication scheme.",
        "class": "Basic implementation of {@link OAuth2ClientCredentials}."
      },
      "framework": "oauth2essentials",
      "discovery": "manual",
      "name": "org.dmfs.oauth2.client.BasicOAuth2ClientCredentials.authenticatedRequest",
      "jar": null,
      "comment": "Sends an authentication request.",
      "parameters": [
        "org.dmfs.httpclient.HttpRequest"
      ],
      "return": "org.dmfs.httpclient.HttpRequest",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/shiro.apache.org\/static\/1.2.6\/apidocs\/org\/apache\/shiro\/mgt\/DefaultSecurityManager.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "low",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Logs out the specified Subject from the system. Note that most application developers should not call this method unless they have a good reason for doing so. The preferred way to logout a Subject is to call {@link org.apache.shiro.subject.Subject#logout Subject.logout()}, not the {@code SecurityManager} directly. Framework developers on the other hand might find calling this method directly useful in certain cases.",
        "class": "The Shiro framework's default concrete implementation of the {@link SecurityManager} interface, based around a collection of {@link org.apache.shiro.realm.Realm}s. This implementation delegates its authentication, authorization, and session operations to wrapped {@link Authenticator}, {@link Authorizer}, and {@link org.apache.shiro.session.mgt.SessionManager SessionManager} instances respectively via superclass implementation. To greatly reduce and simplify configuration, this implementation (and its superclasses) will create suitable defaults for all of its required dependencies, except the required one or more {@link Realm Realm}s. Because {@code Realm} implementations usually interact with an application's data model, they are almost always application specific; you will want to specify at least one custom {@code Realm} implementation that 'knows' about your application's data\/security model (via {@link #setRealm} or one of the overloaded constructors). All other attributes in this class hierarchy will have suitable defaults for most enterprise applications. RememberMe notice: This class supports the ability to configure a {@link #setRememberMeManager RememberMeManager} for {@code RememberMe} identity services for login\/logout, BUT, a default instance will not be created for this attribute at startup. Because RememberMe services are inherently client tier-specific and therefore aplication-dependent, if you want {@code RememberMe} services enabled, you will have to specify an instance yourself via the {@link #setRememberMeManager(RememberMeManager) setRememberMeManager} mutator. However if you're reading this JavaDoc with the expectation of operating in a Web environment, take a look at the {@code org.apache.shiro.web.DefaultWebSecurityManager} implementation, which does support {@code RememberMe} services by default at startup."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.shiro.mgt.DefaultSecurityManager.logout",
      "jar": null,
      "comment": "Logout the specified subject.",
      "parameters": [
        "org.apache.shiro.subject.Subject"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE089"
      ],
      "javadoc": {
        "method": "Used during \"compiling\" a JPA criteria query.",
        "class": "Concrete implementation of a Session. Exposes two interfaces: {@link org.hibernate.Session} to the application {@link org.hibernate.engine.spi.SessionImplementor} to other Hibernate components (SPI) This class is not thread-safe."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.hibernate.internal.SessionImpl.createQuery",
      "jar": "hibernate-core-5.2.10.Final.jar",
      "comment": "",
      "parameters": [
        "java.lang.String",
        "java.lang.Class",
        "javax.persistence.criteria.Selection",
        "org.hibernate.jpa.spi.HibernateEntityManagerImplementor$QueryOptions"
      ],
      "return": "org.hibernate.query.spi.QueryImplementor",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Replace escaped hex digits with the equivalent binary representation. Assume either V2 or V3 escape mechanisms: V2: \\*, \\(, \\), \\\\. V3: \\2A, \\28, \\29, \\5C, \\00.",
        "class": "Represents an LDAP Filter. This filter object can be created from a String or can be built up programatically by adding filter components one at a time. Existing filter components can be iterated though. Each filter component has an integer identifier defined in this class. The following are basic filter components: {@link #EQUALITY_MATCH}, {@link #GREATER_OR_EQUAL}, {@link #LESS_OR_EQUAL}, {@link #SUBSTRINGS}, {@link #PRESENT}, {@link #APPROX_MATCH}, {@link #EXTENSIBLE_MATCH}. More filters can be nested together into more complex filters with the following filter components: {@link #AND}, {@link #OR}, {@link #NOT} Substrings can have three components:        Filter ::= CHOICE {\n               and             [0] SET OF Filter,\n               or              [1] SET OF Filter,\n               not             [2] Filter,\n               equalityMatch   [3] AttributeValueAssertion,\n               substrings      [4] SubstringFilter,\n               greaterOrEqual  [5] AttributeValueAssertion,\n               lessOrEqual     [6] AttributeValueAssertion,\n               present         [7] AttributeDescription,\n               approxMatch     [8] AttributeValueAssertion,\n               extensibleMatch [9] MatchingRuleAssertion }"
      },
      "framework": "ldap",
      "discovery": "manual",
      "name": "com.novell.ldap.rfc2251.RfcFilter.unescapeString",
      "jar": null,
      "comment": "Counter example for sanitizer (unescape)",
      "parameters": [
        "java.lang.String"
      ],
      "return": "byte[]",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/xml.apache.org\/xalan-j\/apidocs\/org\/apache\/xpath\/jaxp\/XPathImpl.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE078"
      ],
      "javadoc": {
        "method": "Compile an XPath expression for later evaluation. If expression contains any {@link XPathFunction}s, they must be available via the {@link XPathFunctionResolver}. An {@link XPathExpressionException} will be thrown if the XPathFunction cannot be resovled with the XPathFunctionResolver. If expression is null, a NullPointerException is thrown.",
        "class": "The XPathImpl class provides implementation for the methods defined in javax.xml.xpath.XPath interface. This provide simple access to the results of an XPath expression."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xpath.jaxp.XPathImpl.compile",
      "jar": null,
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "javax.xml.xpath.XPathExpression",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "http:\/\/docs.spring.io\/autorepo\/docs\/spring-security\/3.1.8.CI-SNAPSHOT\/apidocs\/org\/springframework\/security\/authentication\/RememberMeAuthenticationProvider.html",
      "type": [
        "authentication"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE863",
        "CWE306",
        "CWE862"
      ],
      "javadoc": {
        "method": "Performs authentication with the same contract as {@link org.springframework.security.authentication.AuthenticationManager#authenticate(Authentication)} .",
        "class": "An {@link AuthenticationProvider} implementation that validates {@link RememberMeAuthenticationToken}s. To be successfully validated, the {@link RememberMeAuthenticationToken#getKeyHash()} must match this class' {@link #getKey()}."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.security.authentication.RememberMeAuthenticationProvider.authenticate",
      "jar": null,
      "comment": "The input object is authenticated and returned.",
      "parameters": [
        "org.springframework.security.core.Authentication"
      ],
      "return": "org.springframework.security.core.Authentication",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring-framework\/docs\/current\/javadoc-api\/org\/springframework\/mock\/web\/MockJspWriter.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Print a String and then terminate the line. This method behaves as though it invokes {@link #print(String)} and then {@link #println()}.",
        "class": "Mock implementation of the {@link javax.servlet.jsp.JspWriter} class. Used for testing the web framework; only necessary for testing applications when testing custom JSP tags."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.mock.web.MockJspWriter.println",
      "jar": null,
      "comment": "Sink",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Returns the contents of the file item as a String, using the default character encoding. This method uses {@link #get()} to retrieve the contents of the item.",
        "class": "An adapter of Servlet 3.0 {@link Part} to Apache Commons FileUpload's {@link FileItem}"
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.servlet.ServletPartFileItem.getString",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "The default behavior of this method is to return getQueryString() on the wrapped request object.",
        "class": "Provides a convenient implementation of the HttpServletRequest interface that can be subclassed by developers wishing to adapt the request to a Servlet. This class implements the Wrapper or Decorator pattern. Methods default to calling through to the wrapped request object."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.HttpServletRequestWrapper.getQueryString",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "",
      "discovery": "find-sec-bugs",
      "name": "org.apache.wicket.protocol.http.ClientProperties.getNavigatorAppName",
      "jar": "wicket-core-7.8.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/xalan.apache.org\/xalan-j\/apidocs\/org\/apache\/xalan\/templates\/ElemTemplateElement.html",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Replace the old child with a new child.",
        "class": "An instance of this class represents an element inside an xsl:template class. It has a single \"execute\" method which is expected to perform the given action on the result tree. This class acts like a Element node, and implements the Element interface, but is not a full implementation of that interface... it only implements enough for basic traversal of the tree."
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xalan.templates.ElemTemplateElement.replaceChild",
      "jar": null,
      "comment": "Counter example for sanitizer (replace but for Nodes only)",
      "parameters": [
        "org.w3c.dom.Node",
        "org.w3c.dom.Node"
      ],
      "return": "org.w3c.dom.Node",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/spring-projects\/spring-framework\/blob\/master\/spring-websocket\/src\/main\/java\/org\/springframework\/web\/socket\/config\/HandlersBeanDefinitionParser.java",
      "type": [
        "sink",
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE601"
      ],
      "javadoc": {
        "method": "Parse the specified {@link org.w3c.dom.Element} and register the resulting {@link BeanDefinition BeanDefinition(s)} with the {@link org.springframework.beans.factory.xml.ParserContext#getRegistry() BeanDefinitionRegistry} embedded in the supplied {@link ParserContext}. Implementations must return the primary {@link BeanDefinition} that results from the parse if they will ever be used in a nested fashion (for example as an inner tag in a {@code } tag). Implementations may return {@code null} if they will not be used in a nested fashion.",
        "class": "Parses the configuration for the {@code websocket:handlers} namespace element. Registers a Spring MVC {@code SimpleUrlHandlerMapping} to map HTTP WebSocket handshake (or SockJS) requests to {@link org.springframework.web.socket.WebSocketHandler WebSocketHandler}s."
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.web.socket.config.HandlersBeanDefinitionParser.parse",
      "jar": null,
      "comment": "Source training set",
      "parameters": [
        "org.w3c.dom.Element",
        "org.springframework.beans.factory.xml.ParserContext"
      ],
      "return": "org.springframework.beans.factory.config.BeanDefinition",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Read a line of text. Whenever a line terminator is read the current line number is incremented.",
        "class": "A buffered character-input stream that keeps track of line numbers. This class defines methods {@link #setLineNumber(int)} and {@link #getLineNumber()} for setting and getting the current line number respectively. By default, line numbering begins at 0. This number increments at every line terminator as the data is read, and can be changed with a call to setLineNumber(int). Note however, that setLineNumber(int) does not actually change the current position in the stream; it only changes the value that will be returned by getLineNumber(). A line is considered to be terminated by any one of a line feed ('\\n'), a carriage return ('\\r'), or a carriage return followed immediately by a linefeed."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "java.io.LineNumberReader.readLine",
      "jar": "java-rt-jar-stubs-1.5.0.jar",
      "comment": "",
      "parameters": [],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "https:\/\/github.com\/scribejava\/scribejava\/blob\/master\/scribejava-core\/src\/main\/java\/com\/github\/scribejava\/core\/oauth\/OAuth20Service.java",
      "type": [
        "authentication",
        "sink"
      ],
      "securityLevel": "high",
      "cwe": [
        "CWE306"
      ],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "scribejava",
      "discovery": "manual",
      "name": "com.github.scribejava.core.oauth.OAuth20Service.sendAccessTokenRequestSync",
      "jar": null,
      "comment": "Returns a tocken for the given request.",
      "parameters": [
        "com.github.scribejava.core.model.OAuthRequest"
      ],
      "return": "com.github.scribejava.core.model.OAuth2AccessToken",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sink"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Specifies the domain within which this cookie should be presented. The form of the domain name is specified by RFC 2109. A domain name begins with a dot (.foo.com) and means that the cookie is visible to servers in a specified Domain Name System (DNS) zone (for example, www.foo.com, but not a.b.foo.com). By default, cookies are only returned to the server that sent them.",
        "class": "Creates a cookie, a small amount of information sent by a servlet to a Web browser, saved by the browser, and later sent back to the server. A cookie's value can uniquely identify a client, so cookies are commonly used for session management. A cookie has a name, a single value, and optional attributes such as a comment, path and domain qualifiers, a maximum age, and a version number. Some Web browsers have bugs in how they handle the optional attributes, so use them sparingly to improve the interoperability of your servlets. The servlet sends cookies to the browser by using the {@link HttpServletResponse#addCookie} method, which adds fields to HTTP response headers to send cookies to the browser, one at a time. The browser is expected to support 20 cookies for each Web server, 300 cookies total, and may limit cookie size to 4 KB each. The browser returns cookies to the servlet by adding fields to HTTP request headers. Cookies can be retrieved from a request by using the {@link HttpServletRequest#getCookies} method. Several cookies might have the same name but different path attributes. Cookies affect the caching of the Web pages that use them. HTTP 1.0 does not cache pages that use cookies created with this class. This class does not support the cache control defined with HTTP 1.1. This class supports both the Version 0 (by Netscape) and Version 1 (by RFC 2109) cookie specifications. By default, cookies are created using Version 0 to ensure the best interoperability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "javax.servlet.http.Cookie.setDomain",
      "jar": "tomcat-5.5-servlet-api.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "https:\/\/docs.spring.io\/spring\/docs\/current\/javadoc-api\/org\/springframework\/jdbc\/object\/RdbmsOperation.html",
      "type": [],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "",
        "class": ""
      },
      "framework": "spring",
      "discovery": "manual",
      "name": "org.springframework.jdbc.object.RdbmsOperation.setQueryTimeout",
      "jar": null,
      "comment": "Counter example for cwe089",
      "parameters": [
        "int"
      ],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": true
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE862"
      ],
      "javadoc": {
        "method": "",
        "class": "Provides the Application Default Credential from the environment. An instance represents the per-process state used to get and cache the credential and allows overriding the state and environment for testing purposes."
      },
      "framework": "oauth",
      "discovery": "manual",
      "name": "com.google.auth.oauth2.DefaultCredentialsProvider.getWellKnownCredentialsFile",
      "jar": null,
      "comment": "Source training set",
      "parameters": [],
      "return": "java.io.File",
      "dataIn": {
        "parameters": [
          0
        ],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "This method encodes for JavaScript strings contained within a JavaScript or JSON file. This method is NOT safe for use in ANY context embedded in HTML. The caller must provide the surrounding quotation characters. This method performs the same encode as {@link #forJavaScript(String)} with the exception that \/ and & are not escaped and \" and ' are encoded as \\\" and \\' respectively. Unless you are interested in saving a few bytes of output or are writing a framework on top of this library, it is recommend that you use {@link #forJavaScript(String)} over this method. Example JSP Usage: This example is serving up JavaScript source directly:     \n    var data = \"\";\n This example is serving up JSON data (users of this use-case are encouraged to read up on \"JSON Hijacking\"):     \n    \n    {\"data\":\"\"}",
        "class": "Encode -- fluent interface for contextual encoding. Example usage in a JSP:      \" \/>\n There are two versions of each contextual encoding method. The first takes a {@code String} argument and returns the encoded version as a {@code String}. The second version writes the encoded version directly to a {@code Writer}. Please make sure to read and understand the context that the method encodes for. Encoding for the incorrect context will likely lead to exposing a cross-site scripting vulnerability."
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.owasp.encoder.Encode.forJavaScriptSource",
      "jar": "encoder-1.2.1.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "source"
      ],
      "securityLevel": "none",
      "cwe": [
        "CWE079",
        "CWE601"
      ],
      "javadoc": {
        "method": "",
        "class": "Stub implementation of a {@link javax.servlet.http.HttpServletRequest} with lots of unimplemented methods. I implemented only those, which are required for testing the {@link org.apache.xmlrpc.webserver.XmlRpcServlet}. Perhaps someone else is adding more at a later time?"
      },
      "framework": "apache",
      "discovery": "manual",
      "name": "org.apache.xmlrpc.webserver.HttpServletRequestImpl.parseParameters",
      "jar": null,
      "comment": "Source training set",
      "parameters": [],
      "return": "void",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    },
    {
      "dataOut": {
        "parameters": [],
        "return": false
      },
      "link": "",
      "type": [
        "sanitizer"
      ],
      "securityLevel": "none",
      "cwe": [],
      "javadoc": {
        "method": "Escapes the characters in a {@code String} using XML entities. For example: {@code \"bread\" & \"butter\"} => {@code \"bread\" & \"butter\"}. Supports only the five basic XML entities (gt, lt, quot, amp, apos). Does not support DTDs or external entities. Note that Unicode characters greater than 0x7f are as of 3.0, no longer escaped. If you still wish this functionality, you can achieve it via the following: {@code StringEscapeUtils.ESCAPE_XML.with( NumericEntityEscaper.between(0x7f, Integer.MAX_VALUE) );}",
        "class": "Escapes and unescapes {@code String}s for Java, Java Script, HTML and XML. #ThreadSafe#"
      },
      "framework": "",
      "discovery": "thecodemaster.com",
      "name": "org.apache.commons.lang3.StringEscapeUtils.escapeXml",
      "jar": "commons-lang3-3.10.jar",
      "comment": "",
      "parameters": [
        "java.lang.String"
      ],
      "return": "java.lang.String",
      "dataIn": {
        "parameters": [],
        "return": false
      }
    }
  ]
}