{"cwes":[
  {
    "ID": 120,
    "Name": "Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')",
    "Weakness Abstraction": "Base",
    "Status": "Incomplete",
    "Description": "The program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
    "Extended Description": "A buffer overflow condition exists when a program attempts to put more data in a buffer than it can hold, or when a program attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the classic case in which the program copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:699:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:123:VIEW ID:1000::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::",
    "Weakness Ordinalities": "::ORDINALITY:Resultant:DESCRIPTION:::ORDINALITY:Primary:DESCRIPTION:::",
    "Applicable Platforms": "::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined:::LANGUAGE CLASS:Assembly:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "::TERM:buffer overrun:DESCRIPTION:Some prominent vendors and researchers use the term buffer overrun, but most people use buffer overflow.::TERM:Unbounded Transfer:DESCRIPTION:::",
    "Modes Of Introduction": ":::PHASE:Implementation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:TECHNICAL IMPACT:Execute Unauthorized Code or Commands:NOTE:Integrity Confidentiality Availability Execute Unauthorized Code or Commands Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. This can often be used to subvert any other security service.::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU):NOTE:Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::",
    "Detection Methods": "::METHOD:Automated Static Analysis:EFFECTIVENESS:High:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS::DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections)::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::",
    "Potential Mitigations": "::PHASE:Requirements:STRATEGY:Language Selection:EFFECTIVENESS::DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].::PHASE:Build and Compilation Operation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.::PHASE:Implementation:STRATEGY::EFFECTIVENESS:Moderate:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:EFFECTIVENESS::DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:EFFECTIVENESS:Limited:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system\n129,",
    "Observed Examples": "Base",
    "Functional Areas": "Draft",
    "Affected Resources": "The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.",
    "Taxonomy Mappings": "",
    "Related Attack Patterns": "::NATURE:ChildOf:CWE ID:20:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:1003:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:119:VIEW ID:1000::NATURE:CanPrecede:CWE ID:823:VIEW ID:1000::NATURE:CanPrecede:CWE ID:789:VIEW ID:1000::",
    "Notes": "::ORDINALITY:Resultant:DESCRIPTION:The most common condition situation leading to an out-of-bounds array index is the use of loop index variables as buffer indexes. If the end condition for the loop is subject to a flaw, the index can grow or shrink unbounded, therefore causing a buffer overflow or underflow. Another common situation leading to this condition is the use of a function's return value, or the resulting value of a calculation directly as an index in to a buffer.::"
  },
  {
    "ID": 209,
    "Name": "Information Exposure Through an Error Message",
    "Weakness Abstraction": "Base",
    "Status": "Draft",
    "Description": "The software generates an error message that includes sensitive information about its environment, users, or associated data.",
    "Extended Description": "The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. If an attack fails, an attacker may use error information provided by the server to launch another more focused attack. For example, an attempt to exploit a path traversal weakness (CWE-22) might yield the full pathname of the installed application. In turn, this could be used to select the proper number of .. sequences to navigate to the targeted file. An attack using SQL injection (CWE-89) might not initially succeed, but an error message could reveal the malformed query, which would expose query logic and possibly even passwords or other sensitive information used within the query.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:200:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:200:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:755:VIEW ID:1000::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": "::LANGUAGE NAME:PHP:LANGUAGE PREVALENCE:Often:::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION::::PHASE:System Configuration:DESCRIPTION::::PHASE:Operation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Application Data:NOTE:Confidentiality Read Application Data Often this will either reveal sensitive information which may be used for a later attack or private information stored in the server.::",
    "Detection Methods": "::METHOD:Manual Analysis:EFFECTIVENESS:High:DESCRIPTION:This weakness generally requires domain-specific interpretation using manual analysis. However, the number of potential error conditions may be too large to cover completely within limited time constraints.::METHOD:Automated Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:Automated methods may be able to detect certain idioms automatically, such as exposed stack traces or pathnames, but violation of business rules or privacy requirements is not typically feasible.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Error conditions may be triggered with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior.::METHOD:Manual Dynamic Analysis:EFFECTIVENESS::DESCRIPTION:Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself.::",
    "Potential Mitigations": "::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Handle exceptions internally and do not display errors containing potentially sensitive information to a user.::PHASE:Implementation:STRATEGY:Attack Surface Reduction:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Use naming conventions and strong types to make it easier to spot when sensitive data is being used. When creating structures, objects, or other complex entities, separate the sensitive and non-sensitive data as much as possible.::PHASE:Implementation Build and Compilation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS::DESCRIPTION:Debugging information should not make its way into a production release.::PHASE:Implementation Build and Compilation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Debugging information should not make its way into a production release.::PHASE:System Configuration:STRATEGY::EFFECTIVENESS::DESCRIPTION:Where available, configure the environment to use less verbose error messages. For example, in PHP, disable the display_errors setting during configuration, or at runtime using the error_reporting() function.::PHASE:System Configuration:STRATEGY::EFFECTIVENESS::DESCRIPTION:Create default error pages or messages that do not leak any information.::",
    "Observed Examples": "::REFERENCE:CVE-2008-2049:DESCRIPTION:POP3 server reveals a password in an error message after multiple APOP commands are sent. Might be resultant from another weakness.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2049REFERENCE:CVE-2007-5172:DESCRIPTION:Program reveals password in error message if attacker can trigger certain database errors.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5172REFERENCE:CVE-2008-4638:DESCRIPTION:Composite: application running with high privileges allows user to specify a restricted file to process, which generates a parsing error that leaks the contents of the file.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4638REFERENCE:CVE-2008-1579:DESCRIPTION:Existence of user names can be determined by requesting a nonexistent blog and reading the error message.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1579REFERENCE:CVE-2007-1409:DESCRIPTION:Direct request to library file in web application triggers pathname leak in error message.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-1409REFERENCE:CVE-2008-3060:DESCRIPTION:Malformed input to login page causes leak of full path when IMAP call fails.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3060REFERENCE:CVE-2005-0603:DESCRIPTION:Malformed regexp syntax leads to information exposure in error message.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0603",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "TAXONOMY NAME:CLASP:ENTRY NAME:Accidental leaking of sensitive information through error messages::::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A6:ENTRY NAME:Information Leakage and Improper Error Handling:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A7:ENTRY NAME:Improper Error Handling:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A10:ENTRY NAME:Insecure Configuration Management:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:CERT Java Secure Coding:ENTRY ID:ERR01-J:ENTRY NAME:Do not allow exceptions to expose sensitive information::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP23:ENTRY NAME:Exposed Data::",
    "Related Attack Patterns": "::::::::::::",
    "Notes": ""
  },
  {
    "ID": 212,
    "Name": "Improper Cross-boundary Removal of Sensitive Data",
    "Weakness Abstraction": "Base",
    "Status": "Incomplete",
    "Description": "The software uses a resource that contains sensitive data, but it does not properly remove that data before it stores, transfers, or shares the resource with actors in another control sphere.",
    "Extended Description": "Resources that may contain sensitive data include documents, packets, messages, databases, etc. While this data may be useful to an individual user or small set of users who share the resource, it may need to be removed before the resource can be shared outside of the trusted group. The process of removal is sometimes called cleansing or scrubbing. For example, software that is used for editing documents might not remove sensitive data such as reviewer comments or the local pathname where the document is stored. Or, a proxy might not remove an internal IP address from headers before making an outgoing request to an Internet site.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:200:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:200:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:669:VIEW ID:1000::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION::::PHASE:Operation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Files or Directories Read Application Data:NOTE:Confidentiality Read Files or Directories Read Application Data Sensitive data may be exposed to an unauthorized actor in another control sphere. This may have a wide range of secondary consequences which will depend on what data is exposed. One possibility is the exposure of system data allowing an attacker to craft a specific, more effective attack.::",
    "Detection Methods": "",
    "Potential Mitigations": "::PHASE:Requirements:STRATEGY::EFFECTIVENESS::DESCRIPTION:Clearly specify which information should be regarded as private or sensitive, and require that the product offers functionality that allows the user to cleanse the sensitive information from the resource before it is published or exported to other parties.::PHASE:Architecture and Design:STRATEGY:Separation of Privilege:EFFECTIVENESS::DESCRIPTION:Compartmentalize the system to have safe areas where trust boundaries can be unambiguously drawn. Do not allow sensitive data to go outside of the trust boundary and always be careful when interfacing with a compartment outside of the safe area. Ensure that appropriate compartmentalization is built into the system design and that the compartmentalization serves to allow for and further reinforce privilege separation functionality. Architects and designers should rely on the principle of least privilege to decide when it is appropriate to use and to drop system privileges.::PHASE:Implementation:STRATEGY:Attack Surface Reduction:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Use naming conventions and strong types to make it easier to spot when sensitive data is being used. When creating structures, objects, or other complex entities, separate the sensitive and non-sensitive data as much as possible.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Avoid errors related to improper resource shutdown or release (CWE-404), which may leave the sensitive data within the resource if it is in an incomplete state.::",
    "Observed Examples": "::REFERENCE:CVE-2005-0406:DESCRIPTION:Some image editors modify a JPEG image, but the original EXIF thumbnail image is left intact within the JPEG. (Also an interaction error).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0406REFERENCE:CVE-2002-0704:DESCRIPTION:NAT feature in firewall leaks internal IP addresses in ICMP error messages.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0704",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "TAXONOMY NAME:PLOVER:ENTRY NAME:Cross-Boundary Cleansing Infoleak::",
    "Related Attack Patterns": "::::",
    "Notes": "TYPE:Relationship:NOTE:This entry is intended to be different from resultant information leaks, including those that occur from improper buffer initialization and reuse, improper encryption, interaction errors, and multiple interpretation errors. This entry could be regarded as a privacy leak, depending on the type of information that is leaked.::::TYPE:Relationship:NOTE:There is a close association between CWE-226 and CWE-212. The difference is partially that of perspective. CWE-226 is geared towards the final stage of the resource lifecycle, in which the resource is deleted, eliminated, expired, or otherwise released for reuse. Technically, this involves a transfer to a different control sphere, in which the original contents of the resource are no longer relevant. CWE-212, however, is intended for sensitive data in resources that are intentionally shared with others, so they are still active. This distinction is useful from the perspective of the CWE research view (CWE-1000).::::TYPE:Terminology:NOTE:The terms cleansing and scrubbing have multiple uses within computing. In information security, these are used for the removal of sensitive data, but they are also used for the modification of incoming/outgoing data so that it conforms to specifications.::"
  },
  {
    "ID": 22,
    "Name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
    "Weakness Abstraction": "Class",
    "Status": "Draft",
    "Description": "The software uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the software does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
    "Extended Description": "Many file operations are intended to take place within a restricted directory. By using special elements such as .. and / separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the ../ sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as /usr/local/bin, which may also be useful in accessing unexpected files. This is referred to as absolute path traversal. In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the software may add .txt to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:706:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:668:VIEW ID:1000::",
    "Weakness Ordinalities": "::ORDINALITY:Primary:DESCRIPTION:::ORDINALITY:Resultant:DESCRIPTION:::",
    "Applicable Platforms": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "::TERM:Directory traversal:DESCRIPTION:::TERM:Path traversal:DESCRIPTION:Path traversal is preferred over directory traversal, but both terms are attack-focused.::",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:TECHNICAL IMPACT:Execute Unauthorized Code or Commands:NOTE:Integrity Confidentiality Availability Execute Unauthorized Code or Commands The attacker may be able to create or overwrite critical files that are used to execute code, such as programs or libraries.::SCOPE:Integrity:TECHNICAL IMPACT:Modify Files or Directories:NOTE:Integrity Modify Files or Directories The attacker may be able to overwrite or create critical files, such as programs, libraries, or important data. If the targeted file is used for a security mechanism, then the attacker may be able to bypass that mechanism. For example, appending a new account at the end of a password file may allow an attacker to bypass authentication.::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Files or Directories:NOTE:Confidentiality Read Files or Directories The attacker may be able read the contents of unexpected files and expose sensitive data. If the targeted file is used for a security mechanism, then the attacker may be able to bypass that mechanism. For example, by reading a password file, the attacker could conduct brute force password guessing attacks in order to break into an account on the system.::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart:NOTE:Availability DoS: Crash, Exit, or Restart The attacker may be able to overwrite, delete, or corrupt unexpected critical files such as programs, libraries, or important data. This may prevent the software from working at all and in the case of a protection mechanisms such as authentication, it has the potential to lockout every user of the software.::",
    "Detection Methods": "::METHOD:Automated Static Analysis:EFFECTIVENESS:High:DESCRIPTION:Automated techniques can find areas where path traversal weaknesses exist. However, tuning or customization may be required to remove or de-prioritize path-traversal problems that are only exploitable by the software's administrator - or other privileged users - and thus potentially valid behavior or, at worst, a bug instead of a vulnerability.::METHOD:Manual Static Analysis:EFFECTIVENESS:High:DESCRIPTION:Manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all file access operations can be assessed within limited time constraints.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Web Application Scanner Web Services Scanner Database Scanners::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Fuzz Tester Framework-based Fuzzer::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::",
    "Potential Mitigations": "::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When validating filenames, use stringent whitelists that limit the character set to be used. If feasible, only allow a single . character in the filename to avoid weaknesses such as CWE-23, and exclude directory separators such as / to avoid CWE-36. Use a whitelist of allowable file extensions, which will help to avoid CWE-434. Do not rely exclusively on a filtering mechanism that removes potentially dangerous characters. This is equivalent to a blacklist, which may be incomplete (CWE-184). For example, filtering / is insufficient protection if the filesystem also supports the use of as a directory separator. Another possible error could occur when the filtering is applied in a way that still produces dangerous data (CWE-182). For example, if ../ sequences are removed from the .../...// string in a sequential fashion, two instances of ../ would be removed from the original string, but the remaining characters would still form the ../ string.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180). Make sure that the application does not decode the same input twice (CWE-174). Such errors could be used to bypass whitelist validation schemes by introducing dangerous inputs after they have been checked. Use a built-in path canonicalization function (such as realpath() in C) that produces the canonical version of the pathname, which effectively removes .. sequences and symbolic links (CWE-23, CWE-59). This includes: realpath() in C getCanonicalPath() in Java GetFullPath() in ASP.NET realpath() or abs_path() in Perl realpath() in PHP::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.::PHASE:Operation:STRATEGY:Firewall:EFFECTIVENESS:Moderate:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:EFFECTIVENESS::DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF-185] provide this capability.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:EFFECTIVENESS:Limited:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system\n250,",
    "Observed Examples": "Class",
    "Functional Areas": "Draft",
    "Affected Resources": "The software performs an operation at a privilege level that is higher than the minimum level required, which creates new weaknesses or amplifies the consequences of other weaknesses.",
    "Taxonomy Mappings": "New weaknesses can be exposed because running with extra privileges, such as root or Administrator, can disable the normal security checks being performed by the operating system or surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if they occur while operating at raised privileges. Privilege management functions can behave in some less-than-obvious ways, and they have different quirks on different platforms. These inconsistencies are particularly pronounced if you are transitioning from one non-root user to another. Signal handlers and spawned processes run at the privilege of the owning process, so if a process is running as root when a signal fires or a sub-process is executed, the signal handler or sub-process will operate with root privileges.",
    "Related Attack Patterns": "::NATURE:ChildOf:CWE ID:657:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:657:VIEW ID:699::NATURE:ChildOf:CWE ID:269:VIEW ID:1000::",
    "Notes": ""
  },
  {
    "ID": 327,
    "Name": "Use of a Broken or Risky Cryptographic Algorithm",
    "Weakness Abstraction": "Base",
    "Status": "Draft",
    "Description": "The use of a broken or risky cryptographic algorithm is an unnecessary risk that may result in the exposure of sensitive information.",
    "Extended Description": "The use of a non-standard algorithm is dangerous because a determined attacker may be able to break the algorithm and compromise whatever data has been protected. Well-known techniques may exist to break the algorithm.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:693:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:311:VIEW ID:1000::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "::Cryptographic algorithms are the methods by which data is scrambled. There are a small number of well-understood and heavily studied algorithms that should be used by most applications. It is quite difficult to produce a secure algorithm, and even high profile algorithms by accomplished cryptographic experts have been broken. Since the state of cryptography advances so rapidly, it is common for an algorithm to be considered unsafe even if it was once thought to be strong. This can happen when new attacks against the algorithm are discovered, or if computing power increases so much that the cryptographic algorithm no longer provides the amount of protection that was originally thought.::",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Application Data:NOTE:Confidentiality Read Application Data The confidentiality of sensitive data may be compromised by the use of a broken or risky cryptographic algorithm.::SCOPE:Integrity:TECHNICAL IMPACT:Modify Application Data:NOTE:Integrity Modify Application Data The integrity of sensitive data may be compromised by the use of a broken or risky cryptographic algorithm.::SCOPE:Accountability:SCOPE:Non-Repudiation:TECHNICAL IMPACT:Hide Activities:NOTE:Accountability Non-Repudiation Hide Activities If the cryptographic algorithm is used to ensure the identity of the source of the data (such as digital signatures), then a broken algorithm will compromise this scheme and the source of the data cannot be proven.::",
    "Detection Methods": "::METHOD:Automated Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:Automated methods may be useful for recognizing commonly-used libraries or features that have become obsolete.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis Binary / Bytecode simple extractor â€“ strings, ELF readers, etc.::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Man-in-the-middle attack tool Cost effective for partial coverage: Framework-based Fuzzer Automated Monitored Execution Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Automated Static Analysis:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::",
    "Potential Mitigations": "::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:When there is a need to store or transmit sensitive data, use strong, up-to-date cryptographic algorithms to encrypt that data. Select a well-vetted algorithm that is currently considered to be strong by experts in the field, and use well-tested implementations. As with all cryptographic mechanisms, the source code should be available for analysis. For example, US government systems require FIPS 140-2 certification. Do not develop custom or private cryptographic algorithms. They will likely be exposed to attacks that are well-understood by cryptographers. Reverse engineering techniques are mature. If the algorithm can be compromised if attackers find out how it works, then it is especially weak. Periodically ensure that the cryptography has not become obsolete. Some older algorithms, once thought to require a billion years of computing time, can now be broken in days or hours. This includes MD4, MD5, SHA1, DES, and other algorithms that were once regarded as strong. [REF-267]::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:Design the software so that one cryptographic algorithm can be replaced with another. This will make it easier to upgrade to stronger algorithms.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:Carefully manage and protect cryptographic keys (see CWE-320). If the keys can be guessed or stolen, then the strength of the cryptography itself is irrelevant.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Industry-standard implementations will save development time and may be more likely to avoid errors that can occur during implementation of cryptographic algorithms. Consider the ESAPI Encryption feature.::PHASE:Implementation Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:When using industry-approved techniques, use them correctly. Don't cut corners by skipping resource-intensive steps (CWE-325). These steps are often essential for preventing common attacks.::",
    "Observed Examples": "::REFERENCE:CVE-2008-3775:DESCRIPTION:Product uses ROT-25 to obfuscate the password in the registry.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3775REFERENCE:CVE-2007-4150:DESCRIPTION:product only uses XOR to obfuscate sensitive data:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4150REFERENCE:CVE-2007-5460:DESCRIPTION:product only uses XOR and a fixed key to obfuscate sensitive data:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5460REFERENCE:CVE-2005-4860:DESCRIPTION:Product substitutes characters with other characters in a fixed way, and also leaves certain input characters unchanged.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-4860REFERENCE:CVE-2002-2058:DESCRIPTION:Attackers can infer private IP addresses by dividing each octet by the MD5 hash of '20'.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-2058REFERENCE:CVE-2008-3188:DESCRIPTION:Product uses DES when MD5 has been specified in the configuration, resulting in weaker-than-expected password hashes.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3188REFERENCE:CVE-2005-2946:DESCRIPTION:Default configuration of product uses MD5 instead of stronger algorithms that are available, simplifying forgery of certificates.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-2946REFERENCE:CVE-2007-6013:DESCRIPTION:Product uses the hash of a hash for authentication, allowing attackers to gain privileges if they can obtain the original hash.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6013",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "TAXONOMY NAME:CLASP:ENTRY NAME:Using a broken or risky cryptographic algorithm::::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A8:ENTRY NAME:Insecure Storage:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MSC30-C:ENTRY NAME:Do not use the rand() function for generating pseudorandom numbers:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MSC32-C:ENTRY NAME:Properly seed pseudorandom number generators:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT Java Secure Coding:ENTRY ID:MSC02-J:ENTRY NAME:Generate strong random numbers::",
    "Related Attack Patterns": "::::::::::::::",
    "Notes": "TYPE:Maintenance:NOTE:Relationships between CWE-310, CWE-326, and CWE-327 and all their children need to be reviewed and reorganized.::"
  },
  {
    "ID": 330,
    "Name": "Use of Insufficiently Random Values",
    "Weakness Abstraction": "Class",
    "Status": "Usable",
    "Description": "The software may use insufficiently random numbers or values in a security context that depends on unpredictable numbers.",
    "Extended Description": "When software generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that will be generated, and use this guess to impersonate another user or access sensitive information.",
    "Related Weaknesses": "",
    "Weakness Ordinalities": "::ORDINALITY:Primary:DESCRIPTION:::",
    "Applicable Platforms": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "::Computers are deterministic machines, and as such are unable to produce true randomness. Pseudo-Random Number Generators (PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated. There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties, but their output is highly predictable and forms an easy to reproduce numeric stream that is unsuitable for use in cases where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between it and a truly random value.::",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:SCOPE:Other:TECHNICAL IMPACT:Other:NOTE:Confidentiality Other Other When a protection mechanism relies on random values to restrict access to a sensitive resource, such as a session ID or a seed for generating a cryptographic key, then the resource being protected could be accessed by guessing the ID or key.::SCOPE:Access Control:SCOPE:Other:TECHNICAL IMPACT:Bypass Protection Mechanism Other:NOTE:Access Control Other Bypass Protection Mechanism Other If software relies on unique, unguessable IDs to identify a resource, an attacker might be able to guess an ID for a resource that is owned by another user. The attacker could then read the resource, or pre-create a resource with the same ID to prevent the legitimate program from properly sending the resource to the intended user. For example, a product might maintain session information in a file whose name is based on a username. An attacker could pre-create this file for a victim user, then set the permissions so that the application cannot generate the session for the victim, preventing the victim from using the application.::SCOPE:Access Control:TECHNICAL IMPACT:Bypass Protection Mechanism Gain Privileges or Assume Identity:NOTE:Access Control Bypass Protection Mechanism Gain Privileges or Assume Identity When an authorization or authentication mechanism relies on random values to restrict access to restricted functionality, such as a session ID or a seed for generating a cryptographic key, then an attacker may access the restricted functionality by guessing the ID or key.::",
    "Detection Methods": "::METHOD:Black Box:EFFECTIVENESS::DESCRIPTION:Use monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process\n352,",
    "Potential Mitigations": "Compound",
    "Observed Examples": "Draft",
    "Functional Areas": "The web application does not, or can not, sufficiently verify whether a well-formed, valid, consistent request was intentionally provided by the user who submitted the request.",
    "Affected Resources": "When a web server is designed to receive a request from a client without any mechanism for verifying that it was intentionally sent, then it might be possible for an attacker to trick a client into making an unintentional request to the web server which will be treated as an authentic request. This can be done via a URL, image load, XMLHttpRequest, etc. and can result in exposure of data or unintended code execution.",
    "Taxonomy Mappings": "::NATURE:ChildOf:CWE ID:345:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:345:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:345:VIEW ID:1003:ORDINAL:Primary::NATURE:Requires:CWE ID:346:VIEW ID:1000::NATURE:Requires:CWE ID:441:VIEW ID:1000::NATURE:Requires:CWE ID:642:VIEW ID:1000::NATURE:Requires:CWE ID:613:VIEW ID:1000::",
    "Related Attack Patterns": "",
    "Notes": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY NAME:Web Server:TECHNOLOGY PREVALENCE:Undetermined::"
  },
  {
    "ID": 362,
    "Name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "Weakness Abstraction": "Class",
    "Status": "Draft",
    "Description": "The program contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.",
    "Extended Description": "This can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider. A race condition occurs within concurrent environments, and is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc. A race condition violates these properties, which are closely related: Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution. Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource. A race condition exists when an interfering code sequence can still access the shared resource, violating exclusivity. Programmers may assume that certain code sequences execute too quickly to be affected by an interfering code sequence\n434,",
    "Related Weaknesses": "Base",
    "Weakness Ordinalities": "Draft",
    "Applicable Platforms": "The software allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.",
    "Background Details": "",
    "Alternate Terms": "::NATURE:ChildOf:CWE ID:669:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:669:VIEW ID:1003:ORDINAL:Primary::NATURE:PeerOf:CWE ID:351:VIEW ID:1000::NATURE:PeerOf:CWE ID:436:VIEW ID:1000::NATURE:PeerOf:CWE ID:430:VIEW ID:1000::",
    "Modes Of Introduction": "::ORDINALITY:Primary:DESCRIPTION:This can be primary when there is no check at all.::ORDINALITY:Resultant:DESCRIPTION:This is frequently resultant when use of double extensions (e.g. .php.gif) bypasses a sanity check.::ORDINALITY:Resultant:DESCRIPTION:This can be resultant from client-side enforcement (CWE-602)\n456,",
    "Exploitation Factors": "Base",
    "Likelihood of Exploit": "Draft",
    "Common Consequences": "The software does not initialize critical variables, which causes the execution environment to use unexpected values.",
    "Detection Methods": "",
    "Potential Mitigations": "::NATURE:ChildOf:CWE ID:909:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:89:VIEW ID:1000::NATURE:CanPrecede:CWE ID:120:VIEW ID:1000::NATURE:CanPrecede:CWE ID:98:VIEW ID:1000::NATURE:CanPrecede:CWE ID:457:VIEW ID:1000::NATURE:CanPrecede:CWE ID:457:VIEW ID:699::",
    "Observed Examples": "",
    "Functional Areas": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::",
    "Affected Resources": "",
    "Taxonomy Mappings": "",
    "Related Attack Patterns": ":::PHASE:Implementation:DESCRIPTION:::",
    "Notes": ""
  },
  {
    "ID": 476,
    "Name": "NULL Pointer Dereference",
    "Weakness Abstraction": "Base",
    "Status": "Draft",
    "Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
    "Extended Description": "NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::",
    "Weakness Ordinalities": "::ORDINALITY:Resultant:DESCRIPTION:NULL pointer dereferences are frequently resultant from rarely encountered error conditions, since these are most likely to escape detection during the testing phases.::",
    "Applicable Platforms": "::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:Java:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C#:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Implementation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart:NOTE:Availability DoS: Crash, Exit, or Restart NULL pointer dereferences usually result in the failure of the process unless exception handling (on some platforms) is available and implemented. Even when exception handling is being used, it can still be very difficult to return the software to a safe state of operation.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:TECHNICAL IMPACT:Execute Unauthorized Code or Commands:NOTE:Integrity Confidentiality Availability Execute Unauthorized Code or Commands In very rare circumstances and environments, code execution is possible.::",
    "Detection Methods": "::METHOD:Automated Dynamic Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Dynamic Analysis:EFFECTIVENESS::DESCRIPTION:Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself.::",
    "Potential Mitigations": "::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:If all pointers that could have been modified are sanity-checked previous to use, nearly all NULL pointer dereferences can be prevented.::PHASE:Requirements:STRATEGY::EFFECTIVENESS::DESCRIPTION:The choice could be made to use a language that is not susceptible to these issues.::PHASE:Implementation:STRATEGY::EFFECTIVENESS:Moderate:DESCRIPTION:Check the results of all functions that return a value and verify that the value is non-null before acting upon it.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Explicitly initialize all your variables and other data stores, either during declaration or just before the first usage.::PHASE:Testing:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.::",
    "Observed Examples": "::REFERENCE:CVE-2005-3274:DESCRIPTION:race condition causes a table to be corrupted if a timer activates while it is being modified, leading to resultant NULL dereference\n494,",
    "Functional Areas": "Base",
    "Affected Resources": "Draft",
    "Taxonomy Mappings": "The product downloads source code or an executable from a remote location and executes the code without sufficiently verifying the origin and integrity of the code.",
    "Related Attack Patterns": "An attacker can execute malicious code by compromising the host server, performing DNS spoofing, or modifying the code in transit.",
    "Notes": "::NATURE:ChildOf:CWE ID:669:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:79:VIEW ID:1000::"
  },
  {
    "ID": 676,
    "Name": "Use of Potentially Dangerous Function",
    "Weakness Abstraction": "Base",
    "Status": "Draft",
    "Description": "The program invokes a potentially dangerous function that could introduce a vulnerability if it is used incorrectly, but the function can also be used safely.",
    "Extended Description": "",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:710:VIEW ID:1000:ORDINAL:Primary::",
    "Weakness Ordinalities": "::ORDINALITY:Primary:DESCRIPTION:::",
    "Applicable Platforms": "::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Other:TECHNICAL IMPACT:Varies by Context Quality Degradation Unexpected State:NOTE:Other Varies by Context Quality Degradation Unexpected State If the function is used incorrectly, then it could result in security problems.::",
    "Detection Methods": "::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary / Bytecode Quality Analysis Binary / Bytecode simple extractor â€“ strings, ELF readers, etc.::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Debugger Cost effective for partial coverage: Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Warning Flags Source Code Quality Analyzer::METHOD:Automated Static Analysis:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Origin Analysis::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::",
    "Potential Mitigations": "::PHASE:Build and Compilation Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Identify a list of prohibited API functions and prohibit developers from using these functions, providing safer alternatives. In some cases, automatic code analysis tools or the compiler can be instructed to spot use of prohibited functions, such as the banned.h include file from Microsoft's SDL. [REF-554] [REF-7]::",
    "Observed Examples": "::REFERENCE:CVE-2007-1470:DESCRIPTION:Library has multiple buffer overflows using sprintf() and strcpy():LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-1470REFERENCE:CVE-2009-3849:DESCRIPTION:Buffer overflow using strcat():LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3849REFERENCE:CVE-2006-2114:DESCRIPTION:Buffer overflow using strcpy():LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-2114REFERENCE:CVE-2006-0963:DESCRIPTION:Buffer overflow using strcpy():LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-0963REFERENCE:CVE-2011-0712:DESCRIPTION:Vulnerable use of strcpy() changed to use safer strlcpy():LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0712REFERENCE:CVE-2008-5005:DESCRIPTION:Buffer overflow using strcpy():LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5005",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Dangerous Functions::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:CON33-C:ENTRY NAME:Avoid race conditions when using library functions:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ENV33-C:ENTRY NAME:Do not call system():MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ERR07-C:ENTRY NAME:Prefer functions that support error checking over equivalent functions that don't::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ERR34-C:ENTRY NAME:Detect errors when converting a string to a number:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FIO01-C:ENTRY NAME:Be careful using functions that use file names for identification::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MSC30-C:ENTRY NAME:Do not use the rand() function for generating pseudorandom numbers:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:Imprecise::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP3:ENTRY NAME:Use of an improper API::",
    "Related Attack Patterns": "",
    "Notes": "TYPE:Relationship:NOTE:This weakness is different than CWE-242 (Use of Inherently Dangerous Function). CWE-242 covers functions with such significant security problems that they can never be guaranteed to be safe. Some functions, if used properly, do not directly pose a security risk, but can introduce a weakness if not called correctly. These are regarded as potentially dangerous. A well-known example is the strcpy() function. When provided with a destination buffer that is larger than its source, strcpy() will not overflow. However, it is so often misused that some developers prohibit strcpy() entirely.::"
  },
  {
    "ID": 681,
    "Name": "Incorrect Conversion between Numeric Types",
    "Weakness Abstraction": "Class",
    "Status": "Draft",
    "Description": "When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur.",
    "Extended Description": "",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:704:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:682:VIEW ID:1000::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Implementation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Other:SCOPE:Integrity:TECHNICAL IMPACT:Unexpected State Quality Degradation:NOTE:Other Integrity Unexpected State Quality Degradation The program could wind up using the wrong number and generate incorrect results. If the number is used to allocate resources or make a security decision, then this could introduce a vulnerability.::",
    "Detection Methods": "",
    "Potential Mitigations": "::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Avoid making conversion between numeric types. Always check for the allowed ranges.::",
    "Observed Examples": "::REFERENCE:CVE-2007-4268:DESCRIPTION:Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122):LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4268REFERENCE:CVE-2007-4988:DESCRIPTION:Chain: signed short width value in image processor is sign extended during conversion to unsigned int, which leads to integer overflow and heap-based buffer overflow.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4988REFERENCE:CVE-2009-0231:DESCRIPTION:Integer truncation of length value leads to heap-based buffer overflow.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0231REFERENCE:CVE-2008-3282:DESCRIPTION:Size of a particular type changes for 64-bit platforms, leading to an integer truncation in document processor causes incorrect index to be generated.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3282",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:FLP34-C:ENTRY NAME:Ensure that floating point conversions are within range of the new type:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT15-C:ENTRY NAME:Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT31-C:ENTRY NAME:Ensure that integer conversions do not result in lost or misinterpreted data:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT35-C:ENTRY NAME:Evaluate integer expressions in a larger size before comparing or assigning to that size::::TAXONOMY NAME:CERT Java Secure Coding:ENTRY ID:NUM12-J:ENTRY NAME:Ensure conversions of numeric types to narrower types do not result in lost or misinterpreted data::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP1:ENTRY NAME:Glitch in computation::",
    "Related Attack Patterns": "",
    "Notes": ""
  },
  {
    "ID": 732,
    "Name": "Incorrect Permission Assignment for Critical Resource",
    "Weakness Abstraction": "Class",
    "Status": "Draft",
    "Description": "The software specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.",
    "Extended Description": "When a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:285:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:668:VIEW ID:1000::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION::::PHASE:Installation:DESCRIPTION::::PHASE:Operation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Application Data Read Files or Directories:NOTE:Confidentiality Read Application Data Read Files or Directories An attacker may be able to read sensitive information from the associated resource, such as credentials or configuration information stored in a file.::SCOPE:Access Control:TECHNICAL IMPACT:Gain Privileges or Assume Identity:NOTE:Access Control Gain Privileges or Assume Identity An attacker may be able to modify critical properties of the associated resource to gain privileges, such as replacing a world-writable executable with a Trojan horse.::SCOPE:Integrity:SCOPE:Other:TECHNICAL IMPACT:Modify Application Data Other:NOTE:Integrity Other Modify Application Data Other An attacker may be able to destroy or corrupt critical data in the associated resource, such as deletion of records from a database.::",
    "Detection Methods": "::METHOD:Automated Static Analysis:EFFECTIVENESS::DESCRIPTION:Automated static analysis may be effective in detecting permission problems for system resources such as files, directories, shared memory, device interfaces, etc. Automated techniques may be able to detect the use of library functions that modify permissions, then analyze function calls for arguments that contain potentially insecure values. However, since the software's intended security policy might allow loose permissions for certain operations (such as publishing a file on a web server), automated static analysis may produce some false positives - i.e., warnings that do not have any security consequences or require any code changes. When custom permissions models are used - such as defining who can read messages in a particular forum in a bulletin board system - these can be difficult to detect using automated static analysis. It may be possible to define custom signatures that identify any custom functions that implement the permission checks and assignments.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS::DESCRIPTION:Automated dynamic analysis may be effective in detecting permission problems for system resources such as files, directories, shared memory, device interfaces, etc. However, since the software's intended security policy might allow loose permissions for certain operations (such as publishing a file on a web server), automated dynamic analysis may produce some false positives - i.e., warnings that do not have any security consequences or require any code changes. When custom permissions models are used - such as defining who can read messages in a particular forum in a bulletin board system - these can be difficult to detect using automated dynamic analysis. It may be possible to define custom signatures that identify any custom functions that implement the permission checks and assignments.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session.::METHOD:Manual Static Analysis:EFFECTIVENESS::DESCRIPTION:Manual static analysis may be effective in detecting the use of custom permissions models and functions. The code could then be examined to identifying usage of the related functions. Then the human analyst could evaluate permission assignments in the context of the intended security model of the software.::METHOD:Manual Dynamic Analysis:EFFECTIVENESS::DESCRIPTION:Manual dynamic analysis may be effective in detecting the use of custom permissions models and functions. The program could then be executed with a focus on exercising code paths that are related to the custom permissions. Then the human analyst could evaluate permission assignments in the context of the intended security model of the software.::METHOD:Fuzzing:EFFECTIVENESS::DESCRIPTION:Fuzzing is not effective in detecting this weakness.::METHOD:Black Box:EFFECTIVENESS::DESCRIPTION:Use monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process\n754,",
    "Potential Mitigations": "Class",
    "Observed Examples": "Incomplete",
    "Functional Areas": "The software does not check or improperly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the software.",
    "Affected Resources": "The programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability. Note that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.",
    "Taxonomy Mappings": "::NATURE:ChildOf:CWE ID:703:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:703:VIEW ID:1000:ORDINAL:Primary::",
    "Related Attack Patterns": "",
    "Notes": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::"
  },
  {
    "ID": 822,
    "Name": "Untrusted Pointer Dereference",
    "Weakness Abstraction": "Base",
    "Status": "Incomplete",
    "Description": "The program obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
    "Extended Description": "An attacker can supply a pointer for memory locations that the program is not expecting. If the pointer is dereferenced for a write operation, the attack might allow modification of critical program state variables, cause a crash, or execute code. If the dereferencing operation is for a read, then the attack might allow reading of sensitive data, cause a crash, or set a program variable to an unexpected value (since the value will be read from an unexpected memory location). There are several variants of this weakness, including but not necessarily limited to: The untrusted value is directly invoked as a function call. In OS kernels or drivers where there is a boundary between userland and privileged memory spaces, an untrusted pointer might enter through an API or system call (see CWE-781 for one such example). Inadvertently accepting the value from an untrusted control sphere when it did not have to be accepted as input at all. This might occur when the code was originally developed to be run by a single user in a non-networked environment, and the code is then ported to or otherwise exposed to a networked environment.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:699:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:125:VIEW ID:1000::NATURE:CanPrecede:CWE ID:787:VIEW ID:1000::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": "",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": "",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Memory:NOTE:Confidentiality Read Memory If the untrusted pointer is used in a read operation, an attacker might be able to read sensitive portions of memory.::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart:NOTE:Availability DoS: Crash, Exit, or Restart If the untrusted pointer references a memory location that is not accessible to the program, or points to a location that is malformed or larger than expected by a read or write operation, the application may terminate unexpectedly.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:TECHNICAL IMPACT:Execute Unauthorized Code or Commands Modify Memory:NOTE:Integrity Confidentiality Availability Execute Unauthorized Code or Commands Modify Memory If the untrusted pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible.::",
    "Detection Methods": "",
    "Potential Mitigations": "",
    "Observed Examples": "::REFERENCE:CVE-2007-5655:DESCRIPTION:message-passing framework interprets values in packets as pointers, causing a crash.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5655REFERENCE:CVE-2010-2299:DESCRIPTION:labeled as a type confusion issue, also referred to as a stale pointer. However, the bug ID says contents are simply interpreted as a pointer... renderer ordinarily doesn't supply this pointer directly. The handle in the untrusted area is replaced in one function, but not another - thus also, effectively, exposure to wrong sphere (CWE-668).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2299REFERENCE:CVE-2009-1719:DESCRIPTION:Untrusted dereference using undocumented constructor.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1719REFERENCE:CVE-2009-1250:DESCRIPTION:An error code is incorrectly checked and interpreted as a pointer, leading to a crash.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1250REFERENCE:CVE-2009-0311:DESCRIPTION:An untrusted value is obtained from a packet and directly called as a function pointer, leading to code execution.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0311REFERENCE:CVE-2010-1818:DESCRIPTION:Undocumented attribute in multimedia software allows unmarshaling of an untrusted pointer.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1818REFERENCE:CVE-2010-3189:DESCRIPTION:ActiveX control for security software accepts a parameter that is assumed to be an initialized pointer.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3189REFERENCE:CVE-2010-1253:DESCRIPTION:Spreadsheet software treats certain record values that lead to user-controlled pointer (might be untrusted offset, not untrusted pointer).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1253",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "",
    "Related Attack Patterns": "",
    "Notes": "TYPE:Maintenance:NOTE:There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.::::TYPE:Terminology:NOTE:Many weaknesses related to pointer dereferences fall under the general term of memory corruption or memory safety. As of September 2010, there is no commonly-used terminology that covers the lower-level variants.::::TYPE:Research Gap:NOTE:Under-studied and probably under-reported as of September 2010. This weakness has been reported in high-visibility software, but applied vulnerability researchers have only been investigating it since approximately 2008, and there are only a few public reports. Few reports identify weaknesses at such a low level, which makes it more difficult to find and study real-world code examples.::"
  },
  {
    "ID": 825,
    "Name": "Expired Pointer Dereference",
    "Weakness Abstraction": "Base",
    "Status": "Incomplete",
    "Description": "The program dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid.",
    "Extended Description": "When a program releases memory, but it maintains a pointer to that memory, then the memory might be re-allocated at a later time. If the original pointer is accessed to read or write data, then this could cause the program to read or modify data that is in use by a different function or process. Depending on how the newly-allocated memory is used, this could lead to a denial of service, information exposure, or code execution.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:672:VIEW ID:1000::NATURE:ChildOf:CWE ID:672:VIEW ID:699::NATURE:CanPrecede:CWE ID:125:VIEW ID:1000::NATURE:CanPrecede:CWE ID:787:VIEW ID:1000::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": "",
    "Background Details": "",
    "Alternate Terms": "::TERM:Dangling pointer:DESCRIPTION:::",
    "Modes Of Introduction": "",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Memory:NOTE:Confidentiality Read Memory If the expired pointer is used in a read operation, an attacker might be able to control data read in by the application.::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart:NOTE:Availability DoS: Crash, Exit, or Restart If the expired pointer references a memory location that is not accessible to the program, or points to a location that is malformed (such as NULL) or larger than expected by a read or write operation, then a crash may occur.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:TECHNICAL IMPACT:Execute Unauthorized Code or Commands:NOTE:Integrity Confidentiality Availability Execute Unauthorized Code or Commands If the expired pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible.::",
    "Detection Methods": "",
    "Potential Mitigations": "::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:Choose a language that provides automatic memory management.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.::",
    "Observed Examples": "::REFERENCE:CVE-2008-5013:DESCRIPTION:access of expired memory address leads to arbitrary code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5013REFERENCE:CVE-2010-3257:DESCRIPTION:stale pointer issue leads to denial of service and possibly other consequences:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3257REFERENCE:CVE-2007-1211:DESCRIPTION:read of value at an offset into a structure after the offset is no longer valid:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-1211",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "",
    "Related Attack Patterns": "",
    "Notes": "TYPE:Maintenance:NOTE:There are close relationships between incorrect pointer dereferences and other weaknesses related to buffer operations. There may not be sufficient community agreement regarding these relationships. Further study is needed to determine when these relationships are chains, composites, perspective/layering, or other types of relationships. As of September 2010, most of the relationships are being captured as chains.::::TYPE:Terminology:NOTE:Many weaknesses related to pointer dereferences fall under the general term of memory corruption or memory safety. As of September 2010, there is no commonly-used terminology that covers the lower-level variants.::::TYPE:Research Gap:NOTE:Under-studied and probably under-reported as of September 2010. This weakness has been reported in high-visibility software, but applied vulnerability researchers have only been investigating it since approximately 2008, and there are only a few public reports. Few reports identify weaknesses at such a low level, which makes it more difficult to find and study real-world code examples.::"
  },
  {
    "ID": 829,
    "Name": "Inclusion of Functionality from Untrusted Control Sphere",
    "Weakness Abstraction": "Class",
    "Status": "Incomplete",
    "Description": "The software imports, requires, or includes executable functionality (such as a library) from a source that is outside of the intended control sphere.",
    "Extended Description": "When including third-party functionality, such as a web widget, library, or other source of functionality, the software must effectively trust that functionality. Without sufficient protection mechanisms, the functionality could be malicious in nature (either by coming from an untrusted source, being spoofed, or being modified in transit from a trusted source). The functionality might also contain its own weaknesses, or grant access to additional functionality and state information that should be kept private to the base system, such as system state information, sensitive application data, or the DOM of a web application. This might lead to many different consequences depending on the included functionality, but some examples include injection of malware, information exposure by granting excessive privileges or permissions to the untrusted functionality, DOM-based XSS vulnerabilities, stealing user's cookies, or open redirect to malware (CWE-601).",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:669:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:669:VIEW ID:699:ORDINAL:Primary::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": "",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Implementation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:SCOPE:Integrity:SCOPE:Availability:TECHNICAL IMPACT:Execute Unauthorized Code or Commands:NOTE:Confidentiality Integrity Availability Execute Unauthorized Code or Commands An attacker could insert malicious functionality into the program by causing the program to download code that the attacker has placed into the untrusted control sphere, such as a malicious web site.::",
    "Detection Methods": "::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Forced Path Execution Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling::",
    "Potential Mitigations": "::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:EFFECTIVENESS::DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs. For example, ID 1 could map to inbox.txt and ID 2 could map to profile.txt. Features such as the ESAPI AccessReferenceMap [REF-45] provide this capability.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:EFFECTIVENESS:Limited:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system\n838,",
    "Observed Examples": "Base",
    "Functional Areas": "Incomplete",
    "Affected Resources": "The software uses or specifies an encoding when generating output to a downstream component, but the specified encoding is not the same as the encoding that is expected by the downstream component.",
    "Taxonomy Mappings": "This weakness can cause the downstream component to use a decoding method that produces different data than what the software intended to send. When the wrong encoding is used - even if closely related - the downstream component could decode the data incorrectly. This can have security consequences when the provided boundaries between control and data are inadvertently broken, because the resulting data could introduce control characters or special elements that were not sent by the software. The resulting data could then be used to bypass protection mechanisms such as input validation, and enable injection attacks. While using output encoding is essential for ensuring that communications between components are accurate, the use of the wrong encoding - even if closely related - could cause the downstream component to misinterpret the output. For example, HTML entity encoding is used for elements in the HTML body of a web page. However, a programmer might use entity encoding when generating output for that is used within an attribute of an HTML tag, which could contain functional Javascript that is not affected by the HTML encoding. While web applications have received the most attention for this problem, this weakness could potentially apply to any type of software that uses a communications stream that could support multiple encodings.",
    "Related Attack Patterns": "::NATURE:ChildOf:CWE ID:116:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:116:VIEW ID:699:ORDINAL:Primary::",
    "Notes": ""
  },
  {
    "ID": 89,
    "Name": "Improper Neutralization of Special Elements used in an SQL Command (SQL Injection)",
    "Weakness Abstraction": "Base",
    "Status": "Draft",
    "Description": "The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.",
    "Extended Description": "Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands. SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or software package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:943:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:943:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:943:VIEW ID:1003:ORDINAL:Primary::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY NAME:Database Server:TECHNOLOGY PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION::::PHASE:Operation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Application Data:NOTE:Confidentiality Read Application Data Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with SQL injection vulnerabilities.::SCOPE:Access Control:TECHNICAL IMPACT:Bypass Protection Mechanism:NOTE:Access Control Bypass Protection Mechanism If poor SQL commands are used to check user names and passwords, it may be possible to connect to a system as another user with no previous knowledge of the password.::SCOPE:Access Control:TECHNICAL IMPACT:Bypass Protection Mechanism:NOTE:Access Control Bypass Protection Mechanism If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a SQL injection vulnerability.::SCOPE:Integrity:TECHNICAL IMPACT:Modify Application Data:NOTE:Integrity Modify Application Data Just as it may be possible to read sensitive information, it is also possible to make changes or even delete this information with a SQL injection attack.::",
    "Detection Methods": "::METHOD:Automated Static Analysis:EFFECTIVENESS::DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or do not require any code changes. Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke SQL commands, leading to false negatives - especially if the API/library code is not available for analysis.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Database Scanners Cost effective for partial coverage: Web Application Scanner Web Services Scanner::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::",
    "Potential Mitigations": "::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.::PHASE:Architecture and Design:STRATEGY:Parameterization:EFFECTIVENESS::DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY:Output Encoding:EFFECTIVENESS::DESCRIPTION:While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name O'Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:EFFECTIVENESS::DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.::PHASE:Operation:STRATEGY:Firewall:EFFECTIVENESS:Moderate:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.::PHASE:Operation Implementation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::",
    "Observed Examples": "::REFERENCE:CVE-2004-0366:DESCRIPTION:chain: SQL injection in library intended for database authentication allows SQL injection and authentication bypass.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0366REFERENCE:CVE-2008-2790:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2790REFERENCE:CVE-2008-2223:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2223REFERENCE:CVE-2007-6602:DESCRIPTION:SQL injection via user name.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6602REFERENCE:CVE-2008-5817:DESCRIPTION:SQL injection via user name or password fields.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5817REFERENCE:CVE-2003-0377:DESCRIPTION:SQL injection in security product, using a crafted group name.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0377REFERENCE:CVE-2008-2380:DESCRIPTION:SQL injection in authentication library.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2380REFERENCE:CVE-2017-11508:DESCRIPTION:SQL injection in vulnerability management and reporting tool, using a crafted password.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11508",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "TAXONOMY NAME:PLOVER:ENTRY NAME:SQL injection::::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:SQL Injection::::TAXONOMY NAME:CLASP:ENTRY NAME:SQL injection::::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A2:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A1:ENTRY NAME:Unvalidated Input:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A6:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:WASC:ENTRY ID:19:ENTRY NAME:SQL Injection::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",
    "Related Attack Patterns": "::::::::::::::",
    "Notes": "TYPE:Relationship:NOTE:SQL injection can be resultant from special character mismanagement, MAID, or blacklist/whitelist problems. It can be primary to authentication errors.::"
  },
  {
    "ID": 306,
    "Name": "Missing Authentication for Critical Function.",
    "Weakness Abstraction": "Base",
    "Status": "Draft",
    "Description": "The software does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
    "Extended Description": "Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands. SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or software package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:943:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:943:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:943:VIEW ID:1003:ORDINAL:Primary::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY NAME:Database Server:TECHNOLOGY PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION::::PHASE:Operation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Application Data:NOTE:Confidentiality Read Application Data Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with SQL injection vulnerabilities.::SCOPE:Access Control:TECHNICAL IMPACT:Bypass Protection Mechanism:NOTE:Access Control Bypass Protection Mechanism If poor SQL commands are used to check user names and passwords, it may be possible to connect to a system as another user with no previous knowledge of the password.::SCOPE:Access Control:TECHNICAL IMPACT:Bypass Protection Mechanism:NOTE:Access Control Bypass Protection Mechanism If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a SQL injection vulnerability.::SCOPE:Integrity:TECHNICAL IMPACT:Modify Application Data:NOTE:Integrity Modify Application Data Just as it may be possible to read sensitive information, it is also possible to make changes or even delete this information with a SQL injection attack.::",
    "Detection Methods": "::METHOD:Automated Static Analysis:EFFECTIVENESS::DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or do not require any code changes. Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke SQL commands, leading to false negatives - especially if the API/library code is not available for analysis.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Database Scanners Cost effective for partial coverage: Web Application Scanner Web Services Scanner::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::",
    "Potential Mitigations": "::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.::PHASE:Architecture and Design:STRATEGY:Parameterization:EFFECTIVENESS::DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY:Output Encoding:EFFECTIVENESS::DESCRIPTION:While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name O'Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:EFFECTIVENESS::DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.::PHASE:Operation:STRATEGY:Firewall:EFFECTIVENESS:Moderate:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.::PHASE:Operation Implementation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::",
    "Observed Examples": "::REFERENCE:CVE-2004-0366:DESCRIPTION:chain: SQL injection in library intended for database authentication allows SQL injection and authentication bypass.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0366REFERENCE:CVE-2008-2790:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2790REFERENCE:CVE-2008-2223:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2223REFERENCE:CVE-2007-6602:DESCRIPTION:SQL injection via user name.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6602REFERENCE:CVE-2008-5817:DESCRIPTION:SQL injection via user name or password fields.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5817REFERENCE:CVE-2003-0377:DESCRIPTION:SQL injection in security product, using a crafted group name.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0377REFERENCE:CVE-2008-2380:DESCRIPTION:SQL injection in authentication library.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2380REFERENCE:CVE-2017-11508:DESCRIPTION:SQL injection in vulnerability management and reporting tool, using a crafted password.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11508",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "TAXONOMY NAME:PLOVER:ENTRY NAME:SQL injection::::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:SQL Injection::::TAXONOMY NAME:CLASP:ENTRY NAME:SQL injection::::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A2:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A1:ENTRY NAME:Unvalidated Input:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A6:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:WASC:ENTRY ID:19:ENTRY NAME:SQL Injection::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",
    "Related Attack Patterns": "::::::::::::::",
    "Notes": "TYPE:Relationship:NOTE:SQL injection can be resultant from special character mismanagement, MAID, or blacklist/whitelist problems. It can be primary to authentication errors.::"
  },
  {
    "ID": 78,
    "Name": " Improper Neutralization of Special Elements used in an OS Command (OS Command Injection)",
    "Weakness Abstraction": "Base",
    "Status": "Draft",
    "Description": "The software constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",
    "Extended Description": "Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands. SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or software package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.",
    "Related Weaknesses": "::NATURE:ChildOf:CWE ID:943:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:943:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:943:VIEW ID:1003:ORDINAL:Primary::",
    "Weakness Ordinalities": "",
    "Applicable Platforms": ":::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::TECHNOLOGY NAME:Database Server:TECHNOLOGY PREVALENCE:Undetermined::",
    "Background Details": "",
    "Alternate Terms": "",
    "Modes Of Introduction": ":::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION::::PHASE:Operation:DESCRIPTION:::",
    "Exploitation Factors": "",
    "Likelihood of Exploit": "",
    "Common Consequences": "::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Application Data:NOTE:Confidentiality Read Application Data Since SQL databases generally hold sensitive data, loss of confidentiality is a frequent problem with SQL injection vulnerabilities.::SCOPE:Access Control:TECHNICAL IMPACT:Bypass Protection Mechanism:NOTE:Access Control Bypass Protection Mechanism If poor SQL commands are used to check user names and passwords, it may be possible to connect to a system as another user with no previous knowledge of the password.::SCOPE:Access Control:TECHNICAL IMPACT:Bypass Protection Mechanism:NOTE:Access Control Bypass Protection Mechanism If authorization information is held in a SQL database, it may be possible to change this information through the successful exploitation of a SQL injection vulnerability.::SCOPE:Integrity:TECHNICAL IMPACT:Modify Application Data:NOTE:Integrity Modify Application Data Just as it may be possible to read sensitive information, it is also possible to make changes or even delete this information with a SQL injection attack.::",
    "Detection Methods": "::METHOD:Automated Static Analysis:EFFECTIVENESS::DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or do not require any code changes. Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke SQL commands, leading to false negatives - especially if the API/library code is not available for analysis.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Database Scanners Cost effective for partial coverage: Web Application Scanner Web Services Scanner::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::",
    "Potential Mitigations": "::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.::PHASE:Architecture and Design:STRATEGY:Parameterization:EFFECTIVENESS::DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY:Output Encoding:EFFECTIVENESS::DESCRIPTION:While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name O'Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:EFFECTIVENESS::DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.::PHASE:Operation:STRATEGY:Firewall:EFFECTIVENESS:Moderate:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.::PHASE:Operation Implementation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::",
    "Observed Examples": "::REFERENCE:CVE-2004-0366:DESCRIPTION:chain: SQL injection in library intended for database authentication allows SQL injection and authentication bypass.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0366REFERENCE:CVE-2008-2790:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2790REFERENCE:CVE-2008-2223:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2223REFERENCE:CVE-2007-6602:DESCRIPTION:SQL injection via user name.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-6602REFERENCE:CVE-2008-5817:DESCRIPTION:SQL injection via user name or password fields.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5817REFERENCE:CVE-2003-0377:DESCRIPTION:SQL injection in security product, using a crafted group name.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0377REFERENCE:CVE-2008-2380:DESCRIPTION:SQL injection in authentication library.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2380REFERENCE:CVE-2017-11508:DESCRIPTION:SQL injection in vulnerability management and reporting tool, using a crafted password.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11508",
    "Functional Areas": "",
    "Affected Resources": "",
    "Taxonomy Mappings": "TAXONOMY NAME:PLOVER:ENTRY NAME:SQL injection::::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:SQL Injection::::TAXONOMY NAME:CLASP:ENTRY NAME:SQL injection::::TAXONOMY NAME:OWASP Top Ten 2007:ENTRY ID:A2:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A1:ENTRY NAME:Unvalidated Input:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:OWASP Top Ten 2004:ENTRY ID:A6:ENTRY NAME:Injection Flaws:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:WASC:ENTRY ID:19:ENTRY NAME:SQL Injection::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP24:ENTRY NAME:Tainted input to command::",
    "Related Attack Patterns": "::::::::::::::",
    "Notes": "TYPE:Relationship:NOTE:SQL injection can be resultant from special character mismanagement, MAID, or blacklist/whitelist problems. It can be primary to authentication errors.::"
  }
]}